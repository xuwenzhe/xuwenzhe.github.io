[{"categories":null,"content":"1. Java反射机制概述 package com.atguigu.java; import org.junit.Test; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.Method; public class ReflectionTest { // 反射之前 @Test public void test1() { // 1. 创建Person类的对象 Person p1 = new Person(\"Tom\", 12); // 2. 通过对象，调用其内部的属性和方法 p1.age = 10; System.out.println(p1.toString()); p1.show(); // 在Person类的外部，不可以通过Person类的对象调用其内部的私有结构 // 比如：name, showNation(), 以及私有的构造器（封装性的限制） } // 反射之后，对于Person的操作 @Test public void test2() throws Exception { Class clazz = Person.class; // 1. 通过反射，创建Person类的对象 Constructor cons = clazz.getConstructor(String.class, int.class); Object obj = cons.newInstance(\"Tom\", 12); Person p = (Person) obj; System.out.println(obj.toString()); // 2. 通过反射，调用对象指定的属性和方法 Field age = clazz.getDeclaredField(\"age\"); age.set(p, 10); System.out.println(p.toString()); // 3. 调用方法 Method show = clazz.getDeclaredMethod(\"show\"); show.invoke(p); // 4. 通过反射，可以调用Person类的私有结构的。比如：私有的构造器，属性，方法 Constructor cons1 = clazz.getDeclaredConstructor(String.class); cons1.setAccessible(true); Person p1 = (Person) cons1.newInstance(\"Jerry\"); System.out.println(p1.toString()); // 调用私有的属性 Field name = clazz.getDeclaredField(\"name\"); name.setAccessible(true); name.set(p1, \"HanMeimei\"); // 调用私有方法 Method showNation = clazz.getDeclaredMethod(\"showNation\", String.class); showNation.setAccessible(true); String nation = (String) showNation.invoke(p1, \"中国\"); System.out.println(nation); } // 疑问：通过直接new的方式或反射的方式都可以调用公共的结构，开发中到底用哪个？ // 建议：直接new的方式 // 疑问：什么时候会用到反射的方式调用？ // 反射的特征：动态性 // 疑问：反射机制与面向对象中的封装性是不是矛盾的？如何看待两个技术？ // 不矛盾。封装性可以理解为不建议调用private结构 // 获取Class实例的方式 @Test public void test3() throws ClassNotFoundException { // 方式一：调用运行时类的属性: .class Class\u003cPerson\u003e clazz1 = Person.class; System.out.println(clazz1); // 方式二：通过运行时类的对象, 调用getClass() Person p1 = new Person(); Class clazz2 = p1.getClass(); System.out.println(clazz2); // 方式三(开发中常用)：调用Class的静态方法：forName(String classPath) Class clazz3 = Class.forName(\"com.atguigu.java.Person\"); System.out.println(clazz3); System.out.println(clazz1 == clazz2); System.out.println(clazz2 == clazz3); // 方式四：使用类的加载器：ClassLoader ClassLoader classLoader = ReflectionTest.class.getClassLoader(); Class clazz4 = classLoader.loadClass(\"com.atguigu.java.Person\"); System.out.println(clazz4 == clazz3); } } package com.atguigu.java; public class Person { private String name; public int age; public Person() { System.out.println(\"Person()\"); } public Person(String name, int age) { this.name = name; this.age = age; } private Person(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \"Person{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } public void show() { System.out.println(\"你好，我是一个人\"); } private String showNation(String nation) { System.out.println(\"我的国籍是：\" + nation); return nation; } } ","date":"2021-08-23","objectID":"/java-shk-12/:1:0","tags":null,"title":"Java零基础教程（十二.反射Reflection）","uri":"/java-shk-12/"},{"categories":null,"content":"2. 理解Class类并获取Class实例 关于java.lang.Class类的理解 类的加载过程：程序经过java.exe命令后，会生成一个或多个字节码文件（.class结尾），接着我们使用java.exe命令对某个字节码文件进行解释运行。相当于将某个字节码文件加载到内存中。此过程就称为类的加载。加载到内存中的类，我们就称为运行时类，此运行时类就作为Class的一个实例。 换句话说，Class的实例就对应着一个运行时类. 加载到内存中的运行时类，会缓存一定的时间。在此时间之内，我们可以通过不同的方式来获取此运行时类。注意这里是\"获取”，不是\"创建”， 因为运行时已经加载到内存中。 万事万物皆对象？对象，File，URL，类也是对象（反射），数据库操作 ","date":"2021-08-23","objectID":"/java-shk-12/:2:0","tags":null,"title":"Java零基础教程（十二.反射Reflection）","uri":"/java-shk-12/"},{"categories":null,"content":"3. 类的加载与ClassLoader的理解 package com.atguigu.java; import org.junit.Test; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.IOException; import java.io.InputStream; import java.util.Properties; public class ClassLoaderTest { @Test public void test1() { // 对于自定义类，使用系统类加载器进行加载 ClassLoader classLoader = ClassLoaderTest.class.getClassLoader(); System.out.println(classLoader); // 调用系统类加载器的getParent():获取扩展类加载器 ClassLoader classLoader1 = classLoader.getParent(); System.out.println(classLoader1); // 调用扩展类加载器的getParent()：无法获取引导类加载器 // 引导类加载器主要负责加载java的核心类库，无法加载自定义类的 ClassLoader classLoader2 = classLoader1.getParent(); System.out.println(classLoader2); ClassLoader classLoader3 = String.class.getClassLoader(); System.out.println(classLoader3); } /* Properties:用来读取配置文件 */ @Test public void test2() throws IOException { Properties pros = new Properties(); // 此时的文件默认在当前module下 // 读取配置文件的方式一 FileInputStream fis = new FileInputStream(\"jdbc.properties\"); // 读取配置文件的方式二：使用ClassLoader // 配置文件默认识别为：当前module的src下 // ClassLoader classLoader = ClassLoaderTest.class.getClassLoader(); // InputStream is = classLoader.getResourceAsStream(\"jdbc1.properties\"); pros.load(fis); String user = pros.getProperty(\"user\"); String password = pros.getProperty(\"password\"); System.out.println(\"user = \" + user + \", password = \" + password); } } ","date":"2021-08-23","objectID":"/java-shk-12/:3:0","tags":null,"title":"Java零基础教程（十二.反射Reflection）","uri":"/java-shk-12/"},{"categories":null,"content":"4. 创建运行时类的对象 package com.atguigu.java; import org.junit.Test; import java.util.Random; /* 通过反射创建对应的运行时类的对象 */ public class NewInstanceTest { @Test public void test1() throws IllegalAccessException, InstantiationException { Class\u003cPerson\u003e clazz = Person.class; /* newInstance(): 调用此方法，创建对应的运行时类的对象.内部调用了运行时类的空参构造器 要想此方法正常地创建运行时类的对象，要求： 1. 运行时类必须提供空参的构造器 2. 空参的构造器的访问权限得够。通常，设置为public 在javabean中要求提供一个public的空参构造器，原因： 1. 便于通过反射，创建运行时类的对象 2. 便于子类继承此运行时类时，默认调用super()时，保证父类有此构造器 */ Person obj = clazz.newInstance(); System.out.println(obj); } // 体会反射的动态性 @Test public void test2() { int num = new Random().nextInt(3);// 0, 1, 2 String classPath = \"\"; switch (num) { case 0: classPath = \"java.util.Date\"; break; case 1: classPath = \"java.lang.Object\"; break; case 2: classPath = \"com.atguigu.java.Person\"; break; } Object obj = null; try { obj = getInstance(classPath); System.out.println(obj); } catch (Exception e) { e.printStackTrace(); } } /* 创建一个指定类的对象 classPath:指定类的全类名 */ public Object getInstance(String classPath) throws Exception { Class clazz = Class.forName(classPath); return clazz.newInstance(); } } ","date":"2021-08-23","objectID":"/java-shk-12/:4:0","tags":null,"title":"Java零基础教程（十二.反射Reflection）","uri":"/java-shk-12/"},{"categories":null,"content":"5. 获取运行时类的完整结构 定义父类Creature package com.atguigu.java1; import java.io.Serializable; public class Creature\u003cT\u003e implements Serializable { private char gender; public double weight; private void breath() { System.out.println(\"生物呼吸\"); } public void eat() { System.out.println(\"生物吃东西\"); } } 定义子类Person package com.atguigu.java1; @MyAnnotation(value=\"hi\") public class Person extends Creature\u003cString\u003e implements Comparable\u003cString\u003e, MyInterface { private String name; int age; public int id; public Person() { } @MyAnnotation(value=\"abc\") private Person(String name) { this.name = name; } Person(String name, int age) { this.name = name; this.age = age; } @MyAnnotation private void show(String nation){ System.out.println(\"我的国籍是：\" + nation); } public String display(String interest) throws NullPointerException, ClassCastException { return interest; } @Override public void info() { System.out.println(\"我是一个人\"); } @Override public int compareTo(String o) { return 0; } private static void showDesc() { System.out.println(\"我是一个可爱的人\"); } } 定义接口MyInterface package com.atguigu.java1; public interface MyInterface { void info(); } 定义注解MyAnnotation package com.atguigu.java1; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; import static java.lang.annotation.ElementType.*; @Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, MODULE}) @Retention(RetentionPolicy.RUNTIME) public @interface MyAnnotation { String value() default \"hello\"; } 获取当前运行时类的属性结构 package com.atguigu.java2; import com.atguigu.java1.Person; import org.junit.Test; import java.lang.reflect.Field; import java.lang.reflect.Modifier; public class FieldTest { @Test public void test1() { Class clazz = Person.class; // 获取属性结构 // getFields()获取当前运行时类及其父类中声明为public访问权限的属性 Field[] fields = clazz.getFields(); for (Field f : fields) { System.out.println(f); } // getDeclaredFields(): 获取当前运行时类中声明的所有属性（不包含父类中声明的属性） Field[] declaredFields = clazz.getDeclaredFields(); for (Field f : declaredFields) { System.out.println(f); } } // 权限修饰符 数据类型 变量名 @Test public void test2() { Class clazz = Person.class; Field[] declaredFields = clazz.getDeclaredFields(); for (Field f : declaredFields) { // 权限修饰符 int modifiers = f.getModifiers(); System.out.println(Modifier.toString(modifiers)); // 数据类型 Class\u003c?\u003e type = f.getType(); System.out.println(type); // 变量名 String fName = f.getName(); System.out.println(fName); System.out.println(\"==========\"); } } } 获取运行时类的方法结构 package com.atguigu.java2; import com.atguigu.java1.Person; import org.junit.Test; import org.junit.experimental.theories.suppliers.TestedOn; import java.lang.annotation.Annotation; import java.lang.reflect.Method; import java.lang.reflect.Modifier; public class MethodTest { @Test public void test1() { Class clazz = Person.class; // getMethods(): 获取当前运行时类及其所有父类中声明为public权限的方法 Method[] methods = clazz.getMethods(); for (Method m : methods) { System.out.println(m); } System.out.println(\"===================\"); // getDeclaredMethods(): 获取当前运行时类中声明的所有方法（不包含父类中声明的方法） Method[] declaredMethods = clazz.getDeclaredMethods(); for (Method m : declaredMethods) { System.out.println(m); } } /* 权限修饰符 返回值类型 方法名（参数类型1，形参名1，...） throws Exception */ @Test public void test2() { Class clazz = Person.class; Method[] declaredMethods = clazz.getDeclaredMethods(); for (Method m : declaredMethods) { // 1. 获取方法声明的注解 Annotation[] annos = m.getAnnotations(); for (Annotation a : annos) { System.out.println(a); } // 2. 权限修饰符 System.out.println(Modifier.toString(m.getModifiers())); // 3. 返回值类型 System.out.println(m.getReturnType().getName()); // 4. 方法名 System.out.println(m.getName()); // 5. 形参列表 Class[] parameterTypes = m.getParameterTypes(); if (!(parameterTypes == null || parameterTypes.length == 0)) { for (Class p : parameterTypes) { System.out.print(p.getName()); } } System.out.println(); // 6. 抛出的异常 Class\u003c?\u003e[] exceptionTypes = m.getExceptionTypes(); if (!(exceptionTypes == null || exceptionTypes.length == 0)","date":"2021-08-23","objectID":"/java-shk-12/:5:0","tags":null,"title":"Java零基础教程（十二.反射Reflection）","uri":"/java-shk-12/"},{"categories":null,"content":"6. 调用运行时类的指定结构 package com.atguigu.java2; import com.atguigu.java1.Person; import org.junit.Test; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.Method; /* 调用运行时类中指定的结构：属性，方法，构造器 */ public class ReflectionTest { // 不需要掌握 @Test public void test1() throws Exception { Class clazz = Person.class; // 创建运行时类的对象 Person p = (Person) clazz.newInstance(); // 获取指定的属性:要求运行时类中属性声明为public // 通常不实用此方法，因为属性一般为private Field id = clazz.getField(\"id\"); /* 设置当前属性的值 set()： 参数1，指明设置哪个对象的属性， 参数2：将此属性设置为多少 */ id.set(p, 1001); int pId = (int) id.get(p); System.out.println(pId); } /* 如何操作运行时类中的指定的属性 - 需要掌握 */ @Test public void testField1() throws Exception { Class clazz = Person.class; // 创建运行时类的对象 Person p = (Person) clazz.newInstance(); // getDeclaredField(String fieldName): 获取运行时类中指定变量名的属性 Field name = clazz.getDeclaredField(\"name\"); // 保证当前属性是可访问的 name.setAccessible(true); // 获取，设定指定对象的属性值 name.set(p, \"Tom\"); System.out.println(name.get(p)); } /* 如何操作运行时类中的指定的方法 - 需要掌握 */ @Test public void testMethod() throws Exception { Class clazz = Person.class; // 创建运行时类的对象 Person p = (Person) clazz.newInstance(); // 获取指定的某个方法 // getDeclaredMethod(): 参数1：指明获取的方法的名称 参数2：指明获取方法的形参列表 Method show = clazz.getDeclaredMethod(\"show\", String.class); // 保证当前方法是可访问的 show.setAccessible(true); // 调用方法的invoke(): 参数1： 方法的调用者 参数2：给方法形参赋值的实参 // invoke()的返回值即为对应类中调用的方法的返回值 Object returnValue = show.invoke(p, \"CHN\");// p.show(\"CHN\"); System.out.println(returnValue); // private static void showDesc() Method showDesc = clazz.getDeclaredMethod(\"showDesc\"); showDesc.setAccessible(true); // 如果调用的运行时类中的方法没有返回值，则此invoke()返回null showDesc.invoke(Person.class); } /* 如何调用运行时类中指定的构造器 */ @Test public void testConstructor() throws Exception { Class clazz = Person.class; // private Person(String name) //1. 获取指定的构造器 // getDeclaredConstructor(): 参数：指明构造器的参数列表 Constructor constructor = clazz.getDeclaredConstructor(String.class); // 保证此构造器是可访问的 constructor.setAccessible(true); // 调用此构造器创建运行时类的对象 Person per = (Person) constructor.newInstance(\"Tom\"); System.out.println(per); } } ","date":"2021-08-23","objectID":"/java-shk-12/:6:0","tags":null,"title":"Java零基础教程（十二.反射Reflection）","uri":"/java-shk-12/"},{"categories":null,"content":"7. 反射的应用：动态代理 ","date":"2021-08-23","objectID":"/java-shk-12/:7:0","tags":null,"title":"Java零基础教程（十二.反射Reflection）","uri":"/java-shk-12/"},{"categories":null,"content":"7.1 回顾静态代理 package com.atguigu.java; /* 静态代理举例 特点：代理类和被代理类在编译期间就确定下来了 */ interface ClothFactory { void produceCloth(); } // 代理类 class ProxyClothFactory implements ClothFactory { private ClothFactory factory;// 用被代理类对象进行实例化 public ProxyClothFactory(ClothFactory factory) { this.factory = factory; } @Override public void produceCloth() { System.out.println(\"代理工厂做一些准备工作\"); factory.produceCloth(); System.out.println(\"代理工厂做一些后续的收尾工作\"); } } // 被代理类 class NikeClothFactory implements ClothFactory { @Override public void produceCloth() { System.out.println(\"Nike工厂生产一批运动服\"); } } public class StaticProxyTest { public static void main(String[] args) { // 创建被代理类的对象 NikeClothFactory nike = new NikeClothFactory(); // 创建代理类的对象 ProxyClothFactory proxyClothFactory = new ProxyClothFactory(nike); proxyClothFactory.produceCloth(); } } ","date":"2021-08-23","objectID":"/java-shk-12/:7:1","tags":null,"title":"Java零基础教程（十二.反射Reflection）","uri":"/java-shk-12/"},{"categories":null,"content":"7.2 根据运行时类动态的创建代理类 package com.atguigu.java; /* 动态代理的举例 */ import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; interface Human { String getBelief(); void eat(String food); } // 被代理类 class SuperMan implements Human { @Override public String getBelief() { return \"I believe I can fly\"; } @Override public void eat(String food) { System.out.println(\"我喜欢吃\" + food); } } class HumanUtil { public void method1() { System.out.println(\"通用方法1\"); } public void method2() { System.out.println(\"通用方法2\"); } } /* 要想实现动态代理，需要解决的问题： 问题1：如何根据加载到内存中的被代理类，动态地创建一个代理类及其对象 问题2：当通过被代理类的对象调用方法时，如何动态地调用被代理类中的同名方法 */ class ProxyFactory { //obj被代理类的对象， 调用此方法返回一个代理类的对象，解决问题1 public static Object getProxyInstance(Object obj) { MyInvocationHandler handler = new MyInvocationHandler(); handler.bind(obj); return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), handler); } } class MyInvocationHandler implements InvocationHandler { private Object obj;// 需要使用被代理类的对象进行赋值 public void bind(Object obj) { this.obj = obj; } // 当我们通过代理类的对象，调用方法a时，就会自动地调用如下的方法：invoke() // 将被代理类要执行的方法a的功能就声明在invoke()中 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { HumanUtil humanUtil = new HumanUtil(); humanUtil.method1();//展示AOP的用法，这里method1和method2是固定的，但是中间的方法method不是确定的 // method:即为代理类对象调用的方法，此方法也就作为了被代理类对象要调用的方法 // obj:被代理类的对象 Object returnValue = method.invoke(obj, args); // 上述方法的返回值就作为当前类中invoke()的返回值。 humanUtil.method2(); return returnValue; } } public class ProxyTest { public static void main(String[] args) { SuperMan superMan = new SuperMan(); // proxyInstance代理类的对象 Human proxyInstance = (Human) ProxyFactory.getProxyInstance(superMan); // 当通过代理类对象调用方法时，会自动地调用被代理类中同名的方法 String belief = proxyInstance.getBelief(); System.out.println(belief); proxyInstance.eat(\"四川麻辣烫\"); System.out.println(\"==========================\"); NikeClothFactory nikeClothFactory = new NikeClothFactory(); ClothFactory proxyClothFactory = (ClothFactory) ProxyFactory.getProxyInstance(nikeClothFactory); proxyClothFactory.produceCloth(); } } ","date":"2021-08-23","objectID":"/java-shk-12/:7:2","tags":null,"title":"Java零基础教程（十二.反射Reflection）","uri":"/java-shk-12/"},{"categories":null,"content":"1. 网络编程概述 ","date":"2021-08-22","objectID":"/java-shk-11/:1:0","tags":null,"title":"Java零基础教程（十一.网络编程）","uri":"/java-shk-11/"},{"categories":null,"content":"2. 网络通信要素概述 ","date":"2021-08-22","objectID":"/java-shk-11/:2:0","tags":null,"title":"Java零基础教程（十一.网络编程）","uri":"/java-shk-11/"},{"categories":null,"content":"3. 通信要素1：IP和端口号 ","date":"2021-08-22","objectID":"/java-shk-11/:3:0","tags":null,"title":"Java零基础教程（十一.网络编程）","uri":"/java-shk-11/"},{"categories":null,"content":"4. 通信要素2：网络协议 ","date":"2021-08-22","objectID":"/java-shk-11/:4:0","tags":null,"title":"Java零基础教程（十一.网络编程）","uri":"/java-shk-11/"},{"categories":null,"content":"5. TCP网络编程 package com.atguigu.java1; import org.junit.Test; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.net.InetAddress; import java.net.ServerSocket; import java.net.Socket; /* 实现TCP的网络编程 例子1：客户端 */ public class TCPTest1 { // 客户端 @Test public void client() { Socket socket = null; OutputStream os = null; try { // 1. 创建Socket对象，指明服务器端的ip和端口号 InetAddress inet = InetAddress.getByName(\"192.168.1.66\");//127.0.0.1或局域网ip socket = new Socket(inet, 8899); // 2. 获取一个输出流，用于输出数据 os = socket.getOutputStream(); // 3. 写出数据的操作 os.write(\"你好，我是客户端mm\".getBytes()); } catch (IOException e) { e.printStackTrace(); } finally { // 4. 资源的关闭 if (os != null) { try { os.close(); } catch (IOException e) { e.printStackTrace(); } } if (socket != null) { try { socket.close(); } catch (IOException e) { e.printStackTrace(); } } } } // 服务端 @Test public void server() { ServerSocket ss = null; Socket socket = null; InputStream is = null; ByteArrayOutputStream baos = null; try { // 1. 创建服务器端的ServerSocket，指明自己的端口号 ss = new ServerSocket(8899); // 2. 调用accept()表示接收来自于客户端的socket socket = ss.accept(); // 3. 获取输入流 is = socket.getInputStream(); // 4. 读取输入流中的数据 baos = new ByteArrayOutputStream(); byte[] buffer = new byte[5]; int len; while ((len = is.read(buffer)) != -1) { baos.write(buffer, 0, len); } System.out.println(baos.toString()); System.out.println(\"收到了来自于：\" + socket.getInetAddress() + \"的数据\"); } catch (IOException e) { e.printStackTrace(); } finally { if (baos != null) { // 5. 关闭资源 try { baos.close(); } catch (IOException e) { e.printStackTrace(); } } if (is != null) { try { is.close(); } catch (IOException e) { e.printStackTrace(); } } if (socket != null) { try { socket.close(); } catch (IOException e) { e.printStackTrace(); } } if (ss != null) { try { ss.close(); } catch (IOException e) { e.printStackTrace(); } } } } } package com.atguigu.java1; import org.junit.Test; import java.io.*; import java.net.InetAddress; import java.net.ServerSocket; import java.net.Socket; import java.net.UnknownHostException; /* 例题2：客户端发送文件给服务端，服务端将文件保存在本地 */ public class TCPTest2 { /* 这里涉及的异常还是需要try-catch，这里throws偷懒 */ @Test public void client() throws IOException { Socket socket = new Socket(InetAddress.getByName(\"127.0.0.1\"), 9090); OutputStream os = socket.getOutputStream(); FileInputStream fis = new FileInputStream(new File(\"disney.jpeg\")); byte[] buffer = new byte[1024]; int len; while ((len = fis.read(buffer)) != -1) { os.write(buffer, 0, len); } fis.close(); os.close(); socket.close(); } @Test public void server() throws IOException { ServerSocket ss = new ServerSocket(9090); Socket socket = ss.accept(); InputStream is = socket.getInputStream(); FileOutputStream fos = new FileOutputStream(new File(\"disney1.jpeg\")); byte[] buffer = new byte[1024]; int len; while ((len = is.read(buffer)) != -1) { fos.write(buffer, 0, len); } fos.close(); is.close(); socket.close(); ss.close(); } } package com.atguigu.java1; import org.junit.Test; import java.io.*; import java.net.InetAddress; import java.net.ServerSocket; import java.net.Socket; /* 实现TCP的网络编程 */ public class TCPTest3 { /* 这里涉及的异常还是需要try-catch，这里throws偷懒 */ @Test public void client() throws IOException { Socket socket = new Socket(InetAddress.getByName(\"127.0.0.1\"), 9090); OutputStream os = socket.getOutputStream(); FileInputStream fis = new FileInputStream(new File(\"disney.jpeg\")); byte[] buffer = new byte[1024]; int len; while ((len = fis.read(buffer)) != -1) { os.write(buffer, 0, len); } // 关闭数据输出，告知服务器端数据传完了 socket.shutdownOutput(); // 接受来自于服务器端的数据，并显示到控制台上 InputStream is = socket.getInputStream(); ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte[] buffer1 = new byte[20]; int len1; while ((len1 = is.read(buffer1)) != -1) { baos.write(buffer1, 0, len1); } System.out.println(baos.toString()); fis.close(); os.close(); socket.close(); baos.close(); } @Test public void server() throws IOException { ServerSocket ss = new Serve","date":"2021-08-22","objectID":"/java-shk-11/:5:0","tags":null,"title":"Java零基础教程（十一.网络编程）","uri":"/java-shk-11/"},{"categories":null,"content":"6. UDP网络编程 package com.atguigu.java1; import org.junit.Test; import java.io.IOException; import java.net.*; /* UDP协议的网络编程 */ public class UDPTest { @Test public void sender() throws IOException { DatagramSocket socket = new DatagramSocket(); String str = \"this is a UDP message\"; byte[] data = str.getBytes(); InetAddress inet = InetAddress.getLocalHost(); DatagramPacket packet = new DatagramPacket(data, 0, data.length, inet, 9090); socket.send(packet); socket.close(); } @Test public void receiver() throws IOException { DatagramSocket socket = new DatagramSocket(9090); byte[] buffer = new byte[100]; DatagramPacket packet = new DatagramPacket(buffer, 0, buffer.length); socket.receive(packet); System.out.println(new String(packet.getData(), 0, packet.getLength())); } } ","date":"2021-08-22","objectID":"/java-shk-11/:6:0","tags":null,"title":"Java零基础教程（十一.网络编程）","uri":"/java-shk-11/"},{"categories":null,"content":"7. URL编程 package com.atguigu.java1; import java.net.MalformedURLException; import java.net.URL; /* URL网络编程 1. URL: 统一资源定位符，对应着互联网的某一资源地址 2. 格式： http://localhost:8080/examples/disney.jpeg?username=Tom 协议 主机名 端口号 资源地址 参数列表 */ public class URLTest { public static void main(String[] args) { URL url = null; try { url = new URL(\"http://localhost:8080/examples/disney.jpeg?username=Tom\"); System.out.println(url.getProtocol()); System.out.println(url.getHost()); System.out.println(url.getPort()); System.out.println(url.getPath()); System.out.println(url.getFile()); System.out.println(url.getQuery()); } catch (MalformedURLException e) { e.printStackTrace(); } } } package com.atguigu.java1; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.net.HttpURLConnection; import java.net.MalformedURLException; import java.net.URL; public class URLTest1 { public static void main(String[] args) { HttpURLConnection urlConnection = null; InputStream is = null; FileOutputStream fos = null; try { URL url = new URL(\"https://s3.amazonaws.com/cms.ipressroom.com/219/files/20149/544a6120f6091d588d000048_NVLogo_2D_H/NVLogo_2D_H_thmb.jpg\"); urlConnection = (HttpURLConnection) url.openConnection(); urlConnection.connect(); is = urlConnection.getInputStream(); fos = new FileOutputStream(\"day10/nvidia_logo.jpg\"); byte[] buffer = new byte[1024]; int len; while ((len = is.read(buffer)) != -1) { fos.write(buffer, 0, len); } } catch (IOException e) { e.printStackTrace(); } finally { if (fos != null) { //关闭资源 try { fos.close(); } catch (IOException e) { e.printStackTrace(); } } if (is != null) { try { is.close(); } catch (IOException e) { e.printStackTrace(); } } if (urlConnection != null) { urlConnection.disconnect(); } } } } ","date":"2021-08-22","objectID":"/java-shk-11/:7:0","tags":null,"title":"Java零基础教程（十一.网络编程）","uri":"/java-shk-11/"},{"categories":null,"content":"1. File类 File类的使用 File类的一个对象，代表一个文件或一个文件目录（俗称：文件夹） File类的声明在java.io包下 File类中涉及到关于文件或文件目录的创建，删除，重命名，修改时间，文件大小等方法。并未涉及到写入或读取文件内容的操作。如果需要读取或写入文件内容，必须使用IO流来完成 后续File类的对象常会作为参数传递到流的构造器中，指明读取或写入的\"终点” ","date":"2021-08-15","objectID":"/java-shk-10/:1:0","tags":null,"title":"Java零基础教程（十.IO流）","uri":"/java-shk-10/"},{"categories":null,"content":"1.1 File类的创建 如何创建File类的实例 File(String filePath) File(String parentPath, String childPath) File(File parentPath, String childPath) 相对路径：相较于某个路径下，指明的路径 绝对路径：包含盘符在内的文件或文件目录的路径 路径分隔符 windows:\\\\ unix:/ ","date":"2021-08-15","objectID":"/java-shk-10/:1:1","tags":null,"title":"Java零基础教程（十.IO流）","uri":"/java-shk-10/"},{"categories":null,"content":"1.2 File类的API public String getAbsolutePath():获取绝对路径 public String getPath():获取路径 public String getName():获取名称 public String getParent():获取上层文件目录路径。若无，返回null public long length():获取文件长度（即，字节数）。不能获取目录的长度 public long lastModified():获取最后一次的修改时间，毫秒值 如下的两个方法适用于文件目录 public String[] list():获取指定目录下的所有文件或者文件目录的名称数组 public File[] listFiles:获取指定目录下的所有文件或者文件目录的File数组 public boolean renameTo(File dest):把文件重命名为指定的文件路径 比如：file1.renameTo(file2)为例： 要想保证返回true，需要file1在硬盘中是存在的，且file2不能在硬盘中存在 public boolean isDirectory():判断是否是文件目录 public boolean isFile():判断是否是文件 public boolean exists():判断是否存在 public boolean canRead():判断是否可读 public boolean canWrite():判断是否可写 public boolean isHidden():判断是否隐藏 创建硬盘中对应的文件或文件目录 public boolean createNewFile():创建文件。若文件存在，则不创建，返回false public boolean mkdir():创建文件目录。如果此文件目录存在，就不创建了。 如果此文件目录的上层目录不存在，也不创建 public boolean mkdirs():创建文件目录。如果上层文件目录不存在，一并创建 删除磁盘中的文件或文件目录 public boolean delete():删除文件或者文件夹 删除注意事项： Java中的删除不走回收站 package com.atguigu.java3; import org.junit.Test; import java.io.File; import java.io.IOException; import java.util.Date; public class FileTest { @Test public void test1() { // 构造器1 File file1 = new File(\"hello.txt\");//相对于当前module System.out.println(file1); } @Test public void test2() { File file1 = new File(\"hello.txt\"); File file2 = new File(\"/Users/wenzhe/Desktop/test_java_io.txt\"); System.out.println(file1.getAbsoluteFile()); System.out.println(file1.getPath()); System.out.println(file1.getName()); System.out.println(file1.getParent()); System.out.println(file1.length()); System.out.println(new Date(file1.lastModified())); System.out.println(); System.out.println(file2.getAbsoluteFile()); System.out.println(file2.getPath()); System.out.println(file2.getName()); System.out.println(file2.getParent()); System.out.println(file2.length()); System.out.println(file2.lastModified()); } @Test public void test3() { File file = new File(\"/Users/wenzhe/IdeaProjects/JavaSenior\"); String[] list = file.list(); for (String s : list) { System.out.println(s); } File[] files = file.listFiles(); for(File f : files) { System.out.println(f); } } @Test public void test6() throws IOException { File file1 = new File(\"hi.txt\"); if (!file1.exists()) { file1.createNewFile(); System.out.println(\"创建成功\"); } else { file1.delete(); System.out.println(\"删除成功\"); } } @Test public void test7() { //文件目录 File file1 = new File() } } ","date":"2021-08-15","objectID":"/java-shk-10/:1:2","tags":null,"title":"Java零基础教程（十.IO流）","uri":"/java-shk-10/"},{"categories":null,"content":"2. 节点流（文件流） ","date":"2021-08-15","objectID":"/java-shk-10/:2:0","tags":null,"title":"Java零基础教程（十.IO流）","uri":"/java-shk-10/"},{"categories":null,"content":"2.1 流的分类 操作数据单位：字节流，字符流 数据的流向：输入流，输出流 流的角色；节点流，处理流 ","date":"2021-08-15","objectID":"/java-shk-10/:2:1","tags":null,"title":"Java零基础教程（十.IO流）","uri":"/java-shk-10/"},{"categories":null,"content":"2.2 流的体系结构 抽象基类 节点流(或文件流) 缓冲流（处理流的一种） InputStream FileInputStream (read(byte[] buffer)) BufferedInputStream (read(byte[] buffer)) OutputStream FileOutputStream (write(byte[] buffer, 0, len)) BufferedOutputStream (write(byte[] buffer, 0, len)) / flush() Reader FileReader (read(char[] cbuf)) BufferedReader (read(char[] cbuf) / readLine()) Writer FileWriter (write(char[] cbuf, 0, len)) BufferedWriter (write(char[] cbuf, 0, len)) / flush() package com.atguigu.java; import org.junit.Test; import java.io.File; import java.io.FileReader; import java.io.FileWriter; import java.io.IOException; public class FileReaderWriterTest { public static void main(String[] args) { File file = new File(\"day09/hello.txt\"); System.out.println(file.getAbsolutePath()); } /* 将day09下的hello.txt文件内容读入程序中 说明点： 1. read(): 返回的读入的一个字符，如果达到文件末尾，返回-1 2. 异常的处理：为了保证流资源一定可以执行关闭操作。需要使用try-catch-finally处理 3. 读入的文件一定要存在，否则就会报FileNotFoundException */ @Test public void testFileReader() { FileReader fr = null; try { // 1. 实例化File类的对象，指明要操作的文件 File file = new File(\"hello.txt\");//相较于当前Module // 2. 提供具体的流 fr = new FileReader(file); // 3. 数据的读入 // read(): 返回的读入的一个字符，如果达到文件末尾，返回-1 // 方式一 // int data = fr.read(); // while (data != -1) { // System.out.print((char)data); // data = fr.read(); // } // 方式二 int data; while ((data = fr.read()) != -1) { System.out.print((char)data); } } catch (IOException e) { e.printStackTrace(); } finally { // 4. 流的关闭操作 if (fr != null) { try { fr.close(); } catch (IOException e) { e.printStackTrace(); } } } } // 对read()操作升级：使用read的重载方法 @Test public void testFileReader1() { FileReader fr = null; try { // 1. File类的实例化 File file = new File(\"hello.txt\"); // 2. FileReader流的实例化 fr = new FileReader(file); // 3. 读入的操作 // read(char[] cbuf):返回每次读入cbuf数组中的字符的个数。如果达到文件末尾，返回-1 char[] cbuf = new char[5]; int len; while ((len = fr.read(cbuf)) != -1) { // 方式一 // for (int i = 0; i \u003c len; i++) { // System.out.print(cbuf[i]); // } // 方式二 String str = new String(cbuf, 0, len); System.out.print(str); } } catch (IOException e) { e.printStackTrace(); } finally { if (fr != null) { // 4. 资源的关闭 try { fr.close(); } catch (IOException e) { e.printStackTrace(); } } } } /* 从内存中写出数据到硬盘的文件里 说明： 1。输出操作，对应的File可以不存在的，并不会报异常 2。File对应的硬盘中的文件如果不存在，在输出的过程中，会自动创建此文件 File对应的硬盘中的文件如果存在： 如果流使用的构造器是: FileWriter(file, false) / FileWriter(file):对原有文件的覆盖 如果流使用的构造器是：FileWriter(file, true): 不会对原有文件覆盖，而是在原有文件基础上追加内容 */ @Test public void testFileWriter() throws IOException { // 1. 提供File类的对象，指明写出到的文件 File file = new File(\"hello.txt\"); // 2. 提供FileWriter的对象，用于数据的写出 FileWriter fw = new FileWriter(file, true); // 3. 写出的操作 fw.write(\"I have a dream!\\n\"); fw.write(\"you need to have a dream!\"); // 4. 流资源的关闭 fw.close(); } // 文件的复制 @Test public void testFileReaderFileWriter() { FileReader fr = null; FileWriter fw = null; try { // 1. 创建File类的对象，指明读入和写出的文件 File srcFile = new File(\"hello.txt\"); File destFile = new File(\"hello2.txt\"); // 2. 创建输入流和输出流的对象 fr = new FileReader(srcFile); fw = new FileWriter(destFile); // 3. 数据的读入和写出操作 char[] cbuf = new char[5]; int len; //记录每次读入到cbuf数组中的字符的个数 while ((len = fr.read(cbuf)) != -1) { // 每次写出len个字符 fw.write(cbuf, 0, len); } } catch (IOException e) { e.printStackTrace(); } finally { // 4. 关闭流资源 try { if (fw != null) fw.close(); } catch (IOException e) { e.printStackTrace(); } try { if (fr != null) fr.close(); } catch (IOException e) { e.printStackTrace(); } } } } package com.atguigu.java; import org.junit.Test; import java.io.File; import java.io.FileInputStream; import java.io.IOException; /* 测试FileInputStream和FileOutputStream的使用 结论： 1. 对于文本文件(.txt, .java, .c, .cpp)，使用字符流处理 2. 对于非文本文件(.jpg, .mp3, .mp4, .avi, .doc, .ppt, ...)，使用字节流处理 */ public class FileInputOutputStreamTest { // 使用字节流FileInputStream处理文本文件，可能出现乱码 @Test public void testFileInputStream() { FileInputStream fis = null; try { // 1. 造文件 File file = new File(\"hello.txt\"); // 2. 造流 fis = new FileInputStream(file); // 3. 读数据 byte[] buffer = new byte[5]; int len; while ((len = fis.read(buffer)) != -1) { String str ","date":"2021-08-15","objectID":"/java-shk-10/:2:2","tags":null,"title":"Java零基础教程（十.IO流）","uri":"/java-shk-10/"},{"categories":null,"content":"3. 缓冲流 缓冲流(处理流之一)的使用 BufferedInputStream BufferedOutputStream BufferedReader BufferedWriter 作用：提高流的读取，写入的速度 提高读写速度的原因：内部提供了一个缓冲区 处理流，就是\"套接\"在已有的流的基础上。 package com.atguigu.java; import org.junit.Test; import java.io.*; public class BufferedTest { /* 实现非文本文件的复制 */ @Test public void BufferedStreamTest() { BufferedInputStream bis = null; BufferedOutputStream bos = null; try { // 1. 造文件 File srcFile = new File(\"sf_skyline.jpeg\"); File destFile = new File(\"sf_skyline_test.jpeg\"); // 2. 造流 // 2.1 造节点流 FileInputStream fis = new FileInputStream(srcFile); FileOutputStream fos = new FileOutputStream(destFile); // 2.2 造缓冲流 bis = new BufferedInputStream(fis); bos = new BufferedOutputStream(fos); // 3. 复制的细节：读取写入 byte[] buffer = new byte[10]; int len; while ((len = bis.read(buffer)) != -1) { bos.write(buffer, 0, len); // bos.flush(); // 刷新缓冲区 } } catch (IOException e) { e.printStackTrace(); } finally { // 4. 资源关闭 // 要求1：先关闭外层的流，再关闭内层的流 try { if (bos != null) bos.close(); } catch (IOException e) { e.printStackTrace(); } try { if (bis != null) bis.close(); } catch (IOException e) { e.printStackTrace(); } // 说明：关闭外层流的同时，内层流也会自动的进行关闭。关于内层流的关闭，我们可以省略 // fos.close(); // fis.close(); } } // 实现文件复制的方法 public void copyFileWithBuffered(String srcPath, String destPath) { BufferedInputStream bis = null; BufferedOutputStream bos = null; try { // 1. 造文件 File srcFile = new File(srcPath); File destFile = new File(destPath); // 2. 造流 // 2.1 造节点流 FileInputStream fis = new FileInputStream(srcFile); FileOutputStream fos = new FileOutputStream(destFile); // 2.2 造缓冲流 bis = new BufferedInputStream(fis); bos = new BufferedOutputStream(fos); // 3. 复制的细节：读取写入 byte[] buffer = new byte[1024]; int len; while ((len = bis.read(buffer)) != -1) { bos.write(buffer, 0, len); } } catch (IOException e) { e.printStackTrace(); } finally { // 4. 资源关闭 // 要求1：先关闭外层的流，再关闭内层的流 try { if (bos != null) bos.close(); } catch (IOException e) { e.printStackTrace(); } try { if (bis != null) bis.close(); } catch (IOException e) { e.printStackTrace(); } // 说明：关闭外层流的同时，内层流也会自动的进行关闭。关于内层流的关闭，我们可以省略 // fos.close(); // fis.close(); } } @Test public void testCopyFileWithBuffered() { long start = System.currentTimeMillis(); String srcPath = \"sf_skyline.jpeg\"; String destPath = \"sf_skyline_test.jpeg\"; copyFileWithBuffered(srcPath, destPath); long end = System.currentTimeMillis(); System.out.println(\"Copy took: \" + (end - start) + \" millis\"); } } ","date":"2021-08-15","objectID":"/java-shk-10/:3:0","tags":null,"title":"Java零基础教程（十.IO流）","uri":"/java-shk-10/"},{"categories":null,"content":"4. 转换流 处理流之二：转换流的使用 转换流：属于字符流 InputStreamReader：将一个字节的输入流转换为字符的输入流 OutputStreamWriter：将一个字符流的输出流转换为字节的输出流 作用：提供字节流与字符流之间的转换 编码与解码 解码： 字节，字节数组 ---\u003e 字符数组，字符串 编码： 字符数组，字符串 ---\u003e 字节，字节数组 字符集 ASCII:美国标准信息交换码，用一个字节的7位可以表示 ISO8859-1:拉丁码表。欧洲码表，用一个字节的8位表示 GB2312:中国的中文编码表。最多两个字节编码所有字符 GBK:中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码 Unicode:国际标准码，融合了目前人类使用的所有字符。为每个字符分配唯一的字符码。所有的文字都用两个字节来表示 UTF-8:变长的编码方式，可用1-4个字节来表示一个字符 package com.atguigu.java; import org.junit.Test; import java.io.*; public class InputStreamReaderTest { /* 此时处理异常的话，仍然应该使用try-catch-finally */ @Test public void test1() throws IOException { FileInputStream fis = new FileInputStream(\"test.txt\"); // InputStreamReader isr = new InputStreamReader(fis); // 使用系统默认的字符集 // 参数2指明了字符集，具体使用哪个字符集，取决于文件保存时使用的字符集 InputStreamReader isr = new InputStreamReader(fis, \"UTF-8\"); char[] cbuf = new char[20]; int len; while ((len = isr.read(cbuf)) != -1) { String str = new String(cbuf, 0, len); System.out.print(str); } } @Test public void test2() throws IOException { // 1. 造文件，造流 InputStreamReader isr = new InputStreamReader(new FileInputStream(new File(\"test.txt\")), \"utf-8\"); OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(new File(\"test_gbk.txt\")), \"gbk\"); // 2. 读写过程 char[] cbuf = new char[20]; int len; while ((len = isr.read(cbuf)) != -1) { osw.write(cbuf, 0, len); } // 3. 关闭资源 isr.close(); osw.close(); } } ","date":"2021-08-15","objectID":"/java-shk-10/:4:0","tags":null,"title":"Java零基础教程（十.IO流）","uri":"/java-shk-10/"},{"categories":null,"content":"5. 其他流 ","date":"2021-08-15","objectID":"/java-shk-10/:5:0","tags":null,"title":"Java零基础教程（十.IO流）","uri":"/java-shk-10/"},{"categories":null,"content":"5.1 标准输入流输出流 标准的输入，输出流 System.in: 标准的输入流，默认从键盘输入 System.out: 标准的输出流，默认从控制台输出 System类的setIn(InputStream is) / setOut(PrintStream ps)方式重新指定输入和输出的流 练习 从键盘输入字符串，要求将读取到的整行字符串转成大写输出。然后继续进行输入操作，直至当输入\"e\"或者\"exit\"时，退出程序 方法一：使用scanner实现，调用next()返回一个字符串 方法二：使用System.in 实现 System.in —\u003e 转换流 —\u003e BufferedReader的readLine() package com.atguigu.java; import org.junit.Test; import java.io.*; public class OtherStreamTest { public static void main(String[] args) { BufferedReader br = null; try { InputStreamReader isr = new InputStreamReader(System.in); br = new BufferedReader(isr); while (true) { System.out.println(\"请输入字符串\"); String data = br.readLine(); if (data.equalsIgnoreCase(\"e\") || data.equalsIgnoreCase(\"exit\")) { System.out.println(\"程序结束\"); break; } System.out.println(data.toUpperCase()); } } catch (IOException e) { e.printStackTrace(); } finally { if (br != null) { try { br.close(); } catch (IOException e) { e.printStackTrace(); } } } } ","date":"2021-08-15","objectID":"/java-shk-10/:5:1","tags":null,"title":"Java零基础教程（十.IO流）","uri":"/java-shk-10/"},{"categories":null,"content":"5.2 打印流 @Test public void test2() { PrintStream ps = null; try { FileOutputStream fos = new FileOutputStream(new File(\"test_print_stream.txt\")); ps = new PrintStream(fos, true); if (ps != null) { System.setOut(ps); } for (int i = 0; i \u003c 255; i++) { System.out.print((char) i); if (i % 50 == 0) { System.out.println(); } } } catch (FileNotFoundException e) { e.printStackTrace(); } finally { if (ps != null) { ps.close(); } } } ","date":"2021-08-15","objectID":"/java-shk-10/:5:2","tags":null,"title":"Java零基础教程（十.IO流）","uri":"/java-shk-10/"},{"categories":null,"content":"5.3 数据流 DataInputStream 和 DataOutputStream 作用：用于读取或写出基本数据类型的变量或字符串 练习：将内存中的字符串，基本数据类型的变量写出到文件中 注意：处理异常的话，仍然应该使用try-catch-finally /* @Test public void test3() throws IOException { DataOutputStream dos = new DataOutputStream(new FileOutputStream(\"test_data_stream.txt\")); dos.writeUTF(\"abc\"); dos.flush();//刷新操作，将内存中的数据写入文件 dos.writeInt(123); dos.flush(); dos.writeBoolean(true); dos.flush(); dos.close(); } /* 将文件中存储的基本数据类型变量和字符串读取到内存中，保存在变量中 注意点：读取不同类型的数据的顺序要与当初写入文件时，保存的数据的顺序保持一致。 */ @Test public void test4() throws IOException { DataInputStream dis = new DataInputStream(new FileInputStream(\"test_data_stream.txt\")); String s = dis.readUTF(); int i = dis.readInt(); boolean b = dis.readBoolean(); System.out.println(s + i + b); dis.close(); } } ","date":"2021-08-15","objectID":"/java-shk-10/:5:3","tags":null,"title":"Java零基础教程（十.IO流）","uri":"/java-shk-10/"},{"categories":null,"content":"5.4 对象流 对象流的使用 ObjectInputStream 和 ObjectOutputStream 作用：用于存储和读取基本数据类型数据或对象的处理流。它的强大之处就是可以把java中的对象转化为二进制流。 要想一个java对象是可序列化的，需要满足相应的要求。见Person.java 序列化机制： 对象序列化机制允许把内存中的java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。 当其他程序获取了这种二进制流，就可以恢复成原来的java对象。 package com.atguigu.java; import org.junit.Test; import java.io.*; public class ObjectInputOutputStreamTest { /* 序列化过程：将内存中的java对象保存在磁盘中，或通过网络传输出去 使用ObjectOutputStream实现 */ @Test public void testObjectOutputStream() { ObjectOutputStream oos = null; try { oos = new ObjectOutputStream(new FileOutputStream(\"object.dat\")); oos.writeObject(new String(\"helloWorld\")); oos.flush();// 刷新操作 oos.writeObject(new Person(\"dxu\", 20)); oos.flush(); } catch (IOException e) { e.printStackTrace(); } finally { if (oos != null) { try { oos.close(); } catch (IOException e) { e.printStackTrace(); } } } } /* 反序列化：将磁盘文件中的对象还原为内存中的一个java对象 使用ObjectInputStream来实现 */ @Test public void testObjectInputStream() { ObjectInputStream ois = null; try { ois = new ObjectInputStream(new FileInputStream(\"object.dat\")); Object obj = ois.readObject(); String str = (String) obj; System.out.println(str); Person p = (Person) ois.readObject(); System.out.println(p); } catch (IOException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } finally { if (ois != null) { try { ois.close(); } catch (IOException e) { e.printStackTrace(); } } } } } package com.atguigu.java; import java.io.Serializable; /* Person需要满足如下的要求，方可序列化 1. 需要实现接口：Serializable 2. 当前类提供一个全局常量：serialVersionUID 3. 除了当前Person类需要实现Serializable接口之外，还必须保证其内部所有属性也必须是可序列化的。（默认情况下，基本数据类型是可序列化的） 4. ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量 */ public class Person implements Serializable { public static final long serialVersionUID = 424545154841L; private String name; private int age; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public Person(String name, int age) { this.name = name; this.age = age; } @Override public String toString() { return \"Person{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } } ","date":"2021-08-15","objectID":"/java-shk-10/:5:4","tags":null,"title":"Java零基础教程（十.IO流）","uri":"/java-shk-10/"},{"categories":null,"content":"5.5 随机存取文件流 RandomAccessFile的使用 RandomAccessFile直接继承于java.lang.Object类，实现了DataInput和DataOutput接口 RandomAccessFile既可以作为一个输入流，又可以作为一个输出流 如果RandomAccessFile作为输出流时，写出到的文件如果不存在，则在执行过程中自动创建; 如果写出到的文件存在，则会对原有文件内容进行覆盖。（默认情况下，从头覆盖） 可以通过相关的操作，实现RandomAccessFile\"插入\"数据的效果 package com.atguigu.java; import org.junit.Test; import java.io.File; import java.io.IOException; import java.io.RandomAccessFile; public class RandomAccessFileTest { @Test public void test1() { RandomAccessFile raf1 = null; RandomAccessFile raf2 = null; try { raf1 = new RandomAccessFile(new File(\"sf_skyline.jpeg\"), \"r\"); raf2 = new RandomAccessFile(new File(\"sf_skyline1.jpeg\"), \"rw\"); byte[] buffer = new byte[1024]; int len; while ((len = raf1.read(buffer)) != -1) { raf2.write(buffer, 0, len); } } catch (IOException e) { e.printStackTrace(); } finally { if (raf1 != null) { try { raf1.close(); } catch (IOException e) { e.printStackTrace(); } } if (raf2 != null) { try { raf2.close(); } catch (IOException e) { e.printStackTrace(); } } } } @Test public void test2() throws IOException { RandomAccessFile raf1 = new RandomAccessFile(\"hello.txt\", \"rw\"); raf1.seek(3);// 将指针移动到索引为3的位置 raf1.write(\"xyz\".getBytes()); raf1.close(); } /* 使用RandomAccessFile实现数据的插入效果 */ @Test public void test3() throws IOException { RandomAccessFile raf1 = new RandomAccessFile(\"hello.txt\", \"rw\"); raf1.seek(3);// 将指针移动到索引为3的位置 // 保存指针3后面的所有数据到StringBuilder中 StringBuilder builder = new StringBuilder((int) new File(\"hello.txt\").length()); byte[] buffer = new byte[20]; int len; while ((len = raf1.read(buffer)) != -1) { builder.append(new String(buffer, 0, len)); } // 调回指针,写入\"xyz\" raf1.seek(3); raf1.write(\"xyz\".getBytes()); // 将StringBuilder中的数据写入到文件中 raf1.write(builder.toString().getBytes()); raf1.close(); // 思考：将StringBuilder替换为ByteArrayOutputStream } } ","date":"2021-08-15","objectID":"/java-shk-10/:5:5","tags":null,"title":"Java零基础教程（十.IO流）","uri":"/java-shk-10/"},{"categories":null,"content":"1. 泛型的使用 jdk5.0新增的特性 ","date":"2021-08-11","objectID":"/java-shk-9/:1:0","tags":null,"title":"Java零基础教程（九.泛型）","uri":"/java-shk-9/"},{"categories":null,"content":"1.1. 在集合中使用泛型： 总结： 集合接口或集合类在jdk5.0时都修改为带泛型的结构 在实例化集合类时，可以指明具体的泛型类型 指明完以后，在集合类或接口中凡是定义类或接口时，内部结构（比如：方法，构造器，属性）使用到类的泛型的位置，都指定为实例化的泛型类型。 比如：add(E e) —\u003e 实例化以后：add(Integer e) 注意点：泛型的类型必须是类，不能是基本数据类型。需要用到基本数据类型的位置，拿包装类来替换 如果实例化时，没有指明范型的类型，默认类型为java.lang.Object类型 public class GenericTest { // 在集合中使用泛型 @Test public void test1() { ArrayList list = new ArrayList(); list.add(78); list.add(76); list.add(89); list.add(88); // 问题1： 类型不安全 // list.add(\"Tom\"); for (Object score: list) { int stuScore = (Integer) score; System.out.println(stuScore); } } // 在集合中使用泛型的情况： @Test public void test2() { ArrayList\u003cInteger\u003e list = new ArrayList\u003cInteger\u003e(); list.add(78); list.add(76); list.add(89); list.add(88); // 编译时，就会进行类型检查，保证数据的安全 // list.add(\"Tom\"); for (Integer score : list) { // 避免了强转操作 System.out.println(score); } // 方式二： Iterator\u003cInteger\u003e iterator = list.iterator(); while (iterator.hasNext()) { System.out.println(iterator.next()); } } @Test public void test3() { Map\u003cString, Integer\u003e map = new HashMap\u003cString, Integer\u003e(); map.put(\"Tom\", 87); map.put(\"Jerry\", 87); // 泛型的嵌套 Set\u003cMap.Entry\u003cString, Integer\u003e\u003e entry = map.entrySet(); // option + enter 自动补全 Iterator\u003cMap.Entry\u003cString, Integer\u003e\u003e iterator = entry.iterator(); } @Test public void test4() { // 如果定义了泛型类，实例化没有指明类的泛型，则认为此泛型类型为Object类型 // 要求：如果大家定义了类是带泛型的，建议在实例化时要指明类的泛型 Order order = new Order(); order.setOrderT(123); order.setOrderT(\"ABC\"); // 建议：实例化时指明类的泛型 Order\u003cString\u003e orderAA = new Order\u003c\u003e(\"orderAA\", 1001, \"order:AA\"); orderAA.setOrderT(\"AA:hello\"); } @Test public void test5() { SubOrder sub1 = new SubOrder(); // 由于子类在继承带泛型的父类，指明了泛型类型。则实例化子类对象时，不再需要指明泛型。 sub1.setOrderId(1122); SubOrder1\u003cString\u003e sub2 = new SubOrder1\u003c\u003e(); } @Test public void test6() { ArrayList\u003cString\u003e list1 = null; ArrayList\u003cInteger\u003e list2 = null; // 泛型不同的引用不能相互赋值 // list1 = list2 } // 测试泛型方法 @Test public void test7() { Order\u003cString\u003e order = new Order\u003c\u003e(); Integer[] arr = new Integer[]{1,2,3,4}; // 泛型方法在调用时，指明泛型参数的类型 List\u003cInteger\u003e list = order.copyFromArrayToList(arr); System.out.println(list); } } ","date":"2021-08-11","objectID":"/java-shk-9/:1:1","tags":null,"title":"Java零基础教程（九.泛型）","uri":"/java-shk-9/"},{"categories":null,"content":"1.2 如何自定义泛型结构：泛型类，泛型接口；泛型方法 泛型类，泛型接口 泛型方法 ","date":"2021-08-11","objectID":"/java-shk-9/:1:2","tags":null,"title":"Java零基础教程（九.泛型）","uri":"/java-shk-9/"},{"categories":null,"content":"1.3 泛型在继承方面的体现 虽然类A是类B的父类，但是G\u003cA\u003e和G\u003cB\u003e二者不具备子父类关系，二者是并列关系 补充：类A是类B的父类，A\u003cG\u003e是B\u003cG\u003e的父类 ","date":"2021-08-11","objectID":"/java-shk-9/:1:3","tags":null,"title":"Java零基础教程（九.泛型）","uri":"/java-shk-9/"},{"categories":null,"content":"1.4 通配符 通配符：？ 类A是类B的父类，G\u003cA\u003e和G\u003cB\u003e是没有关系的，二者共同的父类是：G\u003c?\u003e 有限制条件的通配符的使用 ? extends A: G\u003c? extends A\u003e可以作为G\u003cA\u003e和G\u003cB\u003e的父类，其中B是A的子类，相当于小于等于 ? super A: G\u003c? super A\u003e可以作为G\u003cA\u003e和G\u003cB\u003e的父类，其中B是A的父类，相当于大于等于 package com.atguigu.java2; import org.junit.Test; import java.util.ArrayList; import java.util.Iterator; import java.util.List; public class GenericTest { @Test public void test1() { Object obj = null; String str = null; obj = str; Object[] arr1 = null; String[] arr2 = null; arr1 = arr2; List\u003cObject\u003e list1 = null; List\u003cString\u003e list2 = null; // 此时的list1和list2不具备子父类关系 // list1 = list2;// 编译不通过 /* 反证法： 假设list1 = list2 list1.add(123)导致混入非String的数据，出错 */ // show(list1);//编译不通过 show(list2); } public void show(List\u003cString\u003e list){ } @Test public void test2() { List\u003cString\u003e list1 = null; ArrayList\u003cString\u003e list2 = null; list1 = list2; } @Test public void test3() { List\u003cObject\u003e list1 = null; List\u003cString\u003e list2 = null; List\u003c?\u003e list = null; list = list1; list = list2; List\u003cString\u003e list3 = new ArrayList\u003c\u003e(); list3.add(\"AA\"); list3.add(\"BB\"); list3.add(\"CC\"); list = list3; // 添加：对于List\u003c?\u003e就不能向其内部添加数据 // 除了添加null // list.add(\"DD\"); list.add(null); // 获取（读取）：允许读取数据，读取的数据类型为Object Object o = list.get(0); System.out.println(o); } public void print(List\u003c?\u003e list) { Iterator\u003c?\u003e iterator = list.iterator(); while (iterator.hasNext()) { Object obj = iterator.next(); System.out.println(obj); } } @Test public void test4() { List\u003c? extends Person\u003e list1 = null; List\u003c? super Person\u003e list2 = null; List\u003cStudent\u003e list3 = null; List\u003cPerson\u003e list4 = null; List\u003cObject\u003e list5 = null; list1 = list3; list1 = list4; // list1 = list5; // 编译不通过 list2 = list4; // list2 = list3;//编译不通过 // list1.add(new Student());//编译不通过 list2.add(new Person());//编译通过 list2.add(new Student());//编译通过 } } ","date":"2021-08-11","objectID":"/java-shk-9/:1:4","tags":null,"title":"Java零基础教程（九.泛型）","uri":"/java-shk-9/"},{"categories":null,"content":"1. 字符串相关的类 ","date":"2021-04-19","objectID":"/java-shk-8/:1:0","tags":["Java"],"title":"Java零基础教程（八.常用类）","uri":"/java-shk-8/"},{"categories":null,"content":"1.1 String的使用 String：字符串，使用一对\"\"引起来表示。 String声明为final的，不可被继承 String实现了Serializable接口：表示字符串是支持序列化的。实现了Comparable接口：表示String可以比较大小。 String内部定义了final char[] value用于存储字符串数据 String：代表不可变的字符序列。简称：不可变性。 体现： 当对字符串重新赋值时，需要重写指定内存区赋值，不能使用原有的value进行赋值。 当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值（因为value是final的）。 当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。 通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在方法区内的字符串常量池中。 字符串常量池中是不会存储相同内容的字符串的。 结论： 常量与常量的拼接结果在常量池中。且常量池中不会存在相同内容的常量。 只要其中有一个是变量，结果就在堆中 如果拼接的结果调用intern()方法，返回值就在常量池中。 String的实例化方式： 方式一：通过字面量定义的方式 方式二：通过new + 构造器的方式 面试题：String s = new String(\"abc\");方式创建对象，在内存中创建了几个对象？ 两个：一个是堆空间中new结构，另一个是char[]对应的常量池中的数据：“abc” package com.atguigu.java; import org.junit.Test; public class StringTest { @Test public void test3() { String s1 = \"javaEE\"; String s2 = \"hadoop\"; String s3 = \"javaEEhadoop\"; String s4 = \"javaEE\" + \"hadoop\"; String s5 = s1 + \"hadoop\"; String s6 = \"javaEE\" + s2; String s7 = s1 + s2; System.out.println(s3 == s4);// true System.out.println(s3 == s5);// false System.out.println(s3 == s6);// false System.out.println(s3 == s7);// false System.out.println(s5 == s6);// false System.out.println(s5 == s7);// false System.out.println(s6 == s7);// false String s8 = s5.intern();// 返回值得到的s8使用的常量值中已经存在的\"javaEEhadoop\" System.out.println(s3 == s8); } @Test public void test1() { String s1 = \"abc\"; // 字面量的定义方式 String s2 = \"abc\"; // s1 = \"hello\"; // System.out.println(s1); // hello // System.out.println(s2); // abc System.out.println(s1 == s2); // true String s3 = \"abc\"; s3 += \"def\"; System.out.println(s3);// abcdef System.out.println(s2);// abc String s4 = \"abc\"; s4 = s4.replace('a','m'); System.out.println(s4); } @Test public void test2() { // 通过字面量定义的方式：此时的s1和s2的数据javaEE声明在方法区中的字符串常量池中。 String s1 = \"javaEE\"; String s2 = \"javaEE\"; // 通过new + 构造器的方式：此时的s3和s4保存的地址值，是数据在堆空间中开辟空间以后对应的地址值。 String s3 = new String(\"javaEE\"); String s4 = new String(\"javaEE\"); // 解释：s1和s2指向字符串常量池中javaEE内存地址， // s3和s4分别指向堆中各创建的对象，两个对象里面各自的value变量都指向了之前的常量池中javaEE内存地址。 System.out.println(s1 == s2);// true System.out.println(s1 == s3);// false System.out.println(s1 == s4);// false System.out.println(s3 == s4);// false } } 再来看一个String值不可变性的例子： package com.atguigu.exer; public class StringTest { String str = new String(\"good\"); char[] ch = {'t', 'e', 's', 't'}; public void change(String str, char ch[]) { str = \"test ok\"; // 如果改为this.str，str就变为test ok了。 ch[0] = 'b'; } public static void main(String[] args) { StringTest ex = new StringTest(); ex.change(ex.str, ex.ch); System.out.println(ex.str);// good System.out.println(ex.ch);// best } } ","date":"2021-04-19","objectID":"/java-shk-8/:1:1","tags":["Java"],"title":"Java零基础教程（八.常用类）","uri":"/java-shk-8/"},{"categories":null,"content":"1.2 String常用方法 String常用方法 int Length(): 返回字符串的长度： return value.length char charAt(int index): 返回某索引处的字符 return value[index] boolean isEmpty(): 判断是否是空字符串：return value.length == 0 String toLowerCase(): 使用默认语言环境，将String中的所有字符转换为小写 String toUpperCase(): 使用默认语言环境，将String中的所有字符转换为大写 String trim(): 返回字符串的副本，忽略前导空白和尾部空白 boolean equals(Object obj): 比较字符串的内容是否相同 boolean equalsIgnoreCase(String anotherString): 与equals方法类似，忽略大小写 String concat(String str): 将指定字符串连接到此字符串的结尾。等价于用\"+” int compareTo(String anotherString): 比较两个字符串的大小 String substring(int beginIndex): 返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。 String substring(int beginIndex, int endIndex): 返回一个新字符串，它是此字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串。 boolean endsWith(String suffix): 测试此字符串是否以指定的后缀结束 boolean startsWith(String prefix): 测试此字符串是否以指定的前缀开始 boolean startsWith(String prefix, int toffset):测试此字符串从指定索引开始的子字符串是否以指定的前缀开始 int indexOf(String str): 返回指定子字符串在此字符串中第一次出现处的索引 int indexOf(String str, int fromIndex): 返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始找 int lastIndexOf(String str): 返回指定子字符串在此字符串中最右边出现处的索引 int lastIndexOf(String str, int fromIndex): 返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索 注：indexOf和lastIndexOf方法如果未找到都是返回-1 String replace(char oldChar, char newChar): 返回一个新的字符串，它是通过newChar替换此字符串中出现的所有oldChar得到的。 String replace(CharSequence target, CharSequence replacement):使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。 String replaceAll(String regex, String replacement):使用给定的replacement替换此字符串所有匹配给定的正则表达式的子字符串。 String replaceFirst(String regex, String replacement):使用给定的replacement替换此字符串匹配给定的正则表达式的第一个子字符串。 boolean matches(String regex):告知此字符串是否匹配给定的正则表达式。 String[] split(String regex): 根据给定正则表达式的匹配拆分此字符串 String[] split(String regex, int limit): 根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。 package com.atguigu.java; import org.junit.Test; public class StringMethodTest { @Test public void test4() { String str1 = \"北京尚硅谷教育北京\"; System.out.println(str1.replace('北','东')); System.out.println(str1.replace(\"北京\", \"上海\")); } @Test public void test3() { String str1 = \"helloworld\"; System.out.println(str1.endsWith(\"ld\"));// true System.out.println(str1.startsWith(\"He\"));// false System.out.println(str1.startsWith(\"ll\",2));// true System.out.println(str1.contains(\"wo\"));// true System.out.println(str1.indexOf(\"lo\"));//3 System.out.println(str1.indexOf(\"lo\", 5));//-1 System.out.println(\"hellorworld\".lastIndexOf(\"or\"));//7 System.out.println(\"hellorworld\".lastIndexOf(\"or\",6));//4 // 什么情况下，indexOf(str)和lastIndexOf(str)返回值相同 // 仅出现一次，或没出现 } @Test public void test2() { String s1 = \"HelloWorld\"; String s2 = \"helloworld\"; System.out.println(s1.equals(s2)); System.out.println(s1.equalsIgnoreCase(s2)); String s3 = \"abc\"; String s4 = s3.concat(\"def\"); System.out.println(s4); String s5 = \"abc\"; String s6 = new String(\"abe\"); System.out.println(s5.compareTo(s6));//-2,涉及到字符串排序 String s7 = \"北京尚硅谷教育\"; System.out.println(s7.substring(2,5));// 尚硅谷 } @Test public void test1() { String s1 = \"HelloWorld\"; System.out.println(s1.length()); System.out.println(s1.charAt(0)); System.out.println(s1.charAt(9)); // s1 = \"\"; System.out.println(s1.isEmpty()); String s2 = s1.toLowerCase(); System.out.println(s1);//s1不可变的，仍然为原来的字符串 System.out.println(s2); String s3 = \" he llo wo rld \"; String s4 = s3.trim(); System.out.println(s4); } } ","date":"2021-04-19","objectID":"/java-shk-8/:1:2","tags":["Java"],"title":"Java零基础教程（八.常用类）","uri":"/java-shk-8/"},{"categories":null,"content":"1.3 String与其他数据类型的转换 涉及到String类与其他结构之间的转换 String与基本数据类型，包装类之间的转换（复习）: String -\u003e 基本数据类型，包装类：调用包装类的静态方法：parseXxx(str) 基本数据类型，包装类 -\u003e String：调用String重载的valueOf(xxx) String与char[]之间的转换： String -\u003e char[]: 调用String的toCharArray() char[] -\u003e String: 调用String的构造器 String与byte[]之间的转换： 编码：String -\u003e byte[]:调用String的getBytes() 解码：bytes[] -\u003e String: 调用String的构造器 关于编码解码的说明： 编码：字符串 -\u003e 字节 （看得懂 -\u003e 看不懂的二进制数据） 解码：编码的逆过程，字节 -\u003e 字符串（看不懂的二进制数据 -\u003e 看得懂） 注意：解码时，要求解码使用的字符集必须与编码时使用的字符集一致，否则会出现乱码。 package com.atguigu.java; import org.junit.Test; import java.io.UnsupportedEncodingException; import java.util.Arrays; /* */ public class StringTest1 { @Test public void test4() { String s1 = \"javaEEhadoop\"; String s2 = \"javaEE\"; String s3 = s2 + \"hadoop\"; System.out.println(s1 == s3);// false final String s4 = \"javaEE\";// 这里s4是一个常量 String s5 = s4 + \"hadoop\"; System.out.println(s1 == s5);// true } @Test public void test3() throws UnsupportedEncodingException { String str1 = \"abc123中国\"; byte[] bytes = str1.getBytes();// 使用默认的字符集，utf-8一个汉字对应3bytes，gbk字符集一个汉字对应2bytes System.out.println(Arrays.toString(bytes)); // [97, 98, 99, 49, 50, 51, -28, -72, -83, -27, -101, -67] System.out.println(new String(bytes));// 使用默认的字符集，进行解码 byte[] gbks = str1.getBytes(\"gbk\"); System.out.println(new String(gbks));// 出现乱码。原因：编码集和解码集不一致 System.out.println(new String(gbks, \"gbk\")); } @Test public void test2() { String str1 = \"abc123\"; char[] charArray = str1.toCharArray(); for (int i = 0; i \u003c charArray.length; i++) { System.out.println(charArray[i]); } char[] arr = new char[]{'h','e','l','l','o'}; System.out.println(new String(arr)); } @Test public void test1() { String str1 = \"123\"; int num = Integer.parseInt(str1); System.out.println(String.valueOf(num)); String str2 = num + \"\"; System.out.println(str1 == str2);//str1在常量池中，str2在堆中 } } ","date":"2021-04-19","objectID":"/java-shk-8/:1:3","tags":["Java"],"title":"Java零基础教程（八.常用类）","uri":"/java-shk-8/"},{"categories":null,"content":"1.4 String, StringBuilder, StringBuffer 关于StringBuffer和StringBuilder的使用 String，StringBuffer，StringBuilder三者的异同： String：不可变的字符序列；底层使用char[]存储 StringBuffer：可变的字符序列：线程安全的，效率低；底层使用char[]存储 StringBuilder：可变的字符序列：jdk5.0新增的，线程不安全的，效率高；底层使用char[]存储 源码分析： String str = new String();// new char[0]; String str1 = new String(\"abc\");// new char[]{'a','b','c'}; StringBuffer sb1 = new StringBuffer();// new char[16];底层创建了一个长度是16的数组。 sb1.append('a');// value[0] = 'a'; sb1.append('b');// value[1] = 'b'; StringBuffer sb2 = new StringBuffer(\"abc\");// char[] value = new char[\"\"abc\".length() + 16] 问题1. System.out.println(sb2.length()); 问题2. 扩容问题：如果要添加的数据底层数组盛不下了，那就需要扩容底层数组。默认情况下，扩容为原来容量的2倍 + 2， 同时将原有数组中的元素复制到新的数组中。 指导意义：开发中建议大家使用：StringBuffer(int capacity) 或 StringBuilder(int capacity) StringBuffer类的常用方法 StringBuffer append(xxx): 提供了很多的append()方法，用于进行字符串拼接 StringBuffer delete(int start, int end): 删除指定位置的内容 StringBuffer replace(int start, int end, string str): 把[start,end)位置替换为str StringBuffer insert(int offset, xxx): 在指定位置插入xxx StringBuffer reverse(): 把当前字符序列逆转 public int indexOf(String str) public String substring(int start, int end) public int length() public char charAt(int n) public void setCharAt(int n, char ch) 总结： 增：append(xxx) 删：delete(int start, int end) 改：setCharAt(int n, char ch) / replace(int start, int end, string str) 查：charAt(int n) 插：insert(int offset, xxx) 长度：length() 遍历：for() + charAt() / toString() 对比String, StringBuffer, StringBuilder三者效率： 从高到低排序：StringBuilder \u003e StringBuffer \u003e String package com.atguigu.java; import org.junit.Test; public class StringBufferBuilderTest { @Test public void test1() { StringBuffer sb1 = new StringBuffer(\"abc\"); sb1.setCharAt(0,'m'); System.out.println(sb1); // mbc StringBuffer sb2 = new StringBuffer(); System.out.println(sb2.length());//0 } @Test public void test2() { StringBuffer s1 = new StringBuffer(\"abc\"); s1.append(1); s1.append('1'); System.out.println(s1); s1.delete(2,4); System.out.println(s1);//ab1 s1.replace(2,4,\"hello\"); s1.insert(2, false); System.out.println(s1);// abfalsehello s1.reverse(); System.out.println(s1);// olleheslafba String s2 = s1.substring(1,3); } @Test public void test3() { long startTime = 0L; long endTime = 0L; String text = \"\"; StringBuffer buffer = new StringBuffer(\"\"); StringBuilder builder = new StringBuilder(\"\"); startTime = System.currentTimeMillis(); for (int i = 0; i \u003c 20000; i++) { buffer.append(String.valueOf(i)); } endTime = System.currentTimeMillis(); System.out.println(\"StringBuffer的执行时间：\" + (endTime - startTime)); startTime = System.currentTimeMillis(); for (int i = 0; i \u003c 20000; i++) { builder.append(String.valueOf(i)); } endTime = System.currentTimeMillis(); System.out.println(\"StringBuilder的执行时间：\" + (endTime - startTime)); startTime = System.currentTimeMillis(); for (int i = 0; i \u003c 20000; i++) { text = text + i; } endTime = System.currentTimeMillis(); System.out.println(\"String的执行时间：\" + (endTime - startTime)); } } ","date":"2021-04-19","objectID":"/java-shk-8/:1:4","tags":["Java"],"title":"Java零基础教程（八.常用类）","uri":"/java-shk-8/"},{"categories":null,"content":"2. JDK 8之前的日期时间API (Optional) JDK 8之前日期和时间的API测试 java.util.Date类 ｜ --- java.sql.Date类 两个构造器的使用 构造器一：Date():创建一个对应当前时间的Date对象 构造器二：创建指定毫秒数的Date对象 两个方法的使用 toString(): 显示当前的年月日时分秒 getTime(): 获取当前Date对象对应的毫秒数(时间戳) java.sql.Date对应着数据库中的日期类型的变量 如何实例化 如何将java.util.Date对象转换为java.sql.Date对象 package com.atguigu.java; import org.junit.Test; import java.util.Date; public class DateTimeTest { @Test public void test1() { long time = System.currentTimeMillis(); //返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差 // 称为时间戳 System.out.println(time); } @Test public void test2() { // 构造器一：Date(): 创建一个对应当前时间的Date对象 Date date1 = new Date(); System.out.println(date1.toString());//Sat Apr 24 11:34:27 PDT 2021 System.out.println(date1.getTime());//1619289267341 // 构造器二：Date Date date2 = new Date(1619289267341L); System.out.println(date2.toString()); java.sql.Date date3 = new java.sql.Date(1619289267341L); System.out.println(date3);//2021-04-24 // 如何将java.util.Date对象转换为java.sql.Date对象 // 情况一：向下转型 Date date4 = new java.sql.Date(1619289267341L); java.sql.Date date5 = (java.sql.Date) date4; // 情况二： Date date6 = new Date(); // java.sql.Date date7 = (java.sql.Date) date6;// 报错ClassCastException java.sql.Date date7 = new java.sql.Date(date6.getTime()); } } jdk 8之前的日期时间API测试 System类中currentTimeMillis(); java.util.Date和子类java.sql.Date SimpleDateFormat Calendar 注意： 获取月份时：一月是0，二月是1，以此类推，12月是11 获取星期时：周日是1，周二是2，以此类推，周六是7 package com.atguigu.java; import org.junit.Test; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Calendar; import java.util.Date; public class DateTimeTest { /* SimpleDateFormat的使用：SimpleDateFormat对日期Date类的格式化和解析 1. 两个操作： 1.1 格式化：日期 ---\u003e 字符串 1.2 解析：格式化的逆过程，字符串 ---\u003e 日期 2. SimpleDateFormat的实例化 */ @Test public void testSimpleDateFormat() throws ParseException { //实例化SimpleDateFormat SimpleDateFormat sdf = new SimpleDateFormat(); //格式化：日期 ---\u003e 字符串 Date date = new Date(); System.out.println(date); String format = sdf.format(date); System.out.println(format); //解析：格式化的逆过程，字符串 ---\u003e 日期 String str = \"4/24/21, 11:54 PM\"; Date date1 = sdf.parse(str); System.out.println(date1); System.out.println(\"=========按照指定的方式格式化和解析：调用带参的构造器=========\"); SimpleDateFormat sdf1 = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\"); System.out.println(sdf1.format(date)); // 解析：要求字符串必须是符合SimpleDateFormat识别的格式（通过构造器参数体现） // 否则抛异常 System.out.println(sdf1.parse(\"2021-04-24 11:57:20\")); } @Test public void testExer() throws ParseException { // 练习一：字符串转换为java.sql.Date String birth = \"2020-09-28\"; SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\"); Date date = sdf.parse(birth); java.sql.Date birthDate = new java.sql.Date(date.getTime()); System.out.println(birthDate); } /* Calendar日历类的使用 */ @Test public void testCalendar() { // 1. 实例化 // 方式一：创建其子类（GregorianCalendar）的对象 // 方式二：调用其静态方法getInstance() Calendar calendar = Calendar.getInstance(); System.out.println(calendar.getClass()); // 2. 常用方法 // get() int days = calendar.get(Calendar.DAY_OF_MONTH); System.out.println(days);//25 System.out.println(calendar.get(Calendar.DAY_OF_YEAR));//115 // set() calendar.set(Calendar.DAY_OF_MONTH, 22); System.out.println(calendar.get(Calendar.DAY_OF_MONTH));//22 // add() calendar.add(Calendar.DAY_OF_MONTH, -3); System.out.println(calendar.get(Calendar.DAY_OF_MONTH));//19 // getTime(): 日历类---\u003eDate Date date = calendar.getTime(); System.out.println(date);//Mon Apr 19 16:16:17 PDT 2021 // setTime(): Date---\u003e日历类 Date date1 = new Date(); calendar.setTime(date1); System.out.println(calendar.getTime());//Sun Apr 25 16:16:17 PDT 2021 } } ","date":"2021-04-19","objectID":"/java-shk-8/:2:0","tags":["Java"],"title":"Java零基础教程（八.常用类）","uri":"/java-shk-8/"},{"categories":null,"content":"3. JDK 8中新日期时间API LocalDate, LocalTime, LocalDateTime的使用：LocalDateTime相较于LocalDate和LocalTime使用频率要高，类似于Calendar。 Instant的使用。类似于java.util.Date类。 DateTimeFormatter:格式化或解析日期，时间。类似于SimpleDateFormat。 package com.atguigu.java; import org.junit.Test; import java.time.*; import java.time.format.DateTimeFormatter; import java.time.format.FormatStyle; import java.time.temporal.TemporalAccessor; public class JDK8DateTimeTest { @Test public void test1() { // now(): 获取当前的日期，时间，日期+时间 LocalDate localDate = LocalDate.now(); LocalTime localTime = LocalTime.now(); LocalDateTime localDateTime = LocalDateTime.now(); System.out.println(localDate); System.out.println(localTime); System.out.println(localDateTime); // of():设置指定的年月日时分秒。没有偏移量 LocalDateTime localDateTime1 = LocalDateTime.of(2020,10,6,13,23,43); System.out.println(localDateTime1); //getXxx() System.out.println(localDateTime.getDayOfMonth());//25 System.out.println(localDateTime.getDayOfWeek());//SUNDAY // 体现不可变性 // withXxx():设置相关属性 LocalDate localDate1 = localDate.withDayOfMonth(22); System.out.println(localDate);//2021-04-25 System.out.println(localDate1);//2021-04-22 LocalDateTime localDateTime2 = localDateTime.plusMonths(3); System.out.println(localDateTime2); } @Test public void test2() { // now(): 获取本初子午线对应的标准时间 Instant instant = Instant.now(); System.out.println(instant); // 添加时间的偏移量 OffsetDateTime offsetDateTime = instant.atOffset(ZoneOffset.ofHours(8)); System.out.println(offsetDateTime); // 获取自1970年1月1日0时0分0秒（UTC）开始的毫秒数 long milli = instant.toEpochMilli(); System.out.println(milli); // ofEpochMilli():通过给定的毫秒数，获取Instant实例 Instant instant1 = Instant.ofEpochMilli(1619394493520L); System.out.println(instant1); } @Test public void test3() { // 方式一：预定义的标准格式： DateTimeFormatter formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME; LocalDateTime localDateTime = LocalDateTime.now(); String str1 = formatter.format(localDateTime); System.out.println(localDateTime); System.out.println(str1); // 解析：字符串-\u003e日期 TemporalAccessor parse = formatter.parse(str1); System.out.println(parse); // 方式二：本地化相关的格式。如ofLocalizedDateTime() // FormatStyle.LONG / FormatStyle.MEDIUM / FormatStyle.SHORT DateTimeFormatter formatter1 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.SHORT); String str2 = formatter1.format(localDateTime); System.out.println(str2); // 方式三：自定义的格式。如 ofPattern(\"yyyy-MM-dd hh:mm:ss E\") DateTimeFormatter formatter2 = DateTimeFormatter.ofPattern(\"yyyy-MM-dd hh:mm:ss\"); String str4 = formatter2.format(LocalDateTime.now()); System.out.println(str4); // 解析 TemporalAccessor accessor = formatter2.parse(\"2019-02-18 03:52:09\"); System.out.println(accessor); } } ","date":"2021-04-19","objectID":"/java-shk-8/:3:0","tags":["Java"],"title":"Java零基础教程（八.常用类）","uri":"/java-shk-8/"},{"categories":null,"content":"4. Java比较器 Java中的对象，正常情况下，只能进行比较：== 或 != 。 不能使用\u003e或\u003c。但是在开发场景中，我们需要对多个对象进行排序，言外之意，就需要比较对象的大小。如何实现？使用两个接口中的任何一个：Comparable或Comparator。Comparable接口的方式一旦一定，保证Comparable接口实现类的对象在任何位置都可以比较大小，而Comparator接口属于临时性的比较。 ","date":"2021-04-19","objectID":"/java-shk-8/:4:0","tags":["Java"],"title":"Java零基础教程（八.常用类）","uri":"/java-shk-8/"},{"categories":null,"content":"4.1 Comparable接口 Comparable接口的使用举例：自然排序 像String，包装类等实现了Comparable接口，重写了compareTo()方法，给出了比较两个对象大小的方式 像String，包装类重写compareTo()方法以后，进行了从小到大的排列 重写compareTo(obj)的规则： 如果当前对象this大于形参对象obj，则返回正整数， 如果当前对象this小于形参对象obj，则返回负整数， 如果当前对象this等于形参对象obj，则返回零。 对于自定义类来说，如果需要排序，我们可以让自定义类实现Comparable接口，重写compareTo(obj), 在compareTo(obj)方法中指明如何排序。 ","date":"2021-04-19","objectID":"/java-shk-8/:4:1","tags":["Java"],"title":"Java零基础教程（八.常用类）","uri":"/java-shk-8/"},{"categories":null,"content":"4.2 Comparator接口 Comparator接口的使用：定制排序 背景：当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码，或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑使用Comparator的对象来排序。 重写compare(Object o1, Object o2)方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2; 如果返回0，表示相等；返回负整数，则表示o1小于o2。 package com.atguigu.java; import org.junit.Test; import java.util.Arrays; import java.util.Comparator; public class CompareTest { @Test public void test1() { String[] arr = new String[]{\"AA\", \"CC\", \"KK\", \"MM\", \"GG\", \"JJ\", \"DD\"}; Arrays.sort(arr); System.out.println(Arrays.toString(arr)); } @Test public void test2() { Goods[] arr = new Goods[4]; arr[0] = new Goods(\"iphone\", 1200); arr[1] = new Goods(\"xiaomi\", 500); arr[2] = new Goods(\"huawei\", 1000); arr[3] = new Goods(\"oppo\", 300); Arrays.sort(arr); System.out.println(Arrays.toString(arr)); } @Test public void test3() { String[] arr = new String[]{\"AA\", \"CC\", \"KK\", \"MM\", \"GG\", \"JJ\", \"DD\"}; Arrays.sort(arr, new Comparator() { @Override public int compare(Object o1, Object o2) { if (o1 instanceof String \u0026\u0026 o2 instanceof String) { String s1 = (String) o1; String s2 = (String) o2; return -s1.compareTo(s2); } throw new RuntimeException(\"输入的数据类型不一致\"); } }); System.out.println(Arrays.toString(arr)); } @Test public void test4() { Goods[] arr = new Goods[4]; arr[0] = new Goods(\"iphone\", 1200); arr[1] = new Goods(\"xiaomi\", 500); arr[2] = new Goods(\"huawei\", 1000); arr[3] = new Goods(\"oppo\", 300); Arrays.sort(arr, new Comparator() { @Override public int compare(Object o1, Object o2) { if (o1 instanceof Goods \u0026\u0026 o2 instanceof Goods) { Goods g1 = (Goods) o1; Goods g2 = (Goods) o2; if (g1.getName().equals(g2.getName())) { return -Double.compare(g1.getPrice(), g2.getPrice()); } else { return g1.getName().compareTo(g2.getName()); } } throw new RuntimeException(\"输入的数据类型不一致\"); } }); System.out.println(Arrays.toString(arr)); } } ","date":"2021-04-19","objectID":"/java-shk-8/:4:2","tags":["Java"],"title":"Java零基础教程（八.常用类）","uri":"/java-shk-8/"},{"categories":null,"content":"5. 枚举类 ","date":"2021-04-19","objectID":"/java-shk-8/:5:0","tags":["Java"],"title":"Java零基础教程（八.常用类）","uri":"/java-shk-8/"},{"categories":null,"content":"5.1 如何自定义枚举类 一·枚举类的使用 枚举类的理解：类的对象只有有限个，确定的。我们称此类为枚举类 当需要定义一组常量时，强烈建议使用枚举类 如果枚举类中只有一个对象，则可以作为单例模式的实现方式。 二·如何定义枚举类 方式一：jdk 5之前，自定义枚举类 方式二：jdk 5之后，可以使用enum关键字定义枚举类 三·Enum类中的常用方法 values()：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。 valueOf(String str)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象。 toString()：返回当前枚举类对象常量的名称。 四·使用enum关键字定义的枚举类实现接口的情况 情况一：实现接口，在enum类中实现抽象方法 情况二：让枚举类的对象分别实现接口中的抽象方法。 package com.atguigu.java; public class SeasonTest { public static void main(String[] args) { Season spring = Season.SPRING; System.out.println(spring.toString()); } } class Season { // 1. 声明Season对象的属性 private final String seasonName; private final String seasonDesc; // 2. 私有化类的构造器, 并给对象属性赋值 private Season(String seasonName, String seasonDesc) { this.seasonName = seasonName; this.seasonDesc = seasonDesc; } // 3. 提供当前枚举类的多个对象 public static final的 public static final Season SPRING = new Season(\"春天\", \"春暖花开\"); public static final Season SUMMER = new Season(\"夏天\", \"夏日炎炎\"); public static final Season AUTUMN = new Season(\"秋天\", \"秋高气爽\"); public static final Season WINTER = new Season(\"冬天\", \"冰天雪地\"); // 4. 其他诉求：获取枚举类对象的属性 public String getSeasonName() { return seasonName; } public String getSeasonDesc() { return seasonDesc; } // 5. 其他诉求：提供toString方法 @Override public String toString() { return \"Season{\" + \"seasonName='\" + seasonName + '\\'' + \", seasonDesc='\" + seasonDesc + '\\'' + '}'; } } ","date":"2021-04-19","objectID":"/java-shk-8/:5:1","tags":["Java"],"title":"Java零基础教程（八.常用类）","uri":"/java-shk-8/"},{"categories":null,"content":"5.2 关键字enum package com.atguigu.java; import java.util.Arrays; /* 使用enum关键字定义枚举类 说明：定义的枚举类默认继承于java.lang.Enum类 */ public class SeasonTest1 { public static void main(String[] args) { Season1 summer = Season1.SUMMER; System.out.println(summer); // Season1{seasonName='夏天', seasonDesc='夏日炎炎'} System.out.println(Season1.class.getSuperclass()); // class java.lang.Enum Season1[] values = Season1.values(); System.out.println(Arrays.toString(values)); System.out.println(Arrays.toString(Thread.State.values())); // [NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED] // valueOf(String objName): 返回枚举类中对象名是objName的对象 Season1 winter = Season1.valueOf(\"WINTER\"); // 如果没有objName的枚举类对象，则抛异常：IllegalArgumentException // Season1 winter = Season1.valueOf(\"WINTER1\"); System.out.println(winter); // Season1{seasonName='冬天', seasonDesc='冰天雪地'} winter.show(); // 大约在冬季 } } interface info { void show(); } enum Season1 implements info { // 1. 提供当前枚举类的多个对象 多个对象之间用\",\"隔开，末尾对象用\";\"结束 SPRING(\"春天\", \"春暖花开\") { @Override public void show() { System.out.println(\"春天在哪里\"); } }, SUMMER(\"夏天\", \"夏日炎炎\") { @Override public void show() { System.out.println(\"宁夏\"); } }, AUTUMN(\"秋天\", \"秋高气爽\") { @Override public void show() { System.out.println(\"秋天不回来\"); } }, WINTER(\"冬天\", \"冰天雪地\") { @Override public void show() { System.out.println(\"大约在冬季\"); } }; // 2. 声明Season对象的属性 private final String seasonName; private final String seasonDesc; // 3. 私有化类的构造器, 并给对象属性赋值 private Season1(String seasonName, String seasonDesc) { this.seasonName = seasonName; this.seasonDesc = seasonDesc; } // 4. 其他诉求：获取枚举类对象的属性 public String getSeasonName() { return seasonName; } public String getSeasonDesc() { return seasonDesc; } // 5. 其他诉求：提供toString方法 @Override public String toString() { return \"Season1{\" + \"seasonName='\" + seasonName + '\\'' + \", seasonDesc='\" + seasonDesc + '\\'' + '}'; } @Override public void show() { System.out.println(\"这是一个季节\"); } } ","date":"2021-04-19","objectID":"/java-shk-8/:5:2","tags":["Java"],"title":"Java零基础教程（八.常用类）","uri":"/java-shk-8/"},{"categories":null,"content":"5.3 Enum类常用方法 ","date":"2021-04-19","objectID":"/java-shk-8/:5:3","tags":["Java"],"title":"Java零基础教程（八.常用类）","uri":"/java-shk-8/"},{"categories":null,"content":"5.4 实现接口的枚举类 ","date":"2021-04-19","objectID":"/java-shk-8/:5:4","tags":["Java"],"title":"Java零基础教程（八.常用类）","uri":"/java-shk-8/"},{"categories":null,"content":"6. 注解(Annotation) 从JDK 5开始，Java增加了对元数据（MetaData）的支持，也就是Annotation（注解）。Annotation其实就是代码里的特殊标记，这些标记可以在编译，类加载，运行时被读取，并执行相应的处理。通过使用Annotation，程序员可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充信息。代码分析工具，开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。 Annotation可以像修饰符一样被使用，可用于修饰包，类，构造器，方法，成员变量，参数，局部变量的声明，这些信息被保存在Annotation的“name=value”对中。 在JavaSE中，注解的使用比较简单，例如标记过时的功能，忽略警告等。在JavaEE/Android中注解占据了更重要的角色，例如用来配置应用程序等任何切面，代替Java旧版中所遗留的繁冗代码和XML配置等。 未来的开发模式都是基于注解的，JPA是基于注解的，Spring2.5以上都是基于注解的，Hibernate3.x以后也是基于注解的，现在的Struts2有一部分也是基于注解的了。注解是一种趋势，一定程度上可以说：框架 = 注解 + 反射 + 设计模式。 ","date":"2021-04-19","objectID":"/java-shk-8/:6:0","tags":["Java"],"title":"Java零基础教程（八.常用类）","uri":"/java-shk-8/"},{"categories":null,"content":"6.1 注解的使用 理解Annotation Annotation的使用示例 示例一：生成文档相关的注解 示例二：在编译时进行格式检查（JDK内置的三个基本注解） @Override: 限定重写父类方法，该注解只能用于方法 @Deprecated: 用于表示所修饰的元素（类，方法等）已过时。通常是因为所修饰的结构危险或存在更好的选择。 @SuppressWarnings: 抑制编译期警告 示例三：跟踪代码依赖性，实现替代配置文件功能。 如何自定义注解：参照@suppressWarnings定义 注解声明为：@interface 内部定义成员，通常使用value表示 可以指定成员的默认值，使用default定义 如果自定义注解没有成员，表明是一个标识作用。 如果注解有成员，在使用注解时，需要指明成员的值。 自定义注解必须配上注解的信息处理流程（使用反射）才有意义。 自定义注解通常都会指明两个元注解：Retention，Target jdk提供的4种元注解(元注解：对现有的注解进行解释说明的注解) @Retention:指定所修饰的Annotation的生命周期：SOURCE/CLASS（默认）/RUNTIME 只有声明为RUNTIME生命周期的注解，才能通过反射获取。 @Target: 用于指定被修饰的Annotation能用于修饰哪些程序元素 ===== 出现的频率较低 ===== @Documented：表示所修饰的注解在被javadoc解析时，保留下来。 @Inherited：被它修饰的Annotation将具有继承性。 通过反射获取注解信息 — 到反射内容时系统讲解。 jdk8中注解的新特性：可重复注解，类型注解 package com.atguigu.java1; import org.junit.Test; import java.lang.annotation.Annotation; import java.util.Arrays; /* */ public class AnnotationTest { @Test public void testGetAnnotation() { Class clazz = Student.class; Annotation[] annotations = clazz.getAnnotations(); System.out.println(Arrays.toString(annotations)); } } @MyAnnotation(value = \"hi\") class Person { private String name; private int age; @MyAnnotation public Person(String name, int age) { this.name = name; this.age = age; } public void walk() { System.out.println(\"人走路\"); } public void eat() { System.out.println(\"人吃饭\"); } } interface Info { void show(); } class Student extends Person implements Info { @Override public void walk() { System.out.println(\"学生走路\"); } public Student(String name, int age) { super(name, age); } @Override public void show() { } } package com.atguigu.java1; import java.lang.annotation.Inherited; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; import static java.lang.annotation.ElementType.*; @Inherited @Retention(RetentionPolicy.RUNTIME) @Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE}) public @interface MyAnnotation { String value() default \"hello\"; } ","date":"2021-04-19","objectID":"/java-shk-8/:6:1","tags":["Java"],"title":"Java零基础教程（八.常用类）","uri":"/java-shk-8/"},{"categories":null,"content":"7. 集合 集合框架的概述 集合，数组都是对多个数据进行存储操作的结构，简称Java容器。 说明：此时的存储，主要指的是内存层面的存储，不涉及到持久化的存储（.txt,.jpg,.avi,数据库中） 数组在存储多个数据方面的特点： 一旦初始化以后，其长度就确定了。 数组一旦定义好，其元素的类型也就确定了，我们也就只能操作指定类型的数据了。比如：String[] arr; int[] arr1; 数组在存储多个数据方面的缺点： 一旦初始化以后，其长度就不可修改。 数组中提供的方法非常有限，对于添加，删除，插入数据等操作，非常不便，同时效率不高。 获取数组中实际元素的个数的需求，数组没有现成的属性或方法可用。 数组存储数据的特点：有序，可重复。对于无序，不可重复的需求，不能满足。 ","date":"2021-04-19","objectID":"/java-shk-8/:7:0","tags":["Java"],"title":"Java零基础教程（八.常用类）","uri":"/java-shk-8/"},{"categories":null,"content":"7.1 Java集合框架概述 Java集合可分为Collection和Map两种体系 Collection接口：单列数据，定义了存取一组对象的方法的集合 List：元素有序，可重复的集合 Set：元素无序，不可重复的集合 Map接口：双列数据，保存具有映射关系“key-value对”的集合 |--- Collection接口：单列集合，用来存储一个一个的对象 |--- List接口：存储有序的，可重复的数据。---\u003e \"动态数组\" |--- ArrayList, LinkedList, Vector |--- Set接口：存储无序的，不可重复的数据。---\u003e \"高中讲的集合\" |--- HashSet, LinkedHashSet, TreeSet |--- Map接口：双列集合，用来存储一对（key - value）一对的数据 ---\u003e \"高中函数：y = f(x)\" |--- HashMap, LinkedHashMap, TreeMap, Hashtable, Properties ","date":"2021-04-19","objectID":"/java-shk-8/:7:1","tags":["Java"],"title":"Java零基础教程（八.常用类）","uri":"/java-shk-8/"},{"categories":null,"content":"7.2 Collection接口方法 package com.atguigu.java2; import org.junit.Test; import java.util.ArrayList; import java.util.Collection; import java.util.Date; public class CollectionTest { @Test public void test1() { Collection coll = new ArrayList(); // add(Object e):将元素e添加到集合coll中 coll.add(\"AA\"); coll.add(\"BB\"); coll.add(123);//自动装箱 coll.add(new Date()); // size(): 获取添加的元素的个数 System.out.println(coll.size());//4 // addAll(): Collection coll1 = new ArrayList(); coll1.add(456); coll1.add(\"CC\"); coll.addAll(coll1); System.out.println(coll.size());//6 System.out.println(coll); // clear():清空集合元素 coll.clear(); // isEmpty():判断当前集合是否为空 System.out.println(coll.isEmpty()); } } package com.atguigu.java; import org.junit.Test; import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.List; /* Collection接口中声明的方法的测试 向Collection接口的实现类的对象中添加数据obj时，要求obj所在类要重写equals(). */ public class CollectionTest { @Test public void test1() { Collection coll = new ArrayList(); coll.add(123); coll.add(456); coll.add(new String(\"Tom\")); coll.add(false); // Person p = new Person(\"Jerry\", 20); // coll.add(p); coll.add(new Person(\"Jerry\", 20)); // contains(Object obj):判断当前集合中是否包含obj System.out.println(coll.contains(123));// true System.out.println(coll.contains(new String(\"Tom\")));// true,判断内容 // 本来为false, 调用equals(),实现为==。重写equals()后,返回true // 我们在判断时会调用obj对象所在类的equals()方法 System.out.println(coll.contains(new Person(\"Jerry\", 20))); // 2. containsAll(Collection coll1):判断形参coll1中的所有元素是否都存在于当前集合中 Collection coll1 = Arrays.asList(123,456); System.out.println(coll.containsAll(coll1));// true } @Test public void test2() { // 3. remove(Object obj): 从当前集合中移除obj元素 Collection coll = new ArrayList(); coll.add(123); coll.add(456); coll.add(new Person(\"Jerry\", 20)); coll.add(new String(\"Tom\")); coll.add(false); coll.remove(123); System.out.println(coll); coll.remove(new Person(\"Jerry\", 20)); System.out.println(coll);// [456, Tom, false] // 4. removeAll(Collection coll1):差集：从当前集合中移除coll1中所有的元素 Collection coll1 = Arrays.asList(456,\"Tom\"); coll.removeAll(coll1); System.out.println(coll);//[false] } @Test public void test3() { Collection coll = new ArrayList(); coll.add(123); coll.add(456); coll.add(new Person(\"Jerry\", 20)); coll.add(new String(\"Tom\")); coll.add(false); // 5. retainAll(Collection coll1): 交集：获取当前集合和coll1集合的交集，并返回给当前集合 // Collection coll1 = Arrays.asList(123,456,789); // coll.retainAll(coll1); // System.out.println(coll);// [123, 456] // 6. equals(Object obj):判断当前Collection和形参Collection中元素是否都相同。List考虑顺序，Set不考虑顺序。 Collection coll1 = new ArrayList(); coll1.add(123); coll1.add(456); coll1.add(new Person(\"Jerry\", 20)); coll1.add(new String(\"Tom\")); coll1.add(false); System.out.println(coll.equals(coll1));// true } @Test public void test4() { Collection coll = new ArrayList(); coll.add(123); coll.add(456); coll.add(new Person(\"Jerry\", 20)); coll.add(new String(\"Tom\")); coll.add(false); //7. hashCode(): 返回当前对象的哈希值 System.out.println(coll.hashCode()); // 8. 集合-\u003e数组: toArray() Object[] arr = coll.toArray(); System.out.println(Arrays.toString(arr)); // 拓展：数组-\u003e集合: 调用Arrays类的静态方法asList() List\u003cString\u003e list = Arrays.asList(new String[]{\"AA\",\"BB\",\"CC\"}); System.out.println(list);//[AA, BB, CC] //注意 System.out.println(\"===================\"); List\u003cInteger\u003e arr1 = Arrays.asList(new Integer[]{123,456}); System.out.println(arr1);//[123, 456] List arr2 = Arrays.asList(new int[]{123,456}); System.out.println(arr2);//[[I@6b57696f],有且仅有一个元素，为数组 List arr3 = Arrays.asList(new Integer[]{123,456}); System.out.println(arr3);//[123, 456] List arr4 = Arrays.asList(123,456); System.out.println(arr4);//[123, 456] // 9. iterator():返回Iterator接口的实例，用于遍历集合元素。放在IteratorTest.java中测试 } } package com.atguigu.java; import java.util.Objects; public class Person { private String name; private int age; public Person() { } public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public int getAge() { return age; } @Overr","date":"2021-04-19","objectID":"/java-shk-8/:7:2","tags":["Java"],"title":"Java零基础教程（八.常用类）","uri":"/java-shk-8/"},{"categories":null,"content":"7.3 Iterator迭代器接口 集合元素的遍历操作，使用迭代器Iterator接口 Iterator对象称为迭代器（设计模式的一种），主要用于遍历Collection集合中的元素。 GOF给迭代器模式的定义为：提供一种方法访问一个容器（container）对象中各个元素，而又不需暴露该对象的内部细节。迭代器模式，就是为容器而生。类似于\"公交车上的售票员”，“火车上的乘务员”，“空姐”。 Collection接口继承了java.lang.Iterable接口，该接口有一个iterator()方法，那么所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象。 Iterator仅用于遍历集合，Iterator本身并不提供承装对象的能力。如果需要创建Iterator对象，则必须有一个被迭代的集合。 集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。 内部的方法：hasNext()和next() 内部定义了remove(), 可以在遍历的时候，删除集合中的元素。此方法不同于集合直接调用remove()。如果还未调用next()或在上一次调用next方法之后已经调用了remove方法，再调用remove都会报IllegalStateException 迭代器主要用来遍历Collection，不用于遍历Map package com.atguigu.java; import org.junit.Test; import java.util.ArrayList; import java.util.Collection; import java.util.Iterator; public class IteratorTest { @Test public void test1() { Collection coll = new ArrayList(); coll.add(123); coll.add(456); coll.add(new Person(\"Jerry\", 20)); coll.add(new String(\"Tom\")); coll.add(false); Iterator iterator = coll.iterator(); // 方式一： // System.out.println(iterator.next()); // System.out.println(iterator.next()); // System.out.println(iterator.next()); // System.out.println(iterator.next()); // System.out.println(iterator.next()); // // 报异常：NoSuchElementException // System.out.println(iterator.next()); // 方式二：不推荐 for (int i = 0; i \u003c coll.size(); i++) { System.out.println(iterator.next()); } // 方式三：推荐 // hasNext():判断是否还有下一个元素 while (iterator.hasNext()) { // next(): 1）指针下移 2）将下移以后集合位置上的元素返回 System.out.println(iterator.next()); } } @Test public void test2() { Collection coll = new ArrayList(); coll.add(123); coll.add(456); coll.add(new Person(\"Jerry\", 20)); coll.add(new String(\"Tom\")); coll.add(false); // 错误方式一： Iterator iterator = coll.iterator(); while ((iterator.next()) != null) { System.out.println(iterator.next()); } // 错误方式二： while ((coll.iterator().hasNext())) { System.out.println(coll.iterator().next()); } } @Test public void test3() { Collection coll = new ArrayList(); coll.add(123); coll.add(456); coll.add(new Person(\"Jerry\", 20)); coll.add(new String(\"Tom\")); coll.add(false); // 删除集合中\"Tom\" Iterator iterator = coll.iterator(); while (iterator.hasNext()) { Object obj = iterator.next(); if (\"Tom\".equals(obj)) { iterator.remove(); } } // 遍历集合 iterator = coll.iterator(); while (iterator.hasNext()) { // next(): 1）指针下移 2）将下移以后集合位置上的元素返回 System.out.println(iterator.next()); } } } package com.atguigu.java; import org.junit.Test; import java.util.ArrayList; import java.util.Collection; /* jdk 5.0新增了foreach循环，用于遍历集合，数组 */ public class ForTest { @Test public void test1() { Collection coll = new ArrayList(); coll.add(123); coll.add(456); coll.add(new Person(\"Jerry\", 20)); coll.add(new String(\"Tom\")); coll.add(false); // 快捷键iter // for (集合元素的类型 局部变量: 集合对象) // 内部仍然调用了迭代器。 for (Object obj : coll) { System.out.println(obj); } } @Test public void test2() { int[] arr = new int[]{1,2,3,4,5}; for (int i : arr) { System.out.println(i); } } // 练习题 @Test public void test3() { String[] arr = new String[]{\"MM\", \"MM\", \"MM\"}; // 方式一：普通for赋值 // for (int i = 0; i \u003c arr.length; i++) { // arr[i] = \"GG\"; // } // 方式二：增强for循环 for (String s : arr) { s = \"GG\"; } for (int i = 0; i \u003c arr.length; i++) { System.out.println(arr[i]); } // MM, MM, MM // 方式二并没有改变原数组值。s值传递，同指向MM，但是赋值后，s指向了GG，而arr[i]仍指向MM。 } } ","date":"2021-04-19","objectID":"/java-shk-8/:7:3","tags":["Java"],"title":"Java零基础教程（八.常用类）","uri":"/java-shk-8/"},{"categories":null,"content":"7.4 Collection子接口一：List 7.4.1 List三个实现类的不同 面试题：ArrayList，LinkedList，Vector三者的异同？ 同：三个类都是实现了List接口，存储数据的特点相同：存储有序的，可重复的数据 不同： ArrayList:作为List接口的主要实现类，线程不安全，效率高；底层使用Object[]存储 LinkedList:对于频繁的插入，删除操作，使用此类效率比ArrayList高；底层使用双向链表存储 Vector:作为List接口的古老实现类；线程安全，效率低；底层使用Object[]存储 7.4.2 实现类的源码分析 ArrayList jdk7的情况下 ArrayList list = new ArrayList(); //底层创建了长度是10的Object[]数组elementData list.add(123);//elementData[0] = new Integer(123); ... list.add(11);//如果此次的添加导致底层elementData数组容量不够，则扩容。 默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。 结论：建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity); jdk8中ArrayList的变化: ArrayList list = new ArrayList();//底层Object[] elementData初始化为{}，并没有创建长度为10的数组 list.add(123);// 第一次调用add()时，底层才创建了长度为10的数组，并将数组123添加到elementData中 … 后续的添加和扩容操作与jdk7无异。 小结：jdk7中的ArrayList的对象的创建类似于单例的饿汉式，而jdk8中的ArrayList的对象的创建类似于单例的懒汉式，延迟了数组的创建，节省内存。 LinkedList LinkedList list = new LinkedList();//内部声明了Node类型的first和last属性，默认为null list.add(123);//将123封装到Node中，创建了Node对象 其中，Node中的next和prev指针，体现了LinkedList的双向链表的说法 Vector jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。在扩容方面，默认扩容为原来数组长度的2倍 7.4.3 List常用方法 void add(int index, Object ele): 在index位置插入ele元素 boolean addAll(int index, Collection eles): 从index位置开始将eles中的所有元素添加进来 Object get(int index): 获取指定index位置的元素 int indexOf(Object obj): 返回obj在集合中首次出现的位置 int lastIndexOf(Object obj): 返回obj在当前集合中末次出现的位置 Object remove(int index): 移除指定index位置的元素，并返回此元素 Object set(int index, Object ele): 设置指定index位置的元素为ele List subList(int fromIndex, int toIndex): 返回从fromIndex到toIndex位置的子集合 总结：常用方法 增：add(Object) 删：remove(int index) / remove(Object obj) 改：set(int index, Object ele) 查：get(int index) 插：add(int index, Object ele) 长度：size() 遍历：1.Iterator迭代器， 2.增强for循环, 3.普通的循环 public class ListTest { @Test public void test1() { ArrayList list = new ArrayList(); list.add(123); list.add(456); list.add(\"AA\"); list.add(new Person(\"Tom\", 12)); list.add(456); System.out.println(list); list.add(1, \"BB\"); System.out.println(list); List list1 = Arrays.asList(1,2,3); list.addAll(list1); System.out.println(list.size()); System.out.println(list.get(0)); } @Test public void test2() { ArrayList list = new ArrayList(); list.add(123); list.add(456); list.add(\"AA\"); list.add(new Person(\"Tom\", 12)); list.add(456); System.out.println(list.indexOf(456)); System.out.println(list.indexOf(789)); System.out.println(list.lastIndexOf(456)); Object obj = list.remove(0); System.out.println(obj); list.set(1, \"CC\"); System.out.println(list); System.out.println(list.subList(2, 4)); } @Test public void test3() { ArrayList list = new ArrayList(); list.add(123); list.add(456); list.add(\"AA\"); Iterator iterator = list.iterator(); while (iterator.hasNext()) { System.out.println(iterator.next()); } System.out.println(\"*************\"); for (Object obj : list) { System.out.println(obj); } System.out.println(\"*************\"); for (int i = 0; i \u003c list.size(); i++) { System.out.println(list.get(i)); } } @Test public void test4() { // 区分List中remove(int index) 和 remove(Object obj) List list = new ArrayList(); list.add(1); list.add(2); list.add(3); System.out.println(list); list.remove(2); System.out.println(list); list.remove(new Integer(1)); System.out.println(list); } } ","date":"2021-04-19","objectID":"/java-shk-8/:7:4","tags":["Java"],"title":"Java零基础教程（八.常用类）","uri":"/java-shk-8/"},{"categories":null,"content":"7.5 Collection子接口二：Set 7.5.1 Set接口的框架 |----Collection接口：单列集合，用来存储一个一个的对象 |----Set接口：存储无序的，不可重复的数据（高中讲的集合） |----HashSet：作为Set接口的主要实现类：线程不安全的：可以存储null值 |----LinkedHashSet：作为HashSet的子类：遍历其内部数据时，可以按照添加顺序遍历 对于频繁的遍历操作，LinkedHashSet效率高于HashSet |----TreeSet：可以按照添加对象的指定属性，进行排序 HashSet: 作为Set接口的主要实现类：线程不安全的；可以存储null值 LinkedHashSet: 作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历 TreeSet: 可以按照添加对象的指定属性，进行排序。 Set接口中没有额外定义新的方法，使用的都是collection中声明过的方法。 要求：向Set中添加的数据，其所在的类一定要重写hashCode()和equals() 要求：重写的hashCode()和equals()尽可能保持一致性：相等的对象必须具有相等的散列码 重写两个方法的小技巧：对象中用作equals()方法比较的field，都应该用来计算hashCode值 7.5.2 理解 Set：无序，不可重复 (以HashSet为例说明) 无序性：不等于随机性。存储的数据在底层数组中并非按照索引的顺序添加，而是根据数据的哈希值决定 不可重复性：保证添加的元素按照equals()判断时，不能返回true。即：相同的元素只能添加一次 添加元素的过程：(以HashSet为例) 我们向HashSet中添加元素a，首先调用元素a所在类的hashCode()方法，计算元素a的哈希值，此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置(即：索引位置)，判断数组此位置上是否已经有元素： 如果此位置上没有其他元素，则元素a添加成功。—情况1 如果此位置上有其他元素b（或以链表形式存在的多个元素），则比较元素a与元素b的hash值， 如果hash值不相同，则元素a添加成功。—情况2 如果hash值相同，进而需要调用元素a所在类的equals()方法： equals()返回true，元素a添加失败 equals()返回false，则元素a添加成功。—情况3 对于添加成功的情况2和情况3而言：元素a与已经存在指定索引位置上的数据以链表的方式存储。jdk7：元素a放到数组中，指向原来的元素。jdk8：原来的元素在数组中，指向元素a。总结：七上八下 HashSet底层：数组+链表的结构。 package com.atguigu.java1; import com.atguigu.java.Person; import org.junit.Test; import java.util.HashSet; import java.util.Iterator; import java.util.LinkedHashSet; import java.util.Set; public class SetTest { @Test public void test1() { Set set = new HashSet(); set.add(456); set.add(123); set.add(\"AA\"); set.add(\"CC\"); set.add(new Person(\"Tom\", 12)); set.add(129); Iterator iterator = set.iterator(); while (iterator.hasNext()) { System.out.println(iterator.next()); } } // LinkedHashSet的使用 // LinkedHashSet作为HashSet的子类，在添加数据的同时，每个数据还维护了两个引用，记录此数据 // 和有一个数据。 // 优点：对于频繁的遍历操作，效率高于HashSet @Test public void test2() { Set set = new LinkedHashSet(); set.add(456); set.add(123); set.add(\"AA\"); set.add(\"CC\"); set.add(new Person(\"Tom\", 12)); set.add(129); Iterator iterator = set.iterator(); while (iterator.hasNext()) { System.out.println(iterator.next()); } } } 7.5.3 TreeMap 向TreeSet中添加的数据，要求是相同类的对象 两种排序方式，自然排序（实现Comparable接口） 和 定制排序（Comparator） 自然排序中，比较两个对象是否相同的标准为：compareTo()返回0，不再是equals()；底层是通过compareTo存入二叉树，如果compareTo相等，则被看作重复元素，不予添加 定制排序中，比较两个对象是否相同的标准为：compare()返回0，不再是equals() package com.atguigu.java1; import org.junit.Test; import java.util.Comparator; import java.util.Iterator; import java.util.TreeSet; public class TreeSetTest { @Test public void test1() { // TreeSet set = new TreeSet(); // set.add(123); // set.add(12); // set.add(-34); // set.add(0); // Iterator iterator = set.iterator(); // while (iterator.hasNext()) { // System.out.println(iterator.next()); // } // -34 // 0 // 12 // 123 TreeSet set = new TreeSet(); set.add(new User(\"Tom\", 12)); set.add(new User(\"Jerry\", 32)); set.add(new User(\"Jim\", 2)); set.add(new User(\"Mike\", 65)); set.add(new User(\"Jack\", 33)); Iterator iterator = set.iterator(); while (iterator.hasNext()) { System.out.println(iterator.next()); } } @Test public void test2() { Comparator com = new Comparator() { // 按照年龄从小到大排列 @Override public int compare(Object o1, Object o2) { if (o1 instanceof User \u0026\u0026 o2 instanceof User) { User u1 = (User)o1; User u2 = (User)o2; return Integer.compare(u1.getAge(), u2.getAge()); } else { throw new RuntimeException(\"输入的数据类型不匹配\"); } } }; TreeSet set = new TreeSet(com); set.add(new User(\"Tom\", 12)); set.add(new User(\"Jerry\", 32)); set.add(new User(\"Jim\", 2)); set.add(new User(\"Mike\", 65)); set.add(new User(\"Jack\", 33)); Iterator iterator = set.iterator(); while (iterator.hasNext()) { System.out.println(iterator.next()); } // User{name='Jim', age=2} // User{name='Tom', age=12} // User{name='Jerry', age=32} // User{name='Jack', age=33} // User{name='Mike', age=65} } } 关于Set的一个总结问题： 集合Collection中存储的如果是自定义的对象，需要自定义类重写哪个方法？为什么？ List：equals() Set: HashSet, LinkedHashSet: equals(), hashCode() TreeSet: Comparable: compareTo(Object obj) Comparator: compare(Object o1, Object o2) ","date":"2021-04-19","objectID":"/java-shk-8/:7:5","tags":["Java"],"title":"Java零基础教程（八.常用类）","uri":"/java-shk-8/"},{"categories":null,"content":"7.6 Map接口 7.6.1 Map实现类的结构 |----Map:双列数据，存储key-value对的数据 （类似于高中的函数） |----HashMap: 作为Map的主要实现类：线程不安全的，效率高；存储null的key和value |----LinkedHashMap:保证在遍历map元素时，可以按照添加的顺序实现遍历。 原理：在原有的HashMap底层结构基础上，添加了一对儿指针，指向前一个和后一个 对于频繁的遍历操作，此类执行效率高于HashMap |----TreeMap: 保证按照添加到key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序 底层使用红黑树 |----Hashtable: 作为古老的实现类：线程安全的，效率低；不能存储null的key和value |----Properties：常用来处理配置文件。key和value都是String类型 HashMap的底层：数组 + 链表（jdk7及以前）;数组 + 链表 + 红黑树（jdk8） 面试题： HashMap的底层实现原理 HashMap和Hashtable的异同？ CurrentHashMap与Hashtable的异同？（暂时不讲） 7.6.2 Map结构的理解 Map中的key，无序的，不可重复的，使用Set存储所有的key —\u003ekey所在的类要重写equals()和hashCode()(以HashMap为例) Map中的value：无序的，可重复的，使用collection存储所有的value —\u003evalue所在的类要重写equals()(Collection要求) 一个键值对：key-value构成了一个Entry对象。 Map中的entry：无序的，不可重复的，使用Set存储所有的entry 7.6.3 HashMap的底层实现原理，以jdk7说明： HashMap map = new HashMap(); 在实例化以后，底层创建了长度是16的一维数组Entry[] table ...可能已经执行过多次put... map.put(key1, value1); 首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置。 如果此位置上的数据为空，此时的key1-value1添加成功。 —-情况1 如果此位置上的数据不为空，（意味着此位置上存在一个或多个数据，以链表形式存在），比较key1和已经存在的一个或多个数据的哈希值： 如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功 —-情况2 如果key1的哈希值与已经存在的某一个数据（key2-value2）的哈希值相同，继续比较：调用key1所在类的equals(key2)方法，比较： 如果equals()返回false：此时key1-value1添加成功 —-情况3 如果equals()返回true：使用value1替换value2。 补充：关于情况2和情况3：此时key1-value1和原来的数据以链表的方式存储 在不断地添加过程中，会涉及到扩容问题，默认的扩容方式：扩容为原来容量的2倍，并将原有的数据复制过来。 jdk8相较于jdk7在底层实现方面的不同： new HashMap():底层没有创建一个长度为16的数组 jdk8底层的数组是：Node[], 而非Entry[] 首次调用put()方法时，底层创建长度为16的数组 jdk7底层结构只有：数组 + 链表。 jdk8中底层结构：数组 + 链表 + 红黑树 当数组的某一个索引位置上的元素以链表形式存在的数据个数 \u003e 8且当前数组的长度 \u003e 64时，此时此索引位置上的所有数据改为使用红黑树搜索。 7.6.4 LinkedHashMap的底层实现原理（了解） static class Entry\u003cK,V\u003e extends HashMap.Node\u003cK,V\u003e { Entry\u003cK,V\u003e before, after; Entry(int hash, K key, V value, Node\u003cK,V\u003e next) { super(hash, key, value, next); } } 7.6.5 Map接口中定义的方法 Object put (Object key, Object value): 将指定key-value添加到（或修改）当前map对象中 void putAll(Map m): 将m中的所有key-value对存放到当前map中 Object remove(Object key):移除指定key的key-value对，并返回value void clear():清空当前map中的所有数据 Object get(Object key):获取指定key对应的value boolean containsKey(Object key):是否包含指定的key boolean containsValue(Object value):是否包含指定的value int size():返回map中key-value对的个数 boolean isEmpty():判断当前map是否为空 boolean equals(Object obj):判断当前map和参数对象obj是否相等 Set keySet():返回所有key构成的Set集合 Collection values():返回所有value构成的Collection集合 Set entrySet():返回所有key-value对构成的Set集合 总结：常用方法 增：put (Object key, Object value) 删：remove(Object key) 改：put (Object key, Object value) 查：get(Object key) 插：无序 长度：size() 遍历：keySet()，values()，entrySet() package com.atguigu.java; import org.junit.Test; import java.util.*; public class MapTest { @Test public void test1() { Map map = new HashMap(); map.put(123, \"AA\"); map.put(345, \"BB\"); map.put(12, \"CC\"); System.out.println(map); } @Test public void test2() { Map map = new HashMap(); map.put(\"AA\", 123); map.put(45, 123); map.put(\"BB\", 123); map.put(\"AA\", 789); System.out.println(map); Map map2 = new HashMap(); map2.put(\"CC\", 123); map2.put(\"DD\", 345); map2.putAll(map); System.out.println(map2); Object value = map2.remove(\"CC\"); System.out.println(map2); map.clear();//与 map = null不同 System.out.println(map.size()); // 0 } @Test public void test3() { Map map = new HashMap(); map.put(\"AA\", 123); map.put(45, 123); map.put(\"BB\", 56); System.out.println(map.get(45)); System.out.println(map.containsKey(\"BB\")); System.out.println(map.containsValue(123)); map.clear(); System.out.println(map.isEmpty()); } @Test public void test4() { Map map = new HashMap(); map.put(\"AA\", 123); map.put(45, 123); map.put(\"BB\", 56); // 遍历所有的key集：keySet() Set set = map.keySet(); Iterator iterator = set.iterator(); while (iterator.hasNext()) { System.out.println(iterator.next()); } // 遍历所有的value集：values() Collection values = map.values(); for (Object obj: values) { System.out.println(obj); } // 遍历所有key-value：entrySet() Set entrySet = map.entrySet(); Iterator iterator1 = entrySet.iterator(); while (iterator1.hasNext()) { Object obj = iterator1.next(); Map.Entry entry = (Map.Entry) obj; System.out.print","date":"2021-04-19","objectID":"/java-shk-8/:7:6","tags":["Java"],"title":"Java零基础教程（八.常用类）","uri":"/java-shk-8/"},{"categories":null,"content":"7.7 Collections工具类 Collections:操作Collection，Map的工具类 面试题：Collection与Collections的区别？ reverse(List):反转List中元素的顺序 shuffle(List):对List集合元素进行随机排序 sort(List):根据元素的自然顺序对指定List集合元素按升序排序 sort(List, Comparator):根据指定的Comparator产生的顺序对List集合元素进行排序 swap(List, int, int):将指定list集合中i处元素和j处元素进行交换 Object max(Collection):根据元素的自然顺序，返回给定集合中的最大元素 Object max(Collection, Comparator):根据Comparator指定的顺序，返回给定集合中的最大元素 Object min(Collection): Object min(Collection, Comparator): int frequency(Collection, Object):返回指定集合中指定元素的出现次数 void copy(List dest, List src):将src中的内容复制到dest中 boolean replaceAll(List list, Object oldVal, Object newVal):使用新值替换List Collections类中提供了多个synchronizedXxx()方法，该方法可使将指定集合，从而可以解决多线程并发访问集合时的线程安全问题 ","date":"2021-04-19","objectID":"/java-shk-8/:7:7","tags":["Java"],"title":"Java零基础教程（八.常用类）","uri":"/java-shk-8/"},{"categories":null,"content":"8. 其他常用类 System类，Math类，BigInteger与BigDecimal类 ","date":"2021-04-19","objectID":"/java-shk-8/:8:0","tags":["Java"],"title":"Java零基础教程（八.常用类）","uri":"/java-shk-8/"},{"categories":null,"content":"1. 基本概念理解 ","date":"2021-04-16","objectID":"/java-shk-7/:1:0","tags":["Java"],"title":"Java零基础教程（七.多线程）","uri":"/java-shk-7/"},{"categories":null,"content":"1.1 程序 vs 进程 vs 线程 程序（program）是为完成特定任务，用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。 进程（process）是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程：有它自身的产生，存在和消亡的过程。 - 生命周期 如：运行中的QQ，运行中的MP3播放器 程序是静态的，进程是动态的 进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域。 再比如一个运行中的杀毒软件（进程），其中清理文件，查杀木马的运行分别对应一个线程。 线程（thread），进程可进一步细化为线程，是一个程序内部的一条执行路径。 若一个进程同一时间并行执行多个线程，就是支持多线程的 线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)，线程切换的开销小。 一个进程中的多个线程共享相同的内存单元/内存地址空间，他们从同一堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便，高效。但多个线程操作共享的系统资源可能就会带来安全的隐患。 ","date":"2021-04-16","objectID":"/java-shk-7/:1:1","tags":["Java"],"title":"Java零基础教程（七.多线程）","uri":"/java-shk-7/"},{"categories":null,"content":"1.2 单核CPU vs. 多核CPU 单核CPU，其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。例如：虽然有多车道，但是收费站只有一个工作人员在收费，只有收了费才能通过，那么CPU就好比收费人员。如果有某个人不想交钱，那么收费人员可以把他“挂起”（晾着他，等他想通了，准备好了钱，再去收费）。但是因为CPU时间单元特别短，因此感觉不出来。 如果是多核的话，才能更好的发挥多线程的效率。（现在的服务器都是多核的） 一个Java应用程序java.exe，其实至少有三个线程：main()主线程，gc()垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程。 ","date":"2021-04-16","objectID":"/java-shk-7/:1:2","tags":["Java"],"title":"Java零基础教程（七.多线程）","uri":"/java-shk-7/"},{"categories":null,"content":"1.3 并行与并发 并行：多个CPU同时执行多个任务。比如：多个人同时做不同的事。 并发：一个CPU（采用时间片）同时执行多个任务。比如：秒杀，多个人做同一件事。（Quicksilver changes F1 tires?） ","date":"2021-04-16","objectID":"/java-shk-7/:1:3","tags":["Java"],"title":"Java零基础教程（七.多线程）","uri":"/java-shk-7/"},{"categories":null,"content":"1.4 多线程的优点 背景：以单核CPU为例，只使用单核线程先后完成多个任务（调用多个方法），肯定比用多个线程来完成用的时间更短，为何仍需多线程呢？ 多线程程序的优点： 提高应用程序的响应。对图形化界面更有意义，可增强用户体验。 提高计算机系统CPU的利用率 改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改。 何时需要多线程 程序需要同时执行两个或多个任务 程序需要实现一些需要等待的任务时，如用户输入，文件读写操作，网络操作，搜索等。 需要一些后台运行的程序时。 ","date":"2021-04-16","objectID":"/java-shk-7/:1:4","tags":["Java"],"title":"Java零基础教程（七.多线程）","uri":"/java-shk-7/"},{"categories":null,"content":"2. 线程的创建和使用 ","date":"2021-04-16","objectID":"/java-shk-7/:2:0","tags":["Java"],"title":"Java零基础教程（七.多线程）","uri":"/java-shk-7/"},{"categories":null,"content":"2.1 多线程的创建方式一：继承Thread类 创建一个继承于Thread类的子类 重写Thread类的run() -\u003e 将此线程执行的操作声明在run()中 创建Thread类的子类的对象 通过此对象调用start() package com.atguigu.java; /* 例子：遍历100以内的所有偶数 */ // 1. 创建一个继承于Thread类的子类 class MyThread extends Thread { // 2. 重写Thread类的run() @Override public void run() { for (int i = 0; i \u003c 10; i++) { if (i % 2 == 0) { System.out.println(Thread.currentThread().getName() + \":\" + i); } } } } public class ThreadTest { public static void main(String[] args) { // 3. 创建Thread类的子类的对象 MyThread t1 = new MyThread(); // 4. 通过此对象调用start(): 1）启动当前线程 2）调用当前线程的run() t1.start(); // 问题一：我们不能通过直接调用run()的方式启动线程。 // t1.run(); // 问题二：再启动一个线程，遍历。不可以还让已经start()的线程去执行。会报IllegalThreadStateException // t1.start(); // 我们需要重新创建一个线程的对象 MyThread t2 = new MyThread(); t2.start(); // 如下操作仍然是在main线程中执行的。 System.out.println(Thread.currentThread().getName()); } } 匿名子类的方式 package com.atguigu.exer; public class ThreadDemo { public static void main(String[] args) { // 创建Thread类的匿名子类的方式 new Thread(){ @Override public void run() { for (int i = 0; i \u003c 10; i++) { if (i % 2 == 0) { System.out.println(Thread.currentThread().getName() + \":\" + i); } } } }.start(); new Thread(){ @Override public void run() { for (int i = 0; i \u003c 10; i++) { if (i % 2 == 1) { System.out.println(Thread.currentThread().getName() + \":\" + i); } } } }.start(); } } ","date":"2021-04-16","objectID":"/java-shk-7/:2:1","tags":["Java"],"title":"Java零基础教程（七.多线程）","uri":"/java-shk-7/"},{"categories":null,"content":"2.2 Thread类中常用的方法 测试Thread中常用方法 start()：启动当前线程；调用当前线程的run() run()：通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中 currentThread()：静态方法，返回执行当前代码的线程 getName()：获取当前线程的名字 setName()：设置当前线程的名字 yield()：释放当前CPU的执行权 join()：在线程a中调用线程b的join(),此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才结束阻塞状态。 stop()：已过时。当执行此方法时，强制结束此线程 sleep(long millitime)：让当前线程\"睡眠\"指定的毫秒。在指定的毫秒时间内，当前的线程是阻塞状态。 isAlive()：判断当前线程是否存活 线程的优先级 MAX_PRIORITY: 10; MIN_PRIORITY: 1; NORM_PRIORITY: 5 如何获取和设置当前线程的优先级： getPriority(): 获取当前线程的优先级 setPriority(int p): 设置线程的优先级 说明： 高优先级的线程抢占低优先级线程CPU的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下被执行。并不意味着只有当高优先级的线程执行完以后，低优先级的线程才执行。 package com.atguigu.java; public class ThreadMethodTest { public static void main(String[] args) { HelloThread h1 = new HelloThread(\"Thread h1\"); // h1.setName(\"线程一\"); // 设置分线程的优先级 // h1.setPriority(Thread.MAX_PRIORITY); h1.start(); // 给主线程命名 Thread.currentThread().setName(\"主线程\"); // Thread.currentThread().setPriority(Thread.MIN_PRIORITY); for (int i = 0; i \u003c 10; i++) { if (i % 2 == 1) { System.out.println(Thread.currentThread().getName() + \": \" + Thread.currentThread().getPriority() + \": \"+ i); } if (i == 5) { try { h1.join(); } catch (InterruptedException e) { e.printStackTrace(); } } } System.out.println(h1.isAlive()); } } class HelloThread extends Thread { public HelloThread(String name) { super(name); } @Override public void run() { for (int i = 0; i \u003c 10; i++) { if (i % 2 == 0) { try { sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \": \" + Thread.currentThread().getPriority() + \": \"+ i); } // if (i % 20 == 0) { // yield(); // } } } } 例子：用此方式（继承Thread）处理共享数据 package com.atguigu.java; /* 例子： 创建三个窗口卖票，总票数为100张，使用继承Thread类的方式 存在线程安全问题，待解决... */ class Window extends Thread { private static int ticket = 100; @Override public void run() { while (true) { if (ticket \u003e 0) { System.out.println(getName() + \"卖票， 票号为：\" + ticket); ticket--; } else { break; } } } } public class WindowTest { public static void main(String[] args) { Window t1 = new Window(); Window t2 = new Window(); Window t3 = new Window(); t1.setName(\"窗口1\"); t2.setName(\"窗口2\"); t3.setName(\"窗口3\"); t1.start(); t2.start(); t3.start(); } } ","date":"2021-04-16","objectID":"/java-shk-7/:2:2","tags":["Java"],"title":"Java零基础教程（七.多线程）","uri":"/java-shk-7/"},{"categories":null,"content":"2.3 多线程的创建方式二：实现Runnable 创建多线程的方式二：实现Runnable接口 创建一个实现Runnable接口的类 实现类去实现Runnable中的抽象方法：run() 创建实现类的对象 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象 通过Thread类的对象调用start() 比较创建线程的两种方式： 开发中，优先选择实现Runnable接口的方式, 原因： 实现的方式没有类的单继承的局限性 实现的方式更适合来处理多个线程有共享数据的情况 联系： public class Thread implements Runnable 相同点：两种方式都需要重写run()，将线程要执行的逻辑声明在run()中。 package com.atguigu.java; // 1. 创建一个实现Runnable接口的类 class MThread implements Runnable { // 2. 实现类去实现Runnable中的抽象方法：run() @Override public void run() { for (int i = 0; i \u003c 10; i++) { if (i % 2 == 0) { System.out.println(Thread.currentThread().getName() + \": \" + i); } } } } public class ThreadTest1 { public static void main(String[] args) { // 3. 创建实现类的对象 MThread mThread = new MThread(); // 4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象 Thread t1 = new Thread(mThread); t1.setName(\"线程1\"); // 5. 通过Thread类的对象调用start(): 1)启动线程 2)调用当前线程的run() -\u003e 调用了Runnable类型的target t1.start(); // 再启动一个线程 Thread t2 = new Thread(mThread); t2.setName(\"线程2\"); t2.start(); } } 两种方式的对比 package com.atguigu.java; /* 例子： 创建三个窗口卖票，总票数为100张，使用实现Runnable接口的方式 */ class Window1 implements Runnable { // 不需要static：因为堆空间中只创建了一个对象，多个线程共享同一个对象 private int ticket = 100; @Override public void run() { while (true) { if (ticket \u003e 0) { System.out.println(Thread.currentThread().getName() + \"卖票，票号为：\" + ticket); ticket--; } else { break; } } } } public class WindowTest1 { public static void main(String[] args) { Window1 w = new Window1(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName(\"窗口1\"); t2.setName(\"窗口2\"); t3.setName(\"窗口3\"); t1.start(); t2.start(); t3.start(); } } ","date":"2021-04-16","objectID":"/java-shk-7/:2:3","tags":["Java"],"title":"Java零基础教程（七.多线程）","uri":"/java-shk-7/"},{"categories":null,"content":"3. 线程的生命周期 区分“阻塞”状态与“就绪”状态（yield）：阻塞是指CPU想执行也执行不了的状态。 ","date":"2021-04-16","objectID":"/java-shk-7/:3:0","tags":["Java"],"title":"Java零基础教程（七.多线程）","uri":"/java-shk-7/"},{"categories":null,"content":"4. 线程的同步 ","date":"2021-04-16","objectID":"/java-shk-7/:4:0","tags":["Java"],"title":"Java零基础教程（七.多线程）","uri":"/java-shk-7/"},{"categories":null,"content":"4.1 Java的同步机制 例子：创建三个窗口卖票，总票数100张，使用实现Runnable接口的方式 问题：卖票过程中，出现了重票和错票 -\u003e 出现了线程的安全问题 问题出现的原因：当某个线程操作车票的过程中，尚未操作完成时，其他线程参与进来，也操作车票。 如何解决：当一个线程在操作ticket的时候，其他线程不能参与进来。直到线程a操作完ticket时，其他线程才可以开始操作ticket。这种情况即使线程a出现了阻塞，也不能被改变。 在Java中，我们通过同步机制，来解决线程的安全问题。 方式一：同步代码块 synchronized(同步监视器) { // 需要被同步的代码 } 说明： 操作共享数据的代码，即为需要被同步的代码 – 不能包含代码多了，也不能包含代码少了 共享数据：多个线程共同操作的变量。比如：ticket就是共享数据。 同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。锁的要求：多个线程必须要共用同一把锁。 补充：在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器 方式二：同步方法 如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。 同步的方式，解决了线程的安全问题。– 好处 操作同步代码时，只能有一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低。 – 坏处 对于两种线程创建方式（继承Thread类，实现Runnable接口），各有两种解决线程安全的方案，即同步代码块和同步方法。四种情况组合如下： 同步代码块，Runnable package com.atguigu.java; /* */ class Window1 implements Runnable { private int ticket = 100; Object obj = new Object(); @Override public void run() { // Object obj = new Object(); // 线程还是不安全，这里没有共用一把锁 while (true) { synchronized (this) {// 此时的this：唯一的Window1的对象 // synchronized (obj) {// 正确 if (ticket \u003e 0) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \"卖票，票号：\" + ticket); ticket--; } else { break; } } } } } public class WindowTest1 { public static void main(String[] args) { Window1 w = new Window1(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName(\"窗口1\"); t2.setName(\"窗口2\"); t3.setName(\"窗口3\"); t1.start(); t2.start(); t3.start(); } } 同步代码块，继承Thread package com.atguigu.java; /* 使用同步代码块解决继承Thread类的方式的线程安全问题 例子：创建三个窗口卖票，总票数100张，使用继承Thread类的方式 说明：在继承Thread类创建多线程的方式中，慎用this充当同步监视器，考虑使用当前类充当同步监视器。 */ class Window2 extends Thread { private static int ticket = 100; // 注意static锁 private static Object obj = new Object(); @Override public void run() { while (true) { // synchronized (obj) { // synchronized (this) {// 错误，this代表着t1,t2,t3三个对象 synchronized (Window2.class) {// Class clazz = Window2.class, Window2.class只会加载一次 if (ticket \u003e 0) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(getName() + \"卖票，票号：\" + ticket); ticket--; } else { break; } } } } } public class WindowTest2 { public static void main(String[] args) { Window2 t1 = new Window2(); Window2 t2 = new Window2(); Window2 t3 = new Window2(); t1.setName(\"窗口1\"); t2.setName(\"窗口2\"); t3.setName(\"窗口3\"); t1.start(); t2.start(); t3.start(); } } 同步方法，实现Runnable package com.atguigu.java; /* 使用同步方法解决实现Runnable接口的线程安全问题 关于同步方法的总结： 1。 同步方法仍然涉及到同步监视器，只是不需要我们显式地声明。 2。 非静态的同步方法，同步监视器是：this 3。 静态的同步方法，同步监视器是：当前类本身 */ class Window3 implements Runnable { private int ticket = 100; @Override public void run() { while (true) { show(); } } private synchronized void show() { // 同步监视器：this if (ticket \u003e 0) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \"卖票，票号：\" + ticket); ticket--; } } } public class WindowTest3 { public static void main(String[] args) { Window3 w = new Window3(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName(\"窗口1\"); t2.setName(\"窗口2\"); t3.setName(\"窗口3\"); t1.start(); t2.start(); t3.start(); } } 同步方法，继承Thread package com.atguigu.java; class Window4 extends Thread { private static int ticket = 100; @Override public void run() { while (true) { show(); } } private static synchronized void show() { // 正确，static共享锁，同步监视器：Windows4.class // private synchronized void show() { // 错误，同步监视器：t1,t2,t3 if (ticket \u003e 0) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \"卖票，票号：\" + ticket); ticket--; } } } public class WindowTest4 { public static void main(String[] args) { Window4 t1 = new Window4(); Window4 t2 = new Window4(); Window4 t3 = new Window4(); t1.setName(\"窗口1\"); t2.setName(\"窗口2\"); t3.setName(\"窗口3\"); t1.start(); t2.start(); t3.start(); } } ","date":"2021-04-16","objectID":"/java-shk-7/:4:1","tags":["Java"],"title":"Java零基础教程（七.多线程）","uri":"/java-shk-7/"},{"categories":null,"content":"4.2 懒汉式同步机制回顾 package com.atguigu.java1; /* 使用同步机制将单例模式中的懒汉式改写为线程安全的 */ public class BankTest { } class Bank { private Bank(){} private static Bank instance = null; public static Bank getInstance() { // 方式一：效率稍差 // synchronized (Bank.class) { // if (instance == null) { // instance = new Bank(); // return instance; // } // } // 方式二：效率更高 if (instance == null) { synchronized (Bank.class) { if (instance == null) { instance = new Bank(); } } } return instance; } } ","date":"2021-04-16","objectID":"/java-shk-7/:4:2","tags":["Java"],"title":"Java零基础教程（七.多线程）","uri":"/java-shk-7/"},{"categories":null,"content":"4.3 死锁问题 不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁。（例子：两人吃饭，一人拿一根筷子） 演示线程的死锁问题 死锁的理解：不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁。 说明： 出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续 我们使用同步时，要避免出现死锁。 解决方法： 专门的算法，原则 尽量减少同步资源的定义 尽量避免嵌套同步 package com.atguigu.java1; public class ThreadTest { public static void main(String[] args) { StringBuffer s1 = new StringBuffer(); StringBuffer s2 = new StringBuffer(); new Thread(){ @Override public void run() { synchronized (s1) { s1.append(\"a\"); s2.append(\"1\"); try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (s2) { s1.append(\"b\"); s2.append(\"2\"); System.out.println(s1); System.out.println(s2); } } } }.start(); new Thread(new Runnable() { @Override public void run() { synchronized (s2) { s1.append(\"c\"); s2.append(\"3\"); try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (s1) { s1.append(\"d\"); s2.append(\"4\"); System.out.println(s1); System.out.println(s2); } } } }).start(); } } ","date":"2021-04-16","objectID":"/java-shk-7/:4:3","tags":["Java"],"title":"Java零基础教程（七.多线程）","uri":"/java-shk-7/"},{"categories":null,"content":"4.4 第三种同步机制（JDK5.0新增）- Lock 解决线程安全问题的方式三：Lock锁 — JDK5.0新增 面试题：synchronized 与 Lock的异同？ 同：二者都可以解决线程安全问题 不同：synchronized机制在执行完相应的同步代码以后，自动地释放同步监视器 Lock需要手动地启动同步lock(),同时结束同步也需要手动地实现unlock() 优先使用顺序：Lock -\u003e 同步代码块（已经进入了方法体，分配了相应资源） -\u003e 同步方法（在方法体之外） 面试题：如何解决线程安全问题？有几种方式？synchronized， Lock package com.atguigu.java1; import java.util.concurrent.locks.ReentrantLock; class Window implements Runnable { private int ticket = 100; // 1. 实例化ReentrantLock private ReentrantLock lock = new ReentrantLock(); @Override public void run() { while (true) { try { // 2. 调用锁定方法lock()方法 lock.lock(); if (ticket \u003e 0) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \"售票，票号：\" + ticket); ticket--; } else { break; } } catch (Exception e) { e.printStackTrace(); } finally { // 3. 调用解锁方法：unlock() lock.unlock(); } } } } public class LockTest { public static void main(String[] args) { Window w = new Window(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.start(); t2.start(); t3.start(); } } 一道练习 package com.atguigu.exer; class Account { private double balance; public Account(double balance) { this.balance = balance; } public synchronized void deposit(double amt) { if (amt \u003e 0) { balance += amt; try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \"存钱成功，余额：\" + balance); } } } class Customer extends Thread { private Account acct; @Override public void run() { for (int i = 0; i \u003c 3; i++) { acct.deposit(1000); } } public Customer(Account acct) { this.acct = acct; } } public class AccountTest { public static void main(String[] args) { Account acct = new Account(0); Customer c1 = new Customer(acct); Customer c2 = new Customer(acct); c1.setName(\"c1\"); c2.setName(\"c2\"); c1.start(); c2.start(); } } ","date":"2021-04-16","objectID":"/java-shk-7/:4:4","tags":["Java"],"title":"Java零基础教程（七.多线程）","uri":"/java-shk-7/"},{"categories":null,"content":"5. 线程的通信 线程通信的例子：使用两个线程打印1-100。线程1，线程2交替打印 涉及到的三个方法： wait()：一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器（锁） notify()：一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的线程 notifyAll()：一旦执行此方法，就会唤醒所有被wait的线程。 说明： wait(), notify(), notifyAll()三个方法必须使用在同步代码块或同步方法中。 wait(), notify(), notifyAll()三个方法的调用者必须是同步代码块或同步方法中的同步监视器。否则，会出现IllegalMonitorStateException异常 wait(), notify(), notifyAll()三个方法是定义在java.lang.Object类中 面试题：sleep()和wait()的异同？ 相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态 不同点 两个方法声明的位置不同：Thread类中声明sleep(), Object类中声明wait() 调用的要求不同：sleep()可以在任何需要的场景下调用。wait()必须使用在同步代码块或同步方法中 关于是否释放同步监视器（锁）：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。 package com.atguigu.java2; class Number implements Runnable { private int number = 1; private Object obj = new Object(); @Override public void run() { while (true) { synchronized (obj) { obj.notify(); if (number \u003c 100) { System.out.println(Thread.currentThread().getName() + \" : \" + number); number++; try { // 使得调用如下wait()方法的线程进入阻塞状态 obj.wait();// 会释放锁。作为对比，sleep不会释放锁 } catch (InterruptedException e) { e.printStackTrace(); } } else { break; } } } } } public class CommunicationTest { public static void main(String[] args) { Number number = new Number(); Thread t1 = new Thread(number); Thread t2 = new Thread(number); t1.setName(\"线程1\"); t2.setName(\"线程2\"); t1.start(); t2.start(); } } 看一道综合的例题：生产者/消费者问题 package com.atguigu.java2; /* 线程通信的应用：经典例题：生产者/消费者问题 生产者（Productor）将产品交给店员（Clerk），而消费者（Customer）从店员处取走产品，店员一次只能持有固定数量的产品（比如：20）， 如果生产者试图生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品了再通知生产者继续生产；如果店中没有产品了，店员会告诉 消费者等一下，如果店中有产品了再通知消费者来取走产品。 分析： 1. 是否有多线程问题？是，生产者线程，消费者线程 2. 是否有共享数据？是，店员（或产品） 3. 如何解决线程的安全问题？同步机制，有三种方法 4. 是否涉及到线程通信？是 */ class Clerk { private int productCount = 0; // 生产产品 public synchronized void produceProduct() { if (productCount \u003c 20) { productCount++; System.out.println(Thread.currentThread().getName() + \"开始生产第\" + productCount + \"个产品\"); notify(); } else { try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } // 消费产品 public synchronized void consumeProduct() { if (productCount \u003e 0) { System.out.println(Thread.currentThread().getName() + \"开始消费第\" + productCount + \"个产品\"); productCount--; notify(); } else { try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } } class Producer extends Thread { private Clerk clerk; public Producer(Clerk clerk) { this.clerk = clerk; } @Override public void run() { System.out.println(Thread.currentThread().getName() + \"开始生产产品...\"); while (true) { try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } clerk.produceProduct(); } } } class Consumer extends Thread { private Clerk clerk; public Consumer(Clerk clerk) { this.clerk = clerk; } @Override public void run() { System.out.println(Thread.currentThread().getName() + \"开始消费产品...\"); while (true) { try { Thread.sleep(20); } catch (InterruptedException e) { e.printStackTrace(); } clerk.consumeProduct(); } } } public class ProductTest { public static void main(String[] args) { Clerk clerk = new Clerk(); Producer p1 = new Producer(clerk); p1.setName(\"生产者1\"); Consumer c1 = new Consumer(clerk); c1.setName(\"消费者1\"); Consumer c2 = new Consumer(clerk); c2.setName(\"消费者2\"); p1.start(); c1.start(); c2.start(); } } ","date":"2021-04-16","objectID":"/java-shk-7/:5:0","tags":["Java"],"title":"Java零基础教程（七.多线程）","uri":"/java-shk-7/"},{"categories":null,"content":"6. JDK5.0新增线程创建方式 ","date":"2021-04-16","objectID":"/java-shk-7/:6:0","tags":["Java"],"title":"Java零基础教程（七.多线程）","uri":"/java-shk-7/"},{"categories":null,"content":"6.1 多线程的创建方式三：实现Callable接口（JDK5.0新增） 如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建线程方式强大？ call()可以有返回值的。 call()可以抛出异常，被外面的操作捕获，获取异常的信息 Callable是支持范型的 使用步骤： 创建一个实现Callable的实现类 实现call方法，将此线程需要执行的操作声明在call()中 创建Callable接口实现类的对象 将此Callable接口实现类的对象作为参数传递到FutureTask构造器中，创建FutureTask的对象 将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()。 (optional) 获取Callable中call方法的返回值 package com.atguigu.java2; import java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.FutureTask; class NumThread implements Callable { @Override public Object call() throws Exception { int sum = 0; for (int i = 1; i \u003c 100; i++) { if (i % 2 == 0) { System.out.println(i); sum += i; } } return sum; } } public class ThreadNew { public static void main(String[] args) { NumThread numThread = new NumThread(); FutureTask futureTask = new FutureTask(numThread); new Thread(futureTask).start(); try { // get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值 Object sum = futureTask.get(); System.out.println(\"总和为：\" + sum); } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } } } ","date":"2021-04-16","objectID":"/java-shk-7/:6:1","tags":["Java"],"title":"Java零基础教程（七.多线程）","uri":"/java-shk-7/"},{"categories":null,"content":"6.2 多线程的创建方式四：线程池 线程池 背景：经常创建和销毁使用量特别大的资源，比如并发情况下的线程，对性能影响很大。 思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁，实现重复利用。类似生活中的公共交通工具。 好处： 提高响应速度（减少了创建新线程的时间） 降低资源消耗（重复利用线程池中线程，不需要每次都创建） 便于线程管理 corePoolSize：核心池的大小 maximumPoolSize：最大线程数 keepAliveTime：线程没有任务时最多保持多长时间后会终止 开发中，一般都使用线程池的方式创建和管理线程 面试题：创建多线程有几种方式？四种！ package com.atguigu.java2; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; class NumberThread implements Runnable { @Override public void run() { for (int i = 0; i \u003c 100; i++) { if (i % 2 == 0) { System.out.println(Thread.currentThread().getName()+ \" : \" + i); } } } } class NumberThread1 implements Runnable { @Override public void run() { for (int i = 0; i \u003c 100; i++) { if (i % 2 != 0) { System.out.println(Thread.currentThread().getName() + \" : \" + i); } } } } public class ThreadPool { public static void main(String[] args) { // 1. 提供指定线程数量的线程池 // 2. 执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象 ExecutorService service = Executors.newFixedThreadPool(10); // 设置线程池的属性 System.out.println(service.getClass()); // ThreadPoolExecutor // ThreadPoolExecutor service1 = (ThreadPoolExecutor) service;// 向下转型 // service1.setCorePoolSize(15);// 线程池的管理 service.execute(new NumberThread());//适用于Runnable service.execute(new NumberThread1()); // service.submit(Callable callable);//适用于Callable // 3. 关闭线程池 service.shutdown(); } } ","date":"2021-04-16","objectID":"/java-shk-7/:6:2","tags":["Java"],"title":"Java零基础教程（七.多线程）","uri":"/java-shk-7/"},{"categories":null,"content":"1. static关键字 ","date":"2021-04-10","objectID":"/java-shk-6/:1:0","tags":["Java"],"title":"Java零基础教程（六.面向对象-重要补充）","uri":"/java-shk-6/"},{"categories":null,"content":"1.1 static关键字的使用 static: 静态 static可以用来修饰：属性，方法，代码块，内部类 使用static修饰属性: 静态变量（是属性，不是局部变量）或者叫类变量 属性，按是否使用static修饰，有分为静态属性 vs 非静态属性（实例变量） 实例变量：我们创建类类的多个对象，每个对象都独立的拥有一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值的修改。 静态变量：我们创建类类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的。 static修饰属性的其他说明： 静态变量随着类的加载而加载。可以通过“类.静态变量”的方式进行调用 静态变量的加载要早于对象的创建。 由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中。 调用 类变量 实例变量 类 yes no 对象 yes yes 静态属性举例： System.out; Math.PI; 使用static修饰方法: 静态方法 随着类的加载而加载，可以通过“类.静态方法”的方式进行调用 调用 静态方法 非静态方法 类 yes no 对象 yes yes 静态方法中，只能调用静态的方法或属性; 非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性 static注意点： 在静态的方法内，不能使用this关键字，super关键字 关于静态属性和静态方法的使用，大家都可以从生命周期的角度来理解 开发中，如何确定一个属性是否要声明为static的？ 属性是可以被多个对象所共享的，不会随着对象的不同而不同的。 类中的常量也常常声明为static，比如PI 开发中，如何确定一个方法是否要声明为static的？ 操作静态属性的方法，通常设置为static的 工具类中的方法，习惯上声明为static的。比如：Math，Arrays，Collections package com.atguigu.java1; public class StaticTest { public static void main(String[] args) { Chinese c1 = new Chinese(); c1.name = \"姚明\"; c1.age = 40; Chinese c2 = new Chinese(); c2.name = \"马龙\"; c2.age = 30; c1.nation = \"CHN\"; System.out.println(c2.nation); // 编译不通过 // Chinese.name = \"张继科\"; Chinese.show(); } } class Chinese { String name; int age; static String nation; public void eat() { System.out.println(\"Chinese eat\"); } public static void show() { System.out.println(\"I am Chinese\"); // 不能调用非静态结构 // eat(); // name = \"Tom\"; // 可以调用静态结构 System.out.println(nation); } } 再来看一个应用static的例子 package com.atguigu.java1; public class CircleTest { public static void main(String[] args) { Circle c1 = new Circle(); Circle c2 = new Circle(); System.out.println(\"c1 ID: \" + c1.getId()); System.out.println(\"c2 ID: \" + c2.getId()); System.out.println(\"total number of circles: \" + Circle.getTotal()); } } class Circle { private double radius; private int id; private static int total = 0; // 记录创建圆的个数 private static int init = 1001; // static声明的属性被所有对象所共享 public Circle() { id = init++; total++; } public Circle(double radius) { this(); this.radius = radius; } public double getRadius() { return radius; } public static int getTotal() { return total; } public void setRadius(double radius) { this.radius = radius; } public int getId() { return id; } public void setId(int id) { this.id = id; } public double findArea() { return 3.14 * radius * radius; } } ","date":"2021-04-10","objectID":"/java-shk-6/:1:1","tags":["Java"],"title":"Java零基础教程（六.面向对象-重要补充）","uri":"/java-shk-6/"},{"categories":null,"content":"1.2 static应用 - 单例模式（Singleton） 单例设计模式 所谓类的单例设计模式，就是采用一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例。 如何实现？饿汉式 vs 懒汉式 区分 饿汉式 和 懒汉式 饿汉式： 坏处：对象加载时间过长 好处：饿汉式是线程安全的 懒汉式： 好处：延迟对象的创建。 目前的写法坏处：线程不安全。 -\u003e 到多线程内容时，再修改 package com.atguigu.java2; public class SingletonTest1 { public static void main(String[] args) { // 饿汉式 Bank bank1 = Bank.getInstance(); Bank bank2 = Bank.getInstance(); System.out.println(bank1 == bank2); // 懒汉式 Order order1 = Order.getInstance(); Order order2 = Order.getInstance(); System.out.println(order1 == order2); } } class Bank { // 1. 私有化类的构造器 private Bank() { } // 2. 内部创建类的对象 // 4. 要求此对象也必须声明为静态的 private static Bank instance = new Bank(); // 3. 提供公共的静态的方法，返回类的对象 public static Bank getInstance() { return instance; } } class Order { // 1. 私有化构造器 private Order() { } // 2. 声明当前类对象，没有初始化 // 4. 此对象也必须声明为static的 private static Order instance = null; // 3. 声明public，static的返回当前类对象的方法 public static Order getInstance() { if (instance == null) { instance = new Order(); } return instance; } } ","date":"2021-04-10","objectID":"/java-shk-6/:1:2","tags":["Java"],"title":"Java零基础教程（六.面向对象-重要补充）","uri":"/java-shk-6/"},{"categories":null,"content":"2. main方法的回顾 main()方法的使用说明： main()方法作为程序的入口 main()方法也是一个普通的静态方法 main()方法可以作为我们与控制台交互的方式。（之前Scanner） package com.atguigu.java2; public class MainTest { public static void main(String[] args) { Main.main(new String[100]); for (int i = 0; i \u003c args.length; i++) { System.out.println(\"*****\" + args[i]);// run configuration int num = Integer.parseInt(args[i]); System.out.println(\"####\" + num); } } } class Main { public static void main(String[] args) { args = new String[100]; for (int i = 0; i \u003c args.length; i++) { args[i] = \"args_\" + i; System.out.println(args[i]); } } } ","date":"2021-04-10","objectID":"/java-shk-6/:2:0","tags":["Java"],"title":"Java零基础教程（六.面向对象-重要补充）","uri":"/java-shk-6/"},{"categories":null,"content":"3. 代码块 类的成员之四：代码块（或初始化块） 代码块的作用：用来初始化类和对象 代码块如果有修饰的话，只能使用static。 分类：静态代码块 vs 非静态代码块 静态代码块 内部可以有输出语句 随着类的加载而执行, 而且只执行一次 作用：初始化类的属性 如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行 静态代码块的执行要优先于非静态代码块的执行 静态代码块内只能调用静态的属性，静态的方法，不能调用非静态的结构 非静态代码块 内部可以有输出语句 随着对象的创建而执行 每创建一个对象，就执行一次非静态代码块 作用：可以在创建对象时，对对象的属性等进行初始化 如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行 非静态代码块内可以调用静态的属性，静态的方法，或非静态的属性，非静态的方法。 对属性可以赋值的位置： 1）默认初始化 2）显式初始化 3）构构造器中初始化 4）有了对象以后，可以通过“对象.属性”或“对象.方法”的方式赋值 5）在代码块中赋值 执行的顺序：1）- 2）/ 5）- 3）- 4） package com.atguigu.java3; public class BlockTest { public static void main(String[] args) { String desc = Person.desc; Person p1 = new Person(); Person p2 = new Person(); } } class Person { String name; int age; static String desc; public Person() { } public Person(String name, int age) { this.name = name; this.age = age; } // static的代码块 static { System.out.println(\"static block\"); desc = \"I love coding\"; } // 非static的代码块 { System.out.println(\"block\"); } public void eat() { System.out.println(\"person eat\"); } @Override public String toString() { return \"Person [name=\" + name + \", age=\" + age + \"]\"; } } 代码块是要早于构造器执行的 package com.atguigu.java3; public class LeafTest { public static void main(String[] args) { new Leaf(); // output: // Root的静态代码块 // Mid的静态代码块 // Leaf的静态代码块 // Root的普通代码块 // Root的无参构造器 // Mid的普通代码块 // Mid的带参构造器 // Leaf的普通代码块 // Leaf的无参构造器 } } class Root { static { System.out.println(\"Root的静态代码块\"); } { System.out.println(\"Root的普通代码块\"); } public Root() { System.out.println(\"Root的无参构造器\"); } } class Mid extends Root { static { System.out.println(\"Mid的静态代码块\"); } { System.out.println(\"Mid的普通代码块\"); } public Mid() { System.out.println(\"Mid的无参构造器\"); } public Mid(String msg) { System.out.println(\"Mid的带参构造器\"); } } class Leaf extends Mid { static { System.out.println(\"Leaf的静态代码块\"); } { System.out.println(\"Leaf的普通代码块\"); } public Leaf() { super(\"message\"); System.out.println(\"Leaf的无参构造器\"); } } 再看一个例子 package com.atguigu.java3; class Father { static { System.out.println(\"1\"); } { System.out.println(\"2\"); } public Father() { System.out.println(\"3\"); } } public class Son extends Father { static { System.out.println(\"4\"); } { System.out.println(\"5\"); } public Son() { System.out.println(\"6\"); } public static void main(String[] args) { System.out.println(\"7\"); new Son(); System.out.println(\"*****\"); new Son(); // output: 1 - 4 - 7 - 2 - 3 - 5 - 6 // output: ***** // output: 2 - 3 - 5 - 6 } } ","date":"2021-04-10","objectID":"/java-shk-6/:3:0","tags":["Java"],"title":"Java零基础教程（六.面向对象-重要补充）","uri":"/java-shk-6/"},{"categories":null,"content":"4. final关键字 final: final可以用来修饰的结构： 类，方法，变量 final用来修饰一个类: 此类不能被其他类所继承，即不能有子类了，比如：String类，System类，StringBuffer类。 final用来修饰一个方法：表明此方法不可以被重写，比如：Object类中getClass()。 final用来修饰变量：此时的“变量”就称为是一个常量 final修饰属性：可以考虑赋值的位置有：显式初始化，代码块中初始化, 构造器中初始化，（默认，方法位置都不赋值） final修饰局部变量：尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。 static final: static修饰属性，方法，代码块，内部类。final修饰属性，方法，类。其用来修饰属性表示全局常量。 自己用final通常就用来修饰属性，别人用来修饰方法和类时，能看懂。 package com.atguigu.java3; public class FinalTest { final int width = 10; final int LEFT; final int RIGHT; // final int DOWN; { LEFT = 1; } public FinalTest() { RIGHT = 2; } public FinalTest(int n) { RIGHT = n; } // public void setDown(int down) { // this.DOWN = down; // } public void doWidth() { // width = 20; } public void show() { final int NUM = 10;// 常量 // NUM += 20; } public void show(final int num) { // num = 20; // 编译错误 } public static void main(String[] args) { } } final class FinalA { } //class B extends FinalA{ // //} class AA { public final void show() { } } class BB extends AA { // public final void show() { // // } } 看一道题 package com.atguigu.java3; public class FinalExerciseTest { public static void main(String[] args) { Other o = new Other(); new FinalExerciseTest().addOne(o); } public void addOne(final Other o) { // o = new Other(); // 错误，o是final，不能指向新目标 o.i++;// 正确，o指向对象的i是变量，可以变化 System.out.println(o.i);// 1 } } class Other { public int i; } ","date":"2021-04-10","objectID":"/java-shk-6/:4:0","tags":["Java"],"title":"Java零基础教程（六.面向对象-重要补充）","uri":"/java-shk-6/"},{"categories":null,"content":"5. 抽象类 ","date":"2021-04-10","objectID":"/java-shk-6/:5:0","tags":["Java"],"title":"Java零基础教程（六.面向对象-重要补充）","uri":"/java-shk-6/"},{"categories":null,"content":"5.1 abstract关键字的使用 abstract：抽象的 abstract可以用来修饰的结构：类，方法 abstract修饰类：抽象类 此类不能实例化 抽象类中一定有构造器，便于子类实例化时调用（涉及：子类对象实例化的全过程） 开发中，都会提供抽象类的子类，让子类对象实例化，完成相应操作 abstract修饰方法：抽象方法 抽象方法只有方法的声明，没有方法体 包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法。 若子类重写了父类中所有的抽象方法后，此子类方可实例化 若子类没有重写父类中的所有的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰 package com.atguigu.java; public class AbstractTest { public static void main(String[] args) { // 一旦Person类抽象了，就不可实例化 // Person p1 = new Person(); // p1.eat(); } } abstract class Person { String name; int age; public Person() { } public Person(String name, int age) { this.name = name; this.age = age; } // 不是抽象方法 // public void eat() { // } // 抽象方法 public abstract void eat(); public void walk() { System.out.println(\"person walk\"); } } class Student extends Person { public Student(String name, int age) { super(name, age); } public void eat() { System.out.println(\"student eat\"); } } abstract使用上的注意点： abstract不能用来修饰：属性，构造器等结构 abstract不能用来修饰私有方法（private方法子类不能看作重写），静态方法（子父类都为static不能看作重写），final的方法，final的类 package com.atguigu.java; public class AbstractTest1 { } ","date":"2021-04-10","objectID":"/java-shk-6/:5:1","tags":["Java"],"title":"Java零基础教程（六.面向对象-重要补充）","uri":"/java-shk-6/"},{"categories":null,"content":"5.2 匿名子类 package com.atguigu.java; /* * 抽象类的匿名子类 */ public class PersonTest { public static void main(String[] args) { method(new B()); // 匿名对象 // 创建了一个匿名子类的对象 A a = new A() { @Override public void method1() { System.out.println(\"11111\"); } @Override public void method2() { System.out.println(\"22222\"); }}; method(a); System.out.println(\"==============\"); // 匿名子类的匿名对象 method(new A() { @Override public void method1() { System.out.println(\"333\"); } @Override public void method2() { System.out.println(\"444\"); }}); } public static void method(A a) { a.method1(); a.method2(); } } abstract class A { public abstract void method1(); public abstract void method2(); } class B extends A { @Override public void method1() { System.out.println(\"b method1\"); } @Override public void method2() { System.out.println(\"b method2\"); } } ","date":"2021-04-10","objectID":"/java-shk-6/:5:2","tags":["Java"],"title":"Java零基础教程（六.面向对象-重要补充）","uri":"/java-shk-6/"},{"categories":null,"content":"5.3 abstract应用 - 模板方法设计模式 package com.atguigu.java; /* * 抽象类的应用：模板方法的设计模式 */ public class TemplateTest { public static void main(String[] args) { Template t = new SubTemplate(); t.spendTime(); } } abstract class Template { public void spendTime() { long start = System.currentTimeMillis(); code(); long end = System.currentTimeMillis(); System.out.println(\"elapsed time: \"+ (end - start)); } public abstract void code(); } class SubTemplate extends Template { @Override public void code() { for (int i = 2; i \u003c= 1000; i++) { boolean isFlag = true; for (int j = 2; j \u003c= Math.sqrt(i); j++) { if (i % j == 0) { isFlag = false; break; } } if (isFlag) { System.out.println(i); } } } } 再来看一个模板方法设计模式的例子 package com.atguigu.java; // 抽象类的应用：模板方法的设计模式 public class TemplateMethodTest { public static void main(String[] args) { BankTemplateMethod m1 = new DrawMoney(); BankTemplateMethod m2 = new DrawMoney(); m1.process(); m2.process(); } } abstract class BankTemplateMethod { public void takeNumber() { System.out.println(\"take number\"); } public abstract void transact(); // 办理具体业务，钩子方法 public void evaluate() { System.out.println(\"give us a feedback! thanks\"); } public final void process() { takeNumber(); transact(); // 像个钩子，具体执行时，挂哪个子类，就执行哪个子类的实现代码 evaluate(); } } class DrawMoney extends BankTemplateMethod { @Override public void transact() { System.out.println(\"I want to draw my money out of my account\"); } } class ManageMoney extends BankTemplateMethod { @Override public void transact() { System.out.println(\"I want a private client to help me manage my money\"); } } ","date":"2021-04-10","objectID":"/java-shk-6/:5:3","tags":["Java"],"title":"Java零基础教程（六.面向对象-重要补充）","uri":"/java-shk-6/"},{"categories":null,"content":"6. 接口 一方面，有时必须从几个类中派生出一个子类，继承它们所有的属性和方法。但是，Java不支持多重继承。有了借口，就可以得到多重继承的效果。 另一方面，有时必须从几个类中抽取出一些共同的行为特征，而它们之间又没有“is-a”的关系，仅仅是具有相同的行为特征而已。例如：鼠标，键盘，打印机，扫描仪，摄像头，充电器，手机，移动硬盘等都支持USB连接。 接口就是规范，定义的是一组规则，体现了现实世界中“如果你是/要…则必须能”的思想。继承是一个“是不是”的关系，而接口实现则是“能不能”的关系。 接口的本质是契约，标准，规范，就像我们的法律一样。制订好后大家都要遵守。 ","date":"2021-04-10","objectID":"/java-shk-6/:6:0","tags":["Java"],"title":"Java零基础教程（六.面向对象-重要补充）","uri":"/java-shk-6/"},{"categories":null,"content":"6.1 接口的使用 接口使用interface来定义 Java中，接口和类是并列的两个结构 如何定义接口：定义接口中的成员 JDK7及以前：只能定义全局常量和抽象方法 全局常量：public static final的…但是书写时，可以省略不写 抽象方法：public abstract的 JDK8: 除了定义全局常量和抽象方法之外，还可以定义静态方法，默认方法（略） 接口中不能构造构造器的！意味着接口不可以实例化 Java开发中，接口通过让类去实现（implements）的方式来使用. 如果实现类覆盖了接口中的所有抽象方法，则此实现类就可以实例化 如果实现类没有覆盖接口中所有的抽象方法，则此实现类仍为一个抽象类。 Java类可以实现多个接口 -\u003e 弥补了Java单继承性的局限性 格式： class AA extends BB implements CC, DD, EE 接口与接口之间可以继承，而且可以多继承 接口的具体使用，体现多态性 接口，实际上可以看作是一种规范。 面试题：抽象类与接口有哪些异同？ package com.atguigu.java1; public class InterfaceTest { public static void main(String[] args) { Plane p = new Plane(); p.fly(); p.stop(); } } interface Attackable { void attack(); } interface Flyable { // 全局常量 public static final int MAX_SPEED = 7900;// 第一宇宙速度 int MIN_SPEED = 1; // 省略了public static final // 抽象方法 public abstract void fly(); void stop(); // 省略了public abstract } class Plane implements Flyable { @Override public void fly() { System.out.println(\"plane fly\"); } @Override public void stop() { System.out.println(\"plane stop\"); } } abstract class Kite implements Flyable { @Override public void fly() { System.out.println(\"kite fly\"); } } class Bullet implements Flyable, Attackable, CC { @Override public void attack() { // TODO Auto-generated method stub } @Override public void fly() { // TODO Auto-generated method stub } @Override public void stop() { // TODO Auto-generated method stub } @Override public void method1() { // TODO Auto-generated method stub } @Override public void method2() { // TODO Auto-generated method stub } } // ********************** interface AA { void method1(); } interface BB { void method2(); } interface CC extends AA, BB { } USB例子 接口的使用 接口使用上也满足多态性 接口，实际上就是定义了一种规范 开发中， 体会面向接口编程！ package com.atguigu.java1; public class USBTest { public static void main(String[] args) { Computer c = new Computer(); // 1. 创建了接口的非匿名实现类的非匿名对象 Printer p = new Printer(); c.transferData(p); // 2. 创建了接口的非匿名实现类的匿名对象 c.transferData(new Printer()); // 3. 创建了接口的匿名实现类的非匿名对象 USB phone = new USB() { @Override public void start() { System.out.println(\"phone start\"); } @Override public void stop() { System.out.println(\"phone stop\"); } }; c.transferData(phone); // 4. 创建了接口匿名实现类的匿名对象 c.transferData(new USB() { @Override public void start() { System.out.println(\"mp3 start\"); } @Override public void stop() { System.out.println(\"mp3 stop\"); } }); } } class Computer { public void transferData(USB usb) { usb.start(); System.out.println(\"transfering data...\"); usb.stop(); } } interface USB { // 定义了长，宽，最大最小的传输速度等 void start(); void stop(); } class Flash implements USB { @Override public void start() { System.out.println(\"flash start\"); } @Override public void stop() { System.out.println(\"flash stop\"); } } class Printer implements USB { @Override public void start() { System.out.println(\"printer start\"); } @Override public void stop() { System.out.println(\"printer stop\"); } } ","date":"2021-04-10","objectID":"/java-shk-6/:6:1","tags":["Java"],"title":"Java零基础教程（六.面向对象-重要补充）","uri":"/java-shk-6/"},{"categories":null,"content":"6.2 interface应用 - 代理模式 package com.atguigu.java1; /* * 接口的应用：代理模式 */ public class NetworkTest { public static void main(String[] args) { Server s = new Server(); ProxyServer proxyServer = new ProxyServer(s); proxyServer.browse(); } } interface Network { public void browse(); } // 被代理类 class Server implements Network { @Override public void browse() { System.out.println(\"真实的服务器访问网络\"); } } // 代理类 class ProxyServer implements Network { private Network work; public ProxyServer(Network work) { this.work = work; } public void check() { System.out.println(\"联网之前的检查工作\"); } @Override public void browse() { check(); work.browse(); } } 再来看一个代理模式的例子：明星与经纪人 package com.atguigu.java1; /* * 代理模式另外一个例子 */ public class StaticProxyTest { public static void main(String[] args) { Proxy s = new Proxy(new RealStar()); s.confer(); s.signContract(); s.bootTicket(); s.sing(); s.collectMoeny(); // output // 经纪人面谈 // 经纪人签合同 // 经纪人订票 // sing... sing... sing... // 经纪人收钱 } } interface Star { void confer(); // 面谈 void signContract(); // 签合同 void bootTicket(); // 订票 void sing(); // 唱歌 void collectMoeny(); // 收钱 } // 被代理类 class RealStar implements Star { @Override public void confer() { } @Override public void signContract() { } @Override public void bootTicket() { } @Override public void sing() { System.out.println(\"sing... sing... sing...\"); } @Override public void collectMoeny() { } } // 代理类，经纪人 class Proxy implements Star { private Star real; public Proxy(Star real) { this.real = real; } @Override public void confer() { System.out.println(\"经纪人面谈\"); } @Override public void signContract() { System.out.println(\"经纪人签合同\"); } @Override public void bootTicket() { System.out.println(\"经纪人订票\"); } @Override public void sing() { real.sing(); } @Override public void collectMoeny() { System.out.println(\"经纪人收钱\"); }} 一道考题 package com.atguigu.java1; public class C extends B implements A { public static void main(String[] args) { new C().pX(); } public void pX() { System.out.println(super.x); // 1 System.out.println(A.x);// 0 } } interface A { int x = 0; } class B { int x = 1; } ","date":"2021-04-10","objectID":"/java-shk-6/:6:2","tags":["Java"],"title":"Java零基础教程（六.面向对象-重要补充）","uri":"/java-shk-6/"},{"categories":null,"content":"6.3 Java8中interface新特性 package com.atguigu.java8; public class SubClassTest { public static void main(String[] args) { SubClass s = new SubClass(); // 知识点1: 接口中定义的静态方法，只能通过接口来调用 // s.method1();// 编译报错 CompareA.method1(); // 知识点2: 通过实现类的对象，可以调用接口中的默认方法。 // 如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法 s.method2(); // 知识点3： 如果子类（或实现类）继承的父类和实现的接口中声明类同名同参数的方法 // 那么子类在没有重写此方法的情况下，默认调用的是父类中的同名同参数的方法。-\u003e 类优先原则 // 知识点4: 如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法， // 那么在实现类没有重写此方法的情况下，报错。 -\u003e 接口冲突 // 这就需要我们必须在实现类中重写此方法。 s.method3(); } } class SubClass extends SuperClass implements CompareA, CompareB { public void method2() { System.out.println(\"SubClass - method2\"); } // 知识点5:如何在子类（或实现类)的方法中调用父类，接口中被重写的方法 public void myMethod() { method3();// 调用自己定义的重写的方法 super.method3();// 调用的是父类中声明的 // 调用接口中默认的方法 CompareA.super.method3(); CompareB.super.method3(); } } class SuperClass { public void method3() { System.out.println(\"SuperClass - method3\"); } } /* * JDK8: 除了定义全局常量和抽象方法之外，还可以定义静态方法，默认方法 */ interface CompareA { // 静态方法 public static void method1() { System.out.println(\"CompareA - method1\"); } // 默认方法 public default void method2() { System.out.println(\"CompareA - method2\"); } // public可以省略 default void method3() { System.out.println(\"CompareA - method3\"); } } interface CompareB { default void method3() { System.out.println(\"CompareB - method3\"); } } ","date":"2021-04-10","objectID":"/java-shk-6/:6:3","tags":["Java"],"title":"Java零基础教程（六.面向对象-重要补充）","uri":"/java-shk-6/"},{"categories":null,"content":"6.4 接口冲突的解决方式 package com.atguigu.java8; public class Man extends Father implements Filial, Spoony { public void help() { System.out.println(\"接口冲突，该救谁呢\"); Filial.super.help(); Spoony.super.help(); super.help(); } public static void main(String[] args) { Man m = new Man(); m.help(); } } class Father { public void help() { System.out.println(\"儿子，救我媳妇！\"); } } interface Filial { default void help() {// 孝顺的 System.out.println(\"救妈妈\"); } } interface Spoony {// 痴情的 default void help() { System.out.println(\"救媳妇\"); } } ","date":"2021-04-10","objectID":"/java-shk-6/:6:4","tags":["Java"],"title":"Java零基础教程（六.面向对象-重要补充）","uri":"/java-shk-6/"},{"categories":null,"content":"6.5 抽象类和接口有哪些共同点和区别？ 相同点：不能实例化，都可以被继承 不同点： 抽象类：有构造器。单继承。 接口：不能声明构造器。多继承。 ","date":"2021-04-10","objectID":"/java-shk-6/:6:5","tags":["Java"],"title":"Java零基础教程（六.面向对象-重要补充）","uri":"/java-shk-6/"},{"categories":null,"content":"7. 内部类 类的内部成员之五：内部类（例子：人与大脑） Java中允许将一个类A声明在另一个类B中，则类A就是内部类，类B称为外部类。 内部类的分类：成员内部类（静态，非静态） vs 局部内部类（方法内，代码块内，构造器内） 成员内部类： 一方面，作为外部类的成员： 调用外部类的结构 可以被static修饰 可以被4种不同的权限修饰 另一方面，作为一个类出现： 类内可以定义属性，方法，构造器等 可以被final修饰，表示此类不能被继承。言外之意，不使用final，就可以被继承 可以被abstract修饰 关注如下的3个问题 如何实例化成员内部类的对象 如何在成员内部类中区分调用外部类的结构 开发中，局部内部类等使用 package com.atguigu.java2; public class InnerClassTest { public static void main(String[] args) { // 创建Dog实例（静态的成员内部类） Person.Dog dog = new Person.Dog(); dog.show(); // 创建Bird实例（非静态的成员内部类） // Person.Bird bird = new Person.Bird(); Person p = new Person(); Person.Bird bird = p.new Bird(); bird.sing(); System.out.println(\"===============\"); bird.display(\"黄鹂\"); } } class Person { String name = \"小明\"; int age; public void eat() { System.out.println(\"person eat\"); } // 静态成员内部类 static class Dog { String name; int age; public void show() { System.out.println(\"卡拉是条狗\"); // eat();// 编译报错，调用非静态 } } // 非静态成员内部类 class Bird { String name = \"杜鹃\"; public void sing() { System.out.println(\"我是一只小小鸟\"); eat(); Person.this.eat();// 调用外部类的非静态属性 } public void display(String name) { System.out.println(name); // 方法的形参 System.out.println(this.name); // 内部类的属性 System.out.println(Person.this.name); // 外部类的属性 } } public void method() { class AA { } } { class BB { } } public Person() { class CC { } } } 开发中使用内部类的情况 package com.atguigu.java2; public class InnerClassTest1 { // 开发中很少见 public void method() { class AA { } } // 开发中用内部类的情况： // 返回一个实现了Comparable接口的类的对象 public Comparable getComparable() { // 创建一个实现了Comparable接口的类: 局部内部类 // 方式一： 标准的方式 // class MyComparable implements Comparable { // // @Override // public int compareTo(Object o) { // // TODO Auto-generated method stub // return 0; // } // // } // // return new MyComparable(); // 方式二：匿名 return new Comparable() { @Override public int compareTo(Object o) { // TODO Auto-generated method stub return 0; } }; } } ","date":"2021-04-10","objectID":"/java-shk-6/:7:0","tags":["Java"],"title":"Java零基础教程（六.面向对象-重要补充）","uri":"/java-shk-6/"},{"categories":null,"content":"8. 异常处理 ","date":"2021-04-10","objectID":"/java-shk-6/:8:0","tags":["Java"],"title":"Java零基础教程（六.面向对象-重要补充）","uri":"/java-shk-6/"},{"categories":null,"content":"8.1 异常体系结构与常见异常 Java虚拟机无法解决的严重问题。如：JVM系统内部错误，资源耗尽等严重情况。比如：StackOverflowError， OOM。一般不编写针对性的代码进行处理。 package com.atguigu.java; public class ErrorTest { public static void main(String[] args) { // 1. 栈溢出：java.lang.StackOverflowError // main(args); // 2. 堆溢出：java.lang.OutOfMemoryError // Integer[] arr = new Integer[1024*1024*1024]; } } 异常的体系结构 java.lang.Throwable | --- java.lang.Error:一般不编写针对性的代码进行处理 | --- java.lang.Exception: 可以进行异常的处理 | --- 编译时异常（checked） | --- IOException | --- FileNotFoundException | --- ClassNotFoundException | --- 异常时异常（unchecked） | --- NullPointerException | --- ArrayIndexOutofBoundsException | --- ClassCastException | --- NumberFormatException | --- InputMismatchException | --- ArithmeticException 面试题：常见的异常都有哪些？举例说明 package com.atguigu.java; import java.io.File; import java.io.FileInputStream; import java.util.Date; import java.util.Scanner; import org.junit.Test; public class ExceptionTest { // **************** 以下是编译时异常 ********************** @Test public void test7() { File file = new File(\"hello.txt\"); FileInputStream fis = new FileInputStream(file); int data = fis.read(); while (data != -1) { System.out.println((char)data); data = fis.read(); } fis.close(); } // **************** 以下是运行时异常 ********************** // ArithmeticException @Test public void test6() { int a = 10; int b = 0; System.out.println(a / b); } // InputMismatchException @Test public void test5(){ Scanner scanner = new Scanner(System.in); int score = scanner.nextInt(); scanner.close(); } // NumberFormatException @Test public void test4() { String str = \"abc\"; int num = Integer.parseInt(str); } // ClassCastException @Test public void test3() { Object obj = new Date(); String str = (String)obj; System.out.println(str); } //ArrayIndexOutofBoundsException @Test public void test2() { // 举例1 // int[] arr = new int[10]; // System.out.println(arr[10]); // 举例2 String str = \"abc\"; System.out.println(str.charAt(3)); } // NullPointerException @Test public void test1() { // 举例1 // int[] arr = null; // System.out.println(arr[3]); // 举例2 String str = \"abc\"; str = null; System.out.println(str.charAt(0)); } } ","date":"2021-04-10","objectID":"/java-shk-6/:8:1","tags":["Java"],"title":"Java零基础教程（六.面向对象-重要补充）","uri":"/java-shk-6/"},{"categories":null,"content":"8.2 异常处理机制一: try-catch-finally 一·异常的处理：抓抛模型(转院比喻) 过程一：“抛”：程序在正常执行的过程中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象，并将此对象抛出。一旦抛出对象以后，其后的代码就不再执行。 关于异常对象的产生： 系统自动生成的异常对象 手动地生成一个异常对象，并抛出（throw）不同于throws 过程二：“抓”：可以理解为异常的处理方式： 1）try-catch-finally 2) throws 二·try-catch-finally的使用 try { // 可能出现异常的代码 } catch(异常类型1 变量名1) { // 处理异常的方式1 } catch(异常类型2 变量名2) { // 处理异常的方式2 } catch(异常类型3 变量名3) { // 处理异常的方式3 } ... finanlly { //一定会执行的代码 } 说明： finally是可选的. 使用try将可能出现异常代码包装起来，在执行过程中，一旦出现异常，就会出现一个对应异常类的对象， 根据此对象的类型，去catch中进行匹配。 一旦try中的异常对象匹配到某一个catch时，就进入catch中进行异常的处理。一旦处理完成，就跳出当前的 try-catch结构（在没有写finally的情况）。继续执行其后的代码 catch中的异常类型如果没有子父类关系，则谁声明在上，谁声明在下无所谓。 catch中的异常类型如果满足子父类关系，则要求子类一定声明在父类的上面，否则，编译报错 常用的异常对象处理的方式： 1）String getMessage() 2) printStackTrace() 在try结构中声明的变量，在出了try结构以后，就不能再被调用 try-catch-finally结构可以嵌套 体会1：使用try-catch-finally处理编译时异常，使得程序在编译时就不再报错，但是运行时仍可能报错。相当于我们使用try-catch-finally将一个编译时可能出现的异常，延迟到运行时出现。 体会2: 开发中，由于运行时异常比较常见，所以我们通常就不针对运行时异常编写try-catch-finally了。针对于编译时异常，我们说一定要考虑异常的处理。 package com.atguigu.java; import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.IOException; import org.junit.Test; public class ExceptionTest1 { @Test public void test2() { try { File file = new File(\"hello.txt\"); FileInputStream fis = new FileInputStream(file); int data = fis.read(); while (data != -1) { System.out.println((char)data); data = fis.read(); } fis.close(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } @Test public void test1() { String str = \"123\"; str = \"abc\"; try { int num = Integer.parseInt(str); System.out.println(\"hello --- 1\"); } catch (NumberFormatException e) { // System.out.println(\"出现数值转换异常了，不要着急\"); // String getMessage() System.out.println(e.getMessage()); // printStackTrace(); e.printStackTrace(); } catch (NullPointerException e) { System.out.println(\"出现空指针异常了，不要着急\"); } catch (Exception e) { System.out.println(\"出现异常了，不要着急\"); } System.out.println(\"hello --- 2\"); } } finally具体使用 try-catch-finally中finally的使用： finally是可选的 finally中声明的是一定会被执行的代码。即使catch中又出现异常了，try中有return语句，catch中有return语句等情况。 像数据库连接，输入输出流，网络编程Socket等资源，JVM是不能自动回收的，我们需要自己手动地进行资源的释放。此时的资源释放，就需要声明在finally中。 package com.atguigu.java; import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.IOException; import org.junit.Test; public class FinallyTest { @Test public void test2() { FileInputStream fis = null; try { File file = new File(\"hello.txt\"); fis = new FileInputStream(file); int data = fis.read(); while (data != -1) { System.out.println((char)data); data = fis.read(); } } catch (FileNotFoundException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } finally { try { if (fis != null) fis.close(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } @Test public void testMethod() { int num = method(); System.out.println(num); // output: // 我一定会被执行 // 3 } public int method() { try { int[] arr = new int[10]; System.out.println(arr[10]); return 1; } catch (ArrayIndexOutOfBoundsException e) { e.printStackTrace(); return 2; } finally { System.out.println(\"我一定会被执行\"); return 3; } } @Test public void test1() { try { int a = 10; int b = 0; System.out.println(a / b); } catch (ArithmeticException e) { // e.printStackTrace(); int[] arr = new int[10]; System.out.println(arr[10]); } catch (Exception e) { e.printStackTrace(); } // System.out.println(\"执行\"); finally { System.out.println(\"执行了finally\"); } } } ","date":"2021-04-10","objectID":"/java-shk-6/:8:2","tags":["Java"],"title":"Java零基础教程（六.面向对象-重要补充）","uri":"/java-shk-6/"},{"categories":null,"content":"8.3 异常处理机制二: throws 异常处理的方式二：throws + 异常类型 throws + 异常类型写在方法的声明处。指明此方法执行时，可能会抛出的异常类型。一旦当方法体执行时，出现异常，仍会在异常代码出生成一个异常类的对象，此对象满足throws后异常类型时，就会被抛出。异常代码后续的代码，就不再执行。 体会：try-catch-finally: 真正的将异常给处理掉了。throws的方式只是将异常抛给了方法的调用者。并没有真正将异常处理掉。(将病人转到上级医院) 开发中如何选择使用try-catch-finally 还是使用throws？ 如果父类中被重写的方法没有throws方式处理异常，则子类重写的方法也不能使用throws，意味着：如果子类重写的方法中有异常，必须使用try-catch-finally方式处理。 执行的方法a中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。我们建议这几个方法使用throws的方式进行处理。而执行的方法a可以考虑使用try-catch-finally进行处理。 package com.atguigu.java; import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.IOException; public class ExceptionTest2 { public static void main(String[] args) { try { method2(); } catch (IOException e) { e.printStackTrace(); } } public static void method3() { try { method2(); } catch (IOException e) { e.printStackTrace(); } } public static void method2() throws IOException { method1(); } public static void method1() throws FileNotFoundException, IOException { File file = new File(\"hello.txt\"); FileInputStream fis = new FileInputStream(file); int data = fis.read(); while (data != -1) { System.out.println((char)data); data = fis.read(); } fis.close(); } } package com.atguigu.java1; import java.io.FileNotFoundException; import java.io.IOException; /* * 子类重写的规则之一： * 子类重写的方法抛出的异常类型 */ public class OverrideTest { public static void main(String[] args) { OverrideTest test = new OverrideTest(); test.display(new SuperClass()); } public void display(SuperClass s) { try { s.method(); } catch (IOException e) { e.printStackTrace(); } } } class SuperClass { public void method() throws IOException { } } class SubClass extends SuperClass { public void method() throws FileNotFoundException { } } ","date":"2021-04-10","objectID":"/java-shk-6/:8:3","tags":["Java"],"title":"Java零基础教程（六.面向对象-重要补充）","uri":"/java-shk-6/"},{"categories":null,"content":"8.4 手动抛出异常: throw 关于异常对象的产生： 系统自动生成的异常对象 手动地生成一个异常对象，并抛出（throw）不同于throws package com.atguigu.java2; public class StudentTest { public static void main(String[] args) { try { Student s = new Student(); s.regist(1001); System.out.println(s); } catch (Exception e) { e.printStackTrace(); System.out.println(e.getMessage()); } } } class Student { private int id; public void regist(int id) throws Exception { if (id \u003e 0) { this.id = id; } else { // System.out.println(\"您输入的数据非法！\"); // 手动抛出异常对象,一般为Exception或RuntimeException // throw new RuntimeException(\"您输入的数据非法！\"); throw new Exception(\"您输入的数据非法！\"); } } } ","date":"2021-04-10","objectID":"/java-shk-6/:8:4","tags":["Java"],"title":"Java零基础教程（六.面向对象-重要补充）","uri":"/java-shk-6/"},{"categories":null,"content":"8.5 用户自定义异常类 如何自定义异常类？ 继承于现有结构的：RuntimeException, Exception 提供serialVersionUID 提供重载的构造器 package com.atguigu.java2; public class MyException extends RuntimeException { static final long serialVersionUID = -7034897190745766939L; public MyException() { } public MyException(String msg) { super(msg); } } 一道实践题 package com.atguigu.exer; /* * 编写应用程序EcmDef.java，接受命令行的两个参数，要求不能输入负数，计算两数相除。 * 对数据类型不一致（NumberFormatException），缺少命令行参数（ArrayIndexOutOfBoundsException）， * 除0（ArithmeticException）及输入负数（EcDef自定义的异常）进行异常处理。 * * 提示： * 1）在主类（EcmDef）中定义异常方法（ecm）完成两数相除功能， * 2）在main()方法中使用异常处理语句进行异常处理。 * 3）在程序中，自定义对应输入负数的异常类（EcDef）。 * 4）运行时接受参数java EcmDef 20 10 // args[0]=\"20\", args[1]=\"10\" * 5）Integer类的static方法parseInt(String s)将s转换为对应的int值。 */ public class EcmDef { public static void main(String[] args) { try { int i = Integer.parseInt(args[0]); int j = Integer.parseInt(args[1]); System.out.println(ecm(i, j)); } catch (NumberFormatException e) { System.out.println(\"数据类型不一致\"); } catch (ArrayIndexOutOfBoundsException e) { System.out.println(\"缺少命令行参数\"); } catch (ArithmeticException e) { System.out.println(\"除0\"); } catch (EcDef e) { System.out.println(e.getMessage()); } } public static int ecm(int i, int j) throws EcDef { if (i \u003c 0 || j \u003c 0) { throw new EcDef(\"分子或分母为负数了\"); } return i / j; } } class EcDef extends RuntimeException { static final long serialVersionUID = -7034897190745766939L; public EcDef() { } public EcDef(String msg) { super(msg); } } ","date":"2021-04-10","objectID":"/java-shk-6/:8:5","tags":["Java"],"title":"Java零基础教程（六.面向对象-重要补充）","uri":"/java-shk-6/"},{"categories":null,"content":"1. 多态性使用和理解 面向对象特征之三：多态性 理解多态性：可以理解为一个事物的多种形态。 何为多态性：对象的多态性，父类的引用指向子类的对象（或子类的对象赋给父类的引用） 多态的使用：虚拟方法调用 有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。 总结：编译看左边，运行看右边。 便于站在高处(more generalized)指挥，而不局限于实施细节 多态性的使用前提：1）类的继承关系 2）方法的重写 对象的多态性，只适用于方法，不适用于属性。子类不会覆盖父类的同名属性，而是内存都有，编译和运行都看左边。 虚拟方法调用：（Virtual Method Invocation） 子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚拟方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法确定的。 package com.atguigu.java4; public class PersonTest { public static void main(String[] args) { Person p1 = new Person(); p1.eat(); Man man = new Man(); man.eat(); man.earnMoney(); // ************************** // 对象的多态性：父类的引用指向子类的对象 Person p2 = new Man(); //Person p3 = new Woman(); // 多态的使用：当调用子父类同名同参数方法时，实际执行的是子类重写父类的方法 --- 虚拟方法调用 p2.eat(); p2.walk(); // wrong // p2.earnMoney() } } 多态性使用例子 package com.atguigu.java4; import java.sql.Connection; // 多态性使用 // 举例一 public class AnimalTest { public static void main(String[] args) { AnimalTest test = new AnimalTest(); test.func(new Dog()); test.func(new Cat()); } public void func(Animal animal) { animal.eat(); animal.shout(); } } class Animal { public void eat() { System.out.println(\"animal eat\"); } public void shout() { System.out.println(\"animal shout\"); } } class Dog extends Animal { public void eat() { System.out.println(\"dog eat\"); } public void shout() { System.out.println(\"dog shout\"); } } class Cat extends Animal { public void eat() { System.out.println(\"cat eat\"); } public void shout() { System.out.println(\"cat shout\"); } } // 举例二 class Order { public void method(Object obj) { } } // 举例三 class Driver { public void doData(Connection conn) { // conn = new MySqlConnection(); new // 规范的步骤去操作数据 // conn.method1(); // conn.method2(); // conn.method3(); } } 面试： Q：多态性是编译时行为还是运行时行为？ A：运行时行为 方法的重载与重写 二者的定义细节：略 从编译和运行的角度看： 重载，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。他们的调用地址在编译期就绑定了。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。所以：对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”； 而对于多态，只有等到方法调用的那一刻，届时运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”。 引用一句Bruce Eckel的话： \u003e “不要犯傻，如果它不是晚绑定，它就不是多态。” - Bruce Eckel package com.atguigu.java5; import java.util.Random; public class InterviewTest { public static void main(String[] args) { int key = new Random().nextInt(3); System.out.println(key); Animal animal = getInstance(key); animal.eat(); } public static Animal getInstance(int key) { switch (key) { case 0: return new Cat(); case 1: return new Dog(); default: return new Sheep(); } } } class Animal { protected void eat() { System.out.println(\"animal eat\"); } } class Cat extends Animal { protected void eat() { System.out.println(\"cat eat\"); } } class Dog extends Animal { protected void eat() { System.out.println(\"dog eat\"); } } class Sheep extends Animal { protected void eat() { System.out.println(\"sheep eat\"); } } 再来看一个例子 练习： 若子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里的同名方法，系统将不可能把父类里的方法转移到子类中。编译看左边，运行看右边 对于实例变量不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量：编译运行都看左边 package com.atguigu.java; public class FieldMethodTest { public static void main(String[] args) { Sub s = new Sub(); System.out.println(s.count);// 20 s.display(); //20 Base b = s;//多态性 // == 对于引用数据类型来讲，比较的是两个引用数据类型变量的地址值是否相同 System.out.println(b == s);// true System.out.println(b.count);//10 b.display(); //20 } } class Base { int count = 10; public void display() { System.out.println(this.count); } } class Sub extends Base { int count = 20; public void display() { System.out.println(this.count); } } ","date":"2021-04-06","objectID":"/java-shk-5/:1:0","tags":["Java"],"title":"Java零基础教程（五.面向对象-多态Polymorphism）","uri":"/java-shk-5/"},{"categories":null,"content":"2. 向下转型与instanceof关键字 ","date":"2021-04-06","objectID":"/java-shk-5/:2:0","tags":["Java"],"title":"Java零基础教程（五.面向对象-多态Polymorphism）","uri":"/java-shk-5/"},{"categories":null,"content":"2.1 向下转型 有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。 如何才能调用子类特有的属性和方法？使用强制类型转换符，向下转型 较高级的基本数据类型（double） ｜ ^ 强制类型转化 | ｜ 自动类型提升 v ｜ 较低级的基本数据类型（int） 父类（Person） ｜ ^ 向下转型 | ｜ 向上转型：多态 v ｜ 子类（Student） ","date":"2021-04-06","objectID":"/java-shk-5/:2:1","tags":["Java"],"title":"Java零基础教程（五.面向对象-多态Polymorphism）","uri":"/java-shk-5/"},{"categories":null,"content":"2.2 instanceof关键字使用 a instanceof A：判断对象a是否是类A的实例。如果是返回true，如果不是返回false。 使用情景：为了避免在向下转型时出现ClassCastException的异常，我们在向下转型之前，先进行instanceof的判断，一旦返回true，就进行向下转型。如果返回false，不进行向下转型。 如果a instanceof A返回true，则a instanceof B也返回true。其中类B是类A的父类。 package com.atguigu.java; public class PersonTest { public static void main(String[] args) { Person p1 = new Person(); p1.eat(); Man man = new Man(); man.eat(); man.earnMoney(); // ************************** // 对象的多态性：父类的引用指向子类的对象 Person p2 = new Man(); //Person p3 = new Woman(); // 多态的使用：当调用子父类同名同参数方法时，实际执行的是子类重写父类的方法 --- 虚拟方法调用 p2.eat(); p2.walk(); // wrong // p2.earnMoney() // ************************** // 不能调用子类所特有的方法，属性：编译时，p2是Person类型。 System.out.println(\"************************\"); Man m1 = (Man)p2; m1.earnMoney(); // 使用强转时，可能出现ClassCastException的异常 // Woman w1 = (Woman)p2; // w1.goShopping(); // 使用instanceof判断 if (p2 instanceof Woman) { Woman w1 = (Woman)p2; w1.goShopping(); } if (p2 instanceof Man) { m1 = (Man)p2; m1.earnMoney(); } // 练习： // 问题一： 编译时通过，运行时不通过 // 举例一： // Person p3 = new Woman(); // Man m3 = (Man)p3; // 举例二： // Person p4 = new Person(); // Man m4 = (Man)p4; // 问题二：编译通过，运行时也通过 Object obj = new Woman(); Person p = (Person)obj; // 问题三：编译不过 // Man m5 = new Woman(); } } ","date":"2021-04-06","objectID":"/java-shk-5/:2:2","tags":["Java"],"title":"Java零基础教程（五.面向对象-多态Polymorphism）","uri":"/java-shk-5/"},{"categories":null,"content":"3. Object类与equals(),toString()方法 ","date":"2021-04-06","objectID":"/java-shk-5/:3:0","tags":["Java"],"title":"Java零基础教程（五.面向对象-多态Polymorphism）","uri":"/java-shk-5/"},{"categories":null,"content":"3.1 Object类 java.lang.Object类 Object类是所有Java类的根父类 如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类 Object类中的功能(属性，方法)就具有通用性。 属性：无 方法：equals(), toString(), getClass(), hashCode(), clone(), finalize(), wait(), notify(), notifyAll() Object类只声明了一个空参构造器 面试题 final, finally, finalize的区别？ package com.atguigu.java1; public class ObjectTest { public static void main(String[] args) { Order order = new Order(); System.out.println(order.getClass().getSuperclass()); } } class Order { } ","date":"2021-04-06","objectID":"/java-shk-5/:3:1","tags":["Java"],"title":"Java零基础教程（五.面向对象-多态Polymorphism）","uri":"/java-shk-5/"},{"categories":null,"content":"3.2 equals()使用 面试题：==和equals()区别 一·回顾==的使用 运算符 可以使用在基本数据类型变量和引用数据类型变量中 如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等。（不一定类型要相同） 如果比较的是引用数据类型变量：比较两个对象的地址值是否相同，即两个引用是否指向同一个对象实体 补充：==符号使用时，必须保证符号左右两边的变量类型一致，否则编译报错。 二·equals()方法的使用： 是一个方法，而非运算符 只能适用于引用数据类型 Object类中equals()的定义： public boolean equals(Object obj) { return (this == obj); } 说明：Object类中定义的equals()和==的作用是相同的：比较两个对象地址值是否相同，即是否都指向同一个对象实体 像String, Date, File, 包装类等都重写了Object类中的equals()方法，重写以后，比较的不是两个引用地址是否相同，而是比较两个对象的“实体内容”是否相同。 通常情况下，我们自定义的类如果使用equals()的话，也通常是比较两个对象的“实体内容”是否相同。那么，我们就需要对Object类中的equals()进行重写，重写的原则：比较两个对象的实体内容是否相同。 package com.atguigu.java1; public class EqualsTest { public static void main(String[] args) { int i = 10; int j = 10; double d = 10.0; System.out.println(i == j);// true System.out.println(i == d);// true char c = 10; System.out.println(i == c);// true char c1 = 'A'; char c2 = 65; System.out.println(c1 == c2);// true String str1 = new String(\"atguigu\"); String str2 = new String(\"atguigu\"); System.out.println(str1 == str2);// false System.out.println(str1.equals(str2));// true } } ","date":"2021-04-06","objectID":"/java-shk-5/:3:2","tags":["Java"],"title":"Java零基础教程（五.面向对象-多态Polymorphism）","uri":"/java-shk-5/"},{"categories":null,"content":"3.3 toString()使用 Object类中toString()的使用 当我们输出一个对象的引用时，实际上就是调用当前对象的toString() Object类中toString()的定义 public String toString() { return getClass().getName() + \"@\" + Integer.toHexString(hashCode()); } 像String, Date, File, 包装类等都重写了Object类中的toString()方法。使得在调用对象的toString()时，返回“实体内容”信息 自定义类也可以重写toString()方法，当调用此方法时，返回对象的“实体内容”。 ","date":"2021-04-06","objectID":"/java-shk-5/:3:3","tags":["Java"],"title":"Java零基础教程（五.面向对象-多态Polymorphism）","uri":"/java-shk-5/"},{"categories":null,"content":"4. 包装类，基本数据类型，String三者间的转换 包装类的使用 Java提供了8种基本数据类型对应的包装类，使得基本数据类型的变量具有类的特征 掌握的：基本数据类型，包装类，String三者间的相互转换 基本数据类型 -\u003e 包装类：调用包装类的构造器, 基本数据类型无法利用多态 包装类 -\u003e 基本数据类型：调用包装类的xxxValue，包装类不能加减乘除 JDK 5.0新特性：自动装箱与自动拆箱 * 基本数据类型，包装类 -\u003e String类型: String.valueOf() * String类型 -\u003e 基本数据类型，包装类: 调用包装类的parseXxx() package com.atguigu.java2; public class WrapperTest { public static void main(String[] args) { int num1 = 10; Integer in1 = new Integer(num1); System.out.println(in1.toString()); Integer in2 = new Integer(\"123\"); System.out.println(in2.toString()); Float f1 = new Float(12.3f); Float f2 = new Float(\"12.3\"); System.out.println(f1); System.out.println(f2); Boolean b1 = new Boolean(true); Boolean b2 = new Boolean(\"true\"); Boolean b3 = new Boolean(\"TrUe\"); System.out.println(b3); // true int i1 = in1.intValue(); float f3 = f1.floatValue(); System.out.println(i1); System.out.println(f3); //自动装箱 int num2 = 10; Integer in3 = num2;// 自动装箱 System.out.println(in3); int num3 = in3;// 自动拆箱 // 基本数据类型，包装类 -\u003e String类型：调用String重载的valueOf(Xxx xxx) int n1 = 10; // 方式1: 连接运算 String str1 = n1 + \"\"; // 方式2: 调用String的valueOf String s1 = String.valueOf(n1); // \"10\" String s2 = String.valueOf(new Double(12.4)); // \"12.4\" System.out.println(s1 + ',' + s2); int x = Integer.parseInt(\"123\"); boolean b = Boolean.parseBoolean(\"true\"); System.out.println(x); System.out.println(b); } } 一道考题 package com.atguigu.java2; public class InterviewTest { public static void main(String[] args) { } public void test1() { Object o1 = true ? new Integer(1) : new Double(2.0); System.out.println(o1); //1.0, 编译三元标识符，自动类型提升为Double，多态toString } public void test2() { Object o2; if (true) o2 = new Integer(1); else o2 = new Double(2.0); System.out.println(o2); // 1, 不需要自动类型提升 } public void test3() { Integer i = new Integer(1); Integer j = new Integer(1); System.out.println(i == j); // false // Integer内部定义了IntegerCache结构，IntegerCache中定义了Integer[], // 保存了-128～127范围的整数。如果我们使用自动装箱的方式，给Integer赋值的范围在 // -128～127范围内时，可以直接使用数组中的元素，不用再new了。目的：提高效率 Integer m = 1; Integer n = 1; System.out.println(m == n); // true Integer x = 128; // 相当于new了一个Integer对象 Integer y = 128; // 相当于又new了一个Integer对象 System.out.println(x == y); // false } } 体会包装类的引入意义 package com.atguigu.java2; import java.util.Scanner; import java.util.Vector; public class ScoreTest { public static void main(String[] args) { // 1. 实例化Scanner，用于从键盘获取学生成绩 Scanner scan = new Scanner(System.in); // 2. 创建Vector对象 Vector v = new Vector(); // 3. 给Vector中添加元素 int maxScore = 0; while (true) { System.out.println(\"input Student's score (negative number to end)\"); int score = scan.nextInt(); if (score \u003c 0) break; // before jdk5.0 // Integer el = new Integer(score); // v.addElement(el); // 多态 // after jdk5.0 v.addElement(score); // 自动装箱 // 4. 获取成绩最大值 if (score \u003e maxScore) maxScore = score; } // 5. 遍历Vector，得到每个学生成绩，并与最大值比较，得到等级 char level; for (int i = 0; i \u003c v.size(); i++) { Object obj = v.elementAt(i); // before jdk5.0 // Integer el = (Integer)obj; // int score = el.intValue(); // after jdk5.0 int score = (int)obj; if (maxScore - score \u003c= 10) { level = 'A'; } else if (maxScore - score \u003c= 20) { level = 'B'; } else if (maxScore - score \u003c= 30) { level = 'C'; } else { level = 'D'; } System.out.println(\"student score: \" + score + \", grade: \" + level); } } } ","date":"2021-04-06","objectID":"/java-shk-5/:4:0","tags":["Java"],"title":"Java零基础教程（五.面向对象-多态Polymorphism）","uri":"/java-shk-5/"},{"categories":null,"content":"1. 继承性的使用 面向对象的特征之二：继承性 一·继承性的好处 why？ 减少了代码的冗余，提高了代码的复用性 便于功能的扩展 为之后多态性的使用，提供了前提 二·继承性的格式：class A extends B{} A: 子类，派生类，subclass B: 父类，超类，基类，superclass 体现：一旦子类A继承父类B以后，子类A中就获取了父类B中声明的所有的结构：属性，方法。 特别地，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私有的结构。 只是因为封装性的影响，使得子类不能直接调用父类的结构而已。权限修饰符解决的是调用的问题。继承性解决的是能不能获取的问题。 子类继承父类以后，还可以声明自己特有的属性或方法，实现功能的扩展。 子类和父类的关系，不同于子集和集合的关系。 extends：扩展 三·Java中关于继承性的规定 一个类可以被多个子类继承 Java中类的单继承性：一个类只能有一个父类 子父类是相对的概念。 子类直接继承的父类，称为直接父类。间接继承的父类，称为间接父类。 子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法。 四· Object类 如果我们没有显式地声明一个类的父类的话，则此类继承于java.lang.Object类 所有的java类（除java.lang.Object类之外）都直接或间接的继承于java.lang.Object类 意味着，所有的java类具有java.lang.Object类声明的功能。 package com.atguigu.java; public class ExtendsTest { public static void main(String[] args) { Person p1 = new Person(); p1.setAge(1); Student s1 = new Student(); s1.eat(); s1.sleep(); } } 实例化过程 子类对象实例化的全过程 从结果上来看：（继承性） 子类继承父类以后，就获取了父类中声明的属性或方法。创建子类的对象，在堆空间中，就会加载所有父类中声明的属性。 从过程上来看： 当我们通过子类的构造器创建子类对象时，我们一定会直接或间接地调用其父类的构造器，进而调用父类的父类的构造器，直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所有的父类的结构，所以才可以看到内存中有父类中的结构，子类对象才可以考虑进行调用。 明确：虽然创建子类对象时，调用了父类的构造器，但是自始自终就创建过一个对象，即为new的子类对象。 ","date":"2021-04-04","objectID":"/java-shk-4/:1:0","tags":["Java"],"title":"Java零基础教程（四.面向对象-继承inheritance）","uri":"/java-shk-4/"},{"categories":null,"content":"2. 在子类中重写方法 ","date":"2021-04-04","objectID":"/java-shk-4/:2:0","tags":["Java"],"title":"Java零基础教程（四.面向对象-继承inheritance）","uri":"/java-shk-4/"},{"categories":null,"content":"2.1 方法重写的规定 方法的重写(override / overwrite) 重写：子类继承父类以后，可以对父类中同名同参的方法，进行覆盖操作 应用：重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参的方法时，实际执行的是子类重写父类的方法。 面试题：区分方法的重载与重写 重写的规定： 方法的声明： 权限修饰符 返回值类型 方法名(形参列表) throws 异常类型 {方法体} 约定俗成：子类中的叫重写的方法，父类中的叫被重写的方法 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同。 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符(类比：摊煎饼覆盖) cannot reduce the visibility of the inherited method from the superclass 特殊情况：子类不能重写父类中声明为private权限的方法，可以理解为子类重新写了一个方法 太小了，覆盖不了 https://stackoverflow.com/a/39072326 返回值类型： 父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void 父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或者A类的子类 父类被重写的方法的返回值类型是基本数据类型，则子类重写的方法的返回值类型必须是相同的基本数据类型 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型。（具体放到异常处理时候讲） 子类和父类中的同名同参数的方法要么都声明为非static的（考虑重写），要么都声明为static的（不是重写） 注意下面s.walk()的调用 package com.atguigu.java1; public class PersonTest { public static void main(String[] args) { Student s = new Student(\"CS\"); s.eat();// student eat s.walk(10); // person walk, person show, student eat // https://stackoverflow.com/a/6896598 } } /* class Person { String name; int age; public Person() { super(); } public Person(String name, int age) { super(); this.name = name; this.age = age; } public void eat() { System.out.println(\"person eat\"); } public void walk(int distance) { System.out.println(\"person walk \" + distance + \"km\"); show(); eat(); } private void show() { System.out.println(\"person show\"); } public Object info() { return null; } } class Student extends Person { String major; public Student() { super(); } public Student(String major) { this.major = major; } public void study() { System.out.println(\"major is \" + major); } public void eat() { System.out.println(\"student eat\"); } public void show() { System.out.println(\"student show\"); } public String info() { return null; } } */ ","date":"2021-04-04","objectID":"/java-shk-4/:2:1","tags":["Java"],"title":"Java零基础教程（四.面向对象-继承inheritance）","uri":"/java-shk-4/"},{"categories":null,"content":"2.2 再回顾：权限修饰符 private只能自己访问, default可以跨类（同包下）, protected子类可以访问（可以跨包）, public都可以访问。 ","date":"2021-04-04","objectID":"/java-shk-4/:2:2","tags":["Java"],"title":"Java零基础教程（四.面向对象-继承inheritance）","uri":"/java-shk-4/"},{"categories":null,"content":"2.3 super关键字 super关键字的使用 super理解为：父类的 super可以用来调用: 属性，方法，构造器 super的使用 我们可以在子类的方法或构造器中。通过使用“super.属性”或“super.方法”的方式，显式地调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略“super.” 特殊情况：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式地使用“super.属性”的方式，表明调用的是父类中声明的属性。 特殊情况：当子类重写了父类中的方法以后，我们要想在子类中调用父类中声明的方法时，则必须显式地 使用“super.方法”的方式，表明调用的是父类中声明的方法。 super调用构造器 我们可以在子类的构造器中显式地使用“super(形参列表)”的方式，调用父类中声明的指定构造器 “super(形参列表)”的使用，必须声明在子类构造器的首行。 我们在类的构造器中，针对于“this(形参列表)”或“super(形参列表)”只能二选一，不能同时出现 在构造器首行，没有显式地声明“this(形参列表)”或“super(形参列表)”，则默认调用的是父类中空参构造器 在类的多个构造器中，至少有一个类的构造器中使用了“super(形参列表)”，调用父类中的构造器 package com.atguigu.java3; public class SuperTest { public static void main(String[] args) { Student s = new Student(); s.study();// student study, student eat, person eat } } /* public class Person { String name; int age; int id;// 身份证 public Person() { } public Person(String name) { this.name = name; } public Person(String name, int age) { this(name); this.age = age; } public void eat() { System.out.println(\"person eat\"); } public void walk() { System.out.println(\"person walk\"); } } package com.atguigu.java3; public class Student extends Person { String major; int id;//学号 public Student() { } public Student(String major) { this.major = major; } public void eat() { System.out.println(\"student eat\"); } public void study() { System.out.println(\"student study\"); this.eat(); super.eat(); } } */ ","date":"2021-04-04","objectID":"/java-shk-4/:2:3","tags":["Java"],"title":"Java零基础教程（四.面向对象-继承inheritance）","uri":"/java-shk-4/"},{"categories":null,"content":"1. 类和对象 ","date":"2021-04-03","objectID":"/java-shk-3/:1:0","tags":["Java"],"title":"Java零基础教程（三.面向对象-封装Encapsulation）","uri":"/java-shk-3/"},{"categories":null,"content":"1.1 面向对象的思想 一· Java面向对象学习的三条主线 Java类及类的成员：属性，方法，构造器，代码块，内部类 面向对象的三大特征：封装性，继承性，多态性，（抽象性） 其他关键字：this, super, static, final, abstract, interface, package, import等。 二·“人把大象装进冰箱” 面向对象：强调的是功能行为，以函数为最小单位，考虑怎么做。 把冰箱门打开 抬起大象，塞进冰箱 把冰箱门关闭 面向对象：强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。 人 { 打开(冰箱) { 冰箱.开开(); } 抬起(大象) { 大象.进入(冰箱); } 关闭(冰箱) { 冰箱.闭合(); } } 冰箱 { 开开(){} 闭合(){} } 大象 { 进入(冰箱){} } 程序员从面向过程的执行者转化成了面向对象的指挥者。 三·面向对象的两个要素 类：对一类事物的描述，是抽象的，概念上的定义 对象：是实际存在的该类事物的每个个体，因而也称为实例（instance） 面向对象程序设计的重点是类的设计 设计类，就是设计类的成员 ","date":"2021-04-03","objectID":"/java-shk-3/:1:1","tags":["Java"],"title":"Java零基础教程（三.面向对象-封装Encapsulation）","uri":"/java-shk-3/"},{"categories":null,"content":"1.2 类的属性和方法 一·设计类，其实就是设计类的成员 属性 = 成员变量 = field 方法 = 成员方法 = 函数 = method 创建类的对象 = 类的实例化 二·类和对象的使用（面向对象思想落地） 创建类，设计类的成员 创建类的对象 通过“对象.属性”或“对象.方法”调用对象的结构 三·如果创建了一个类的多个对象，则每个对象都独立的拥有一套类的属性（非static） 意味着：如果我们修改一个对象的属性a，则不影响另外一个对象属性a的值。 package com.atguigu.java; // 测试类 public class PersonTest { public static void main(String[] args) { // TODO Auto-generated method stub // 2. 创建Person类的对象 Person p1 = new Person(); // Scanner scanner = new Scanner(System.in); // 调用对象的结构：属性，方法 // 调用属性： “对象.属性” p1.name = \"Tom\"; p1.isMale = true; System.out.println(p1.name); // 调用方法：“对象.方法” p1.eat(); p1.sleep(); p1.talk(\"Chinese\"); // ******************************** Person p2 = new Person(); System.out.println(p2.name);// null System.out.println(p2.isMale);// false // ******************************** // 将p1变量保存的对象地址值赋给p3，导致p1和p3指向了堆空间的同一个对象实体 Person p3 = p1; System.out.println(p3.name);//Tom p3.age = 10; System.out.println(p1.age);//10 } } // 1. 创建类 class Person { // 属性 String name; int age; boolean isMale; // 方法 public void eat() { System.out.println(\"人可以吃饭\"); } public void sleep() { System.out.println(\"人可以睡觉\"); } public void talk(String language) { System.out.println(\"人可以说话，使用的是： \" + language); } } ","date":"2021-04-03","objectID":"/java-shk-3/:1:2","tags":["Java"],"title":"Java零基础教程（三.面向对象-封装Encapsulation）","uri":"/java-shk-3/"},{"categories":null,"content":"1.3 属性 vs. 局部变量 类中属性的使用 属性 vs 局部变量 相同点： 定义变量的格式：数据类型 变量名 = 变量值 先声明，后使用 变量都有其对应的作用域 不同点： 在类中声明位置的不同 属性：直接定义在类的一对{} 局部变量：声明在方法内，方法形参，代码块内，构造器形参，构造器内部的变量 关于权限修饰符的不同 属性：可以在声明属性时，指明其权限，使用权限修饰符。常用的权限修饰符：private, public, 缺省, protected —\u003e 封装性。（目前，大家声明属性时，都是用缺省就可以了。） 局部变量：不可以使用权限修饰符。 默认初始化的情况： 属性：类的属性，根据其类型，都有默认初始化值。 整型(byte, short, int, long) 0 浮点型(float, double) 0.0 字符型(char), 0 或 '\\u0000' boolean: false 引用数据类型(类，数组，接口) null 局部变量：没有默认初始化值。意味着，我们在调用局部变量之前，一定要显式赋值。特别地：形参在调用时，我们再赋值即可。 在内存中家在的位置不同： 属性：加载到堆空间中（非static） 局部变量：加载到栈空间 package com.atguigu.java; public class UserTest { public static void main(String[] args) { // TODO Auto-generated method stub User u1 = new User(); System.out.println(u1.name); System.out.println(u1.age); System.out.println(u1.isMale); } } class User { // 属性 String name; public int age; boolean isMale; public void talk(String language) {// language: 形参，也是局部变量 System.out.println(\"我们使用\" + language + \"进行交流\"); } public void eat() { String food = \"烙饼\";// 局部变量，不赋值会报错 System.out.println(\"北方人喜欢吃: \" + food); } } ","date":"2021-04-03","objectID":"/java-shk-3/:1:3","tags":["Java"],"title":"Java零基础教程（三.面向对象-封装Encapsulation）","uri":"/java-shk-3/"},{"categories":null,"content":"1.4 类方法的声明和使用 类中方法的声明和使用 方法：描述类应该具有的功能 比如：Math类: sqrt() random()；Scanner类: nextXxx()；Arrays类: sort(), binarySearch(), toString(), equals() 举例： public void eat(){} public void sleep(int hour){} public String getName(){} public String getNation(String nation){} 方法的声明： 权限修饰符 返回值类型 方法名(形参列表) { 方法体 } static, final, abstract 来修饰的方法，后面再讲 说明： 关于权限修饰符：默认方法的权限修饰符先都使用public Java规定的4种权限修饰符：private, public, 缺省, protected —\u003e 封装性细说 返回值类型：有返回值 vs 没有返回值 如果方法有返回值，则必须在方法声明时，指定返回值的类型。同时方法中，需要使用return关键字类返回指定类型的变量或常量：“return 数据”。 如果方法没有返回值，则方法声明时，使用void来表示。通常，没有返回值的方法中，就不需要return。 但是如果使用的话，只能return;表示结束此方法的意思。 我们定义方法该不该有返回值？题目要求,凭经验：具体问题具体分析 方法名：属于标识符，遵循标识符的规则和规范，“见名知意” 形参列表： 方法可以声明0个，1个，或多个形参。 格式：数据类型1 形参1, 数据类型2 形参2, ... 我们定义方法时，该不该定义形参？题目要求,凭经验：具体问题具体分析 方法体：方法功能的体现 return关键字的使用： 使用范围：使用在方法体中 作用： 结束方法 针对于有返回值类型的方法，使用return 数据方法返回所要的数据。 注意点：return关键字后面不可以声明执行语句。 方法的使用中，可以调用当前类的属性或方法 特殊的：方法A中有调用了方法A：递归方法。 方法中不可以定义方法 class Customer { String name; int age; boolean isMale; public void eat() { System.out.println(\"客户吃饭\"); } public void sleep(int hour) { System.out.println(\"休息了\" + hour + \"个小时\"); } public String getName() { return name; } public String getNation(String nation) { String info = \"我的国籍是：\" + nation; return info; } } ","date":"2021-04-03","objectID":"/java-shk-3/:1:4","tags":["Java"],"title":"Java零基础教程（三.面向对象-封装Encapsulation）","uri":"/java-shk-3/"},{"categories":null,"content":"1.5 匿名对象 匿名对象的使用 理解： 我们创建的对象，没有显式地赋给一个变量名，即为匿名对象。 特征：匿名对象只能调用一次。 使用：如下 package com.atguigu.java; public class InstanceTest { public static void main(String[] args) { new Phone().price = 1999; new Phone().showPrice(); PhoneFactory pf = new PhoneFactory(); // 匿名对象的使用 pf.show(new Phone()); } } class PhoneFactory { public void show(Phone phone) { phone.showPrice(); } } class Phone { double price; public void showPrice() { System.out.println(\"价格为：\" + price); } } ","date":"2021-04-03","objectID":"/java-shk-3/:1:5","tags":["Java"],"title":"Java零基础教程（三.面向对象-封装Encapsulation）","uri":"/java-shk-3/"},{"categories":null,"content":"1.6 方法的重载 方法的重载（overload）loading… 定义：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。 “两同一不同”：同一个类，相同方法名；参数列表不同（参数个数不同或参数类型不同） 举例: Arrays类中重载的sort() / binarySearch() 判断是否是重载? 跟方法的权限修饰符，返回值类型，形参变量名，方法体没有关系。 在通过对象调用方法时，如何确定某一个指定的方法：方法名 -\u003e 参数列表 package com.atguigu.java1; public class OverLoadTest { // 如下的4个方法构成了重载 public void getSum(int i, int j) { System.out.println(\"1\"); } public void getSum(double d1, double d2) { System.out.println(\"2\"); } public void getSum(String s, int i) { System.out.println(\"3\"); } public void getSum(int i, String s) { System.out.println(\"4\"); } // 下面的都不算重载 // public int getSum(int i, int j) { // // } // public void getSum(int m, int n) { // // } // private void getSum(int i, int j) { // // } } ","date":"2021-04-03","objectID":"/java-shk-3/:1:6","tags":["Java"],"title":"Java零基础教程（三.面向对象-封装Encapsulation）","uri":"/java-shk-3/"},{"categories":null,"content":"1.7 可变个数形参 可变个数形参的方法 jdk 5.0 新增的内容 具体使用： 可变个数形参的格式： 数据类型 ... 变量名 当调用可变个数形参的方法时，传入参数的个数可以是0，1，2… 可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载 可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。换句话说，二者不能共存 可变个数形参在方法的形参中，必须声明在末尾 可变个数形参在方法的形参中，最多只能声明一个可变形参。 package com.atguigu.java1; public class MethodArgsTest { public static void main(String[] args) { MethodArgsTest test = new MethodArgsTest(); test.show(12);//1 test.show(\"hello\");//2 test.show(\"hello\", \"world\");//3 test.show();//3 } public void show(int i) { System.out.println(\"1\"); } public void show(String s) { System.out.println(\"2\"); } public void show(String ... strs) { System.out.println(\"3\"); } // public void show(String[] strs) { // // } } ","date":"2021-04-03","objectID":"/java-shk-3/:1:7","tags":["Java"],"title":"Java零基础教程（三.面向对象-封装Encapsulation）","uri":"/java-shk-3/"},{"categories":null,"content":"1.8 方法的值传递机制 方法的形参的值传递机制：值传递 形参：方法定义时，声明的小括号内的参数 实参：方法调用时，实际传递给形参的数据 值传递机制： 如果参数是基本数据类型，此时赋值的是变量所保存的数据值。 如果参数是引用数据类型，此时赋值的是变量所保存的数据的地址值。 package com.atguigu.java1; public class ValueTransferTest1 { public static void main(String[] args) { int m = 10; int n = 20; // 交换两个变量的值 int tmp = m; m = n; n = tmp; System.out.println(\"m = \" + m + \", n = \" + n); ValueTransferTest1 test = new ValueTransferTest1(); m = 10; n = 20; test.swap(m, n); System.out.println(\"m = \" + m + \", n = \" + n); System.out.println(\"**************************\"); Data data = new Data(); data.m = 10; data.n = 20; test.swap(data); System.out.println(\"m = \" + data.m + \", n = \" + data.n); } public void swap(int m, int n) { int tmp = m; m = n; n = tmp; } public void swap(Data data) { int tmp = data.m; data.m = data.n; data.n = tmp; } } class Data { int m; int n; } ","date":"2021-04-03","objectID":"/java-shk-3/:1:8","tags":["Java"],"title":"Java零基础教程（三.面向对象-封装Encapsulation）","uri":"/java-shk-3/"},{"categories":null,"content":"2. 面向对象特征之一：封装与隐藏 为什么需要封装？封装的作用和含义？ 我要用洗衣机，只需要按一下开关和洗涤模式就可以了。有必要了解洗衣机内部的结构吗？有必要碰电动机吗？ 我要开车，… 我们程序设计追求“高内聚，低耦合”。 高内聚：类的内部数据操作细节自己完成，不允许外部干涉； 低耦合：仅对外暴露少量的方法用于使用。 面向对象的特征一：封装与隐藏 一·问题的引入 当我们创建一个类的对象以后，我们可以通过“对象.属性”的方式，对对象的属性进行赋值。这里赋值操作要受到属性的数据类型和存储范围的制约。除此之外，没有其他制约条件。但是，在实际问题中，我们往往需要给属性赋值加入额外的限制条件。这个条件就不能在属性声明时体现，我们只能通过方法进行限制条件的添加。（比如：set）同时，我们需要避免用户再使用“对象.属性”的方式对属性进行赋值。则需要将属性声明为私有的（private） ---\u003e 此时，针对于属性就体现了封装性。 二·封装性的体现： 我们将类的属性私有化（private），同时，提供公共的（public）方法来获取（getXxx）和设置（setXxx）此属性的值 拓展：封装性的体现：1）如上 2） 不对外暴露的私有的方法 3） 单例模式 三·封装性的体现，需要权限修饰符来配合。 Java规定的4种权限：（从小到大）private, 缺省, protected, public 四种权限可以用来修饰类及类的内部结构：属性，方法，构造器，内部类 具体地， 四种权限都可以用来修饰类的内部结构：属性，方法，构造器，内部类 修饰类的话，只能使用：缺省，public 总结封装性：Java提供了4种权限修饰符来修饰类及类的内部结构，体现类及类的内部结构在被调用时的可见性大小 package com.atguigu.java; public class AnimalTest { public static void main(String[] args) { Animal a = new Animal(); a.name = \"大黄\"; a.age = 1; // a.legs = 4; a.show(); a.setLegs(4); a.show(); } } class Animal { String name; int age; private int legs; public void eat() { System.out.println(\"动物进食\"); } public void show() { System.out.println(\"name = \" + name + \", age = \" + age + \", legs = \" + legs); } public void setLegs(int l) { if (l \u003e= 0 \u0026\u0026 l % 2 == 0) { legs = l; } else { legs = 0; // 抛出异常 } legs = l; } public int getLegs() { return legs; } } 修饰符 类内部 同一个包 不同包的子类 同一个工程 private yes （缺省） yes yes protected yes yes yes public yes yes yes yes ","date":"2021-04-03","objectID":"/java-shk-3/:2:0","tags":["Java"],"title":"Java零基础教程（三.面向对象-封装Encapsulation）","uri":"/java-shk-3/"},{"categories":null,"content":"3. 构造器 ","date":"2021-04-03","objectID":"/java-shk-3/:3:0","tags":["Java"],"title":"Java零基础教程（三.面向对象-封装Encapsulation）","uri":"/java-shk-3/"},{"categories":null,"content":"3.1 构造器的使用 类的结构之三：构造器（或构造方法，constructor）的使用 一·构造器的作用： 创建对象 初始化对象的的信息 二·说明： 如果没有显式的定义类的构造器的话，则系统默认提供一个空参的构造器。 定义构造器的格式：权限修饰符 类名(形参列表){} 一个类中定义的多个构造器，彼此构成重载 一旦我们显式的定义了类的一个构造器之后，系统就不再提供默认的空参构造器。 一个类中，至少会有一个构造器。 package com.atguigu.java1; public class PersonTest { public static void main(String[] args) { // 创建类的对象: new + 构造器 Person p = new Person(); p.eat(); Person p1 = new Person(\"Tom\"); System.out.println(p1.name); } } class Person { // 属性 String name; int age; // 构造器 public Person() { System.out.println(\"constructing object\"); } public Person(String n) { name = n; } // 方法 public void eat() { System.out.println(\"人吃饭\"); } } ","date":"2021-04-03","objectID":"/java-shk-3/:3:1","tags":["Java"],"title":"Java零基础教程（三.面向对象-封装Encapsulation）","uri":"/java-shk-3/"},{"categories":null,"content":"3.2 属性赋值的先后顺序 总结：属性赋值的先后顺序 默认初始化值 显式初始化 构造器中赋值 通过“对象.方法” 或 “对象.属性”的方式赋值 以上操作的先后顺序：1 - 2 - 3 - 4 package com.atguigu.java1; public class UserTest { } class User { String name; int age = 1; public User() { } public User(int a) { age = a; } } ","date":"2021-04-03","objectID":"/java-shk-3/:3:2","tags":["Java"],"title":"Java零基础教程（三.面向对象-封装Encapsulation）","uri":"/java-shk-3/"},{"categories":null,"content":"3.3 JavaBean JavaBean 是一种Java语言写成的可重用组建。 所谓JavaBean，是指符合如下标准的Java类： 类是公共的 有一个无参的公共构造器 有属性，且有对应的get，set方法 package com.atguigu.java1; public class Customer { private int id; private String name; public Customer() { } public void setId(int i) { id = i; } public int getId() { return id; } public void setName(String n) { name = n; } public String getName() { return name; } } ","date":"2021-04-03","objectID":"/java-shk-3/:3:3","tags":["Java"],"title":"Java零基础教程（三.面向对象-封装Encapsulation）","uri":"/java-shk-3/"},{"categories":null,"content":"4 关键字 ","date":"2021-04-03","objectID":"/java-shk-3/:4:0","tags":["Java"],"title":"Java零基础教程（三.面向对象-封装Encapsulation）","uri":"/java-shk-3/"},{"categories":null,"content":"4.1 this关键字 this 关键字的使用 this可以用来修饰,调用：属性，方法，构造器 this修饰属性和方法： this理解为当前对象 或 当前正在创建的对象 在类的方法中，我们可以使用this.属性或this.方法的方式，调用当前对象的属性和方法。但是通常情况下，我们都选择省略this.。特殊情况下，如果方法的形参和类的属性同名时，我们必须显式地使用this.变量的方式，表明此变量是属性，而非形参。 在类的构造器中，我们可以使用this.属性或this.方法的方式，调用当前正在创建的对象属性和方法。但是通常情况下，我们都选择省略this.。特殊情况下，如果构造器的形参和类的属性同名时，我们必须显式地使用this.变量的方式，表明此变量是属性，而非形参。 this调用构造器 我们在类的构造器中，可以显式的使用this(形参列表)方式，调用本类中指定的其他构造器。 构造器中不能通过this(形参列表)方式调用自己。 如果一个类中有n个构造器，则最多有n-1构造器中使用了“this(形参列表)” 规定：this(形参列表)必须声明在当前构造器的首行 构造器内部，最多只能声明一个this(形参列表)，用来调用其他的构造器 package com.atguigu.java2; public class PersonTest { public static void main(String[] args) { Person p1 = new Person(); p1.setAge(1); System.out.println(p1.getAge()); } } class Person { private String name; private int age; public Person() { this.eat(); String info = \"Person初始化时，需要考虑如下的1，2，3，4，... (共40行代码)\"; System.out.println(info); } public Person(int age) { this(); this.age = age; } public Person(String name) { this(); this.name = name; } public Person(String name, int age) { this(age); this.name = name; // this.age = age; } public void setName(String name) { this.name = name; } public String getName() { return name; } public void setAge(int age) { this.age = age; } public int getAge() { return age; } public void eat() { System.out.println(\"人吃饭\"); this.study(); } public void study() { System.out.println(\"人学习\"); } } ","date":"2021-04-03","objectID":"/java-shk-3/:4:1","tags":["Java"],"title":"Java零基础教程（三.面向对象-封装Encapsulation）","uri":"/java-shk-3/"},{"categories":null,"content":"4.2 package和import关键字 一·package关键字的作用（类似班级的概念） 为了更好地实现项目中类的管理，提供包的概念。 使用package声明类或接口所属的包，声明在源文件的首行 包，属于标识符，遵循标识符的命名规则，规范(xxxyyyzzz)，“见名知意” 每“.”一次，就代表一层文件目录 补充 * 同一个包下，不能命名同名的接口，类。 * 不同的包下，可以命名同名的接口，类。 二·import关键字的使用 在源文件中显式的使用import结构导入指定包下的类，接口。 声明在包的声明和类的声明之间 如果需要导入多个结构，则并列写出即可 可以使用“xxx.*”的方式，表示可以导入xxx包下的所有结构。 如果使用的类或接口是java.lang包下定义的，则可以省略import结构 如果使用的类或接口是本包下定义的，则可以省略import接口。 如果在源文件中，使用了不同包下的同名类，则必须至少有一个类需要以全类名的方式显式 使用“xxx.*”方式表明可以调用xxx包下的所有结构。但是如果使用的是xxx子包下的结构，则仍需要显式import import static: 导入指定类或接口[中]的静态结构：属性或方法。 package com.atguigu.java2; import java.util.Date; import static java.lang.System.*; public class PackageImportTest { public static void main(String[] args) { Date date = new Date(); // 全类名 java.sql.Date date1 = new java.sql.Date(0); out.println(\"hello\"); } } ","date":"2021-04-03","objectID":"/java-shk-3/:4:2","tags":["Java"],"title":"Java零基础教程（三.面向对象-封装Encapsulation）","uri":"/java-shk-3/"},{"categories":null,"content":"1. 关键字 数据类型：class, interface, enum, byte, short, int, long, float, double, char, boolean, void 数值：true, false, null 流程控制：if, else, switch, case, default, while, do, for, break, continue, return 访问权限：private, protected, public 类，函数，变量的修饰符：abstract, final, static, synchronized 类与类关系：extends, implements 实例的创建，引用，判断：new, this, super, instanceof 异常处理：try, catch, finally, throw, throws 包：package, import 其他：native, strictfp, transient, volatile, assert ","date":"2021-03-10","objectID":"/java-shk-2/:1:0","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"2. 标识符 标识符（aka变量方法类名）的命名规范： 包：都小写 xxxyyy 类,接口：XxxYyy 变量方法：xxxYyy 常量：XXX_YYY_ZZZ ","date":"2021-03-10","objectID":"/java-shk-2/:2:0","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"3. 变量 ","date":"2021-03-10","objectID":"/java-shk-2/:3:0","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"3.1 数据类型 包含变量类型，变量名，和存储的值。变量都定义在其作用域内，在作用域内，它是有效的，除了作用域就失效了。 基本数据类型：整数类型byte（-128～127）, short（两字节-2^15～2^15-1）, int(四字节，-21亿～21亿), long（八字节，必须以小写或大写L结尾）； 浮点类型float（四字节，必须以f或F结尾，精确到7位有效数字，范围-3.403e38～3.403e38）, double（八字节，精度为float两倍，范围-1.798e308～1.798e308）;字符型char（两字节），布尔型boolean; 引用数据类型：类（例如String类），接口，数组 ASCII字符集：8bit表示 Unicode字符集：将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，使用Unicode没有乱码的问题。char c = \\u0043(字母C)。 UTF-8: 互联网上使用最广的一种Unicode的实现方式，采用变长编码方式，使用1～6个字节表示一个符号。 ","date":"2021-03-10","objectID":"/java-shk-2/:3:1","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"3.2 基本数据类型之间的转换 自动类型提升 当容量小的数据类型的变量与容量大的数据类型的变量做运算时，结果自动提升为容量大的数据类型。 所表示数据范围（容量）排序：byte， char， short \u003c int \u003c long \u003c float \u003c double,注意这里是范围大小，而不是所占空间大小（float四字节小于long的八字节）。 特别的，当byte，char，short之间做运算时，结果为int型。 // Example short s1 = 10; byte b1 = 10; char c1 = 'a'; // char c = c1 + s1; // 编译报错 // char c = c1 + b1; // 编译报错 // short s = b1 + s1; // 编译报错 // short s = b1 + b1; // 编译报错 long l = 123213; // 成功，自动类型提升 // long l1 = 12313213123232; // 编译报错 long l1 = 12313213123232L; // 成功 //float f = 12.3; // 编译报错，double往float转了 // 整形常量默认为int型，浮点型常量默认为double型 强制类型转换 是自动类型提升的逆操作，将范围大的值向范围小的变量转换 // Example double d = 12.3; // int i = d; // 编译报错 int i = (int)d; // 成功，但截断损失精度 int i2 = 128; byte b = (byte)i2; // 成功，但是b = -128 (二进制最高位的原因) ","date":"2021-03-10","objectID":"/java-shk-2/:3:2","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"3.3 String数据类型 String类型变量的使用： String属于引用数据类型 声明String类型变量时，使用一对“” String可以和8种基本数据类型做运算，且运算只能是连接运算“+” 运算的结果仍然是String类型。 String s1 = \"Hello World!\"; // 练习：判断+是相加还是连接 char c = 'a'; int num = 10; String str = \"hello\"; System.out.println(c + num + str); // 107hello System.out.println(c + str + num); // ahello10 System.out.println(c + (num + str)); // a10hello System.out.println((c + num) + str); // 107hello System.out.println(str + num + c); // hello10a System.out.println(\"* *\"); // * * System.out.println('*' + '\\t' + '*'); // 93, 因为是char之间的数值运算 System.out.println('*' + \"\\t\" + '*'); // * * System.out.println('*' + '\\t' + \"*\"); // 51*, 第一个相加执行的是数值运算 System.out.println('*' + ('\\t' + \"*\")); // * * ","date":"2021-03-10","objectID":"/java-shk-2/:3:3","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"3.4 进制转换 整数的四种常见进制：二进制（0b或0B），十进制，八进制（以数字0开头表示），十六进制（0x或0X） 三码： 原码：直接将一个数值换成二进制数，最高位是符号位。 负数的反码：是对原码按位取反，只是最高位（符号位）确定为1。 负数的补码：其反码加1。 正数的原码，反码，补码相同。负数的补码是其反码+1。 00001110: 十进制14 10001110: -14的原码，第一位是符号位 11110001: -14的反码，除第一位外按位取反 11110010: -14的补码，计算机底层以补码形式存储数据。 求10111011储存的是什么数？ 去补10111010 取反11000101 所以储存的是-(64+4+1) = -69 特别地，10000000储存的是-128 ","date":"2021-03-10","objectID":"/java-shk-2/:3:4","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"4. 运算符 ","date":"2021-03-10","objectID":"/java-shk-2/:4:0","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"4.1 算数运算符 加减乘除（/）取模（%），前自增，后自增，前自减，后自减，字符串连接（+） int num1 = 12; int num2 = 5; System.out.println(num1 / num2); // 2 System.out.println(num1 / num2 * num2); // 10 double res = num1 / num2; System.out.println(res); // 2.0 System.out.println(num1 / (num2 + 0.0)); // 2.4 System.out.println(12 % 5); // 2 System.out.println(-12 % 5); // -2 System.out.println(12 % -5); // 2 System.out.println(-12 % -5); // -2 // 取模的符号与被模数（12/-12）相同 int a1 = 10; int b1 = ++a1; int a2 = 10; int b2 = a2++; //执行后，a1是11，b1是11，a2是11，b2是10 //注意点 short s1 = 10; // s1 = s1 + 1; // 编译失败，int值放入short变量 s1++; //编译通过，自增不改变本身变量数据类型 byte b1 = 127; b1++; System.out.println(b1); // -128 ","date":"2021-03-10","objectID":"/java-shk-2/:4:1","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"4.2 赋值运算符 =， +=， -=， *=， /=， %= // option 1 int i1 = 10; int j1 = 10; // option 2 int i2, j2; i2 = j2 = 10; // option 3 int i3 = 10; j3 = 20; short s1 = 10; // s1 = s1 + 2; // 编译失败 s1 += 2; System.out.println(s1); // 12 // 所以开发中希望变量+2 // option1: num = num + 2; // option2 (推荐): num += 2; // 所以开发中希望变量+1 // option1: num = num + 1; // option2: num += 1; // option3 (推荐): num++; int n = 10; n += (n++) + (++n); System.out.println(n); // n = n + (n++) + (++n) = 10 + 10 + 12 = 32 ","date":"2021-03-10","objectID":"/java-shk-2/:4:2","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"4.3 比较运算符 ==, !=, \u003c, \u003e, \u003c=, \u003e=, instanceof ","date":"2021-03-10","objectID":"/java-shk-2/:4:3","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"4.4 逻辑运算符 \u0026, \u0026\u0026, |, ||, !（非）, ^（异或） ","date":"2021-03-10","objectID":"/java-shk-2/:4:4","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"4.5 位运算符 \u003c\u003c, \u003e\u003e, \u003e\u003e\u003e, \u0026, |, ^（异或运算）, ~（取反） 区分逻辑\u0026和位运算\u0026：逻辑\u0026计算的是boolean型，位运算\u0026计算的是数值。 总结 位运算符操作的都是整形的数据 在一定范围内，每向左移一位，相当于 *2 在一定范围内，每向右移一位，相当于 /2 // 交换两个变量的值 // option1: 推荐 int tmp = num1; num1 = num2; num2 = num1; // option2: 可能超出存储范围 num1 = num1 + num2; num2 = num1 - num2; num1 = num1 - num2; // option3: trick num1 = num1 ^ num2; num2 = num1 ^ num2; num1 = num1 ^ num2; ","date":"2021-03-10","objectID":"/java-shk-2/:4:5","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"4.6 三元运算符 (condition) ? caseTrue : caseFalse; ","date":"2021-03-10","objectID":"/java-shk-2/:4:6","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"5. 流程控制 import java.util.Scanner; class IfTest { public static void main(String[] args) { Scanner scan = new Scanner(System.in); System.out.println(\"Input exam score: (0-100)\"); int score = scan.nextInt(); if (score == 100) { System.out.println(\"win a BMW\"); } else if (score \u003e 80) { System.out.println(\"win a iPhone\"); } else if (score \u003e= 60) { System.out.println(\"win a iPad\"); } else { System.out.println(\"no prize\"); } } } 总结： 如果多个条件表达式之间互斥，哪个判断在上面在下面，无所谓。 如果多个条件表达式之间有交集，需要考虑清楚谁在上。 如果多个条件表达式之间有包含，通常情况下，范围小的在上面，否则范围小的可能没机会执行。 int number = 2; switch (number) { case 0: System.out.println(\"zero\"); break; case 1: System.out.println(\"one\"); break; case 2: System.out.println(\"two\"); break; default: System.out.println(\"other\"); break; } 总结： 根据switch的表达式中的值，依次匹配各个case的常量。一旦匹配成功，则进入相应的case结构中，调用其执行语句。当调用完执行语句以后，则依然继续向下执行其他case结构中的执行语句，直到遇到break关键字或此switch-case结构末尾结束为止。 break可以使用在switch-case结构中，表示一旦执行到此关键字，就跳出switch-case结构。 switch结构中的表达式，只能是如下的6种数据结构之一：byte，short，char，int，枚举类型（JDK5.0新增），String类型（JDK7.0新增）。 case之后只能声明常量，不能声明范围。 break关键字是可选的。 default类似于if-else结构中的else。default结构是可选的。 如果switch-case结构中的多个case执行语句相同，则可以考虑合并。 凡是可以使用switch-case结构的地方，都可以转换为if-else。反之不成立。 我们写分支结构时，当发现既可以使用switch-case，（同时，switch中表达式的取值情况不太多），又可以使用if-else时，我们优先选择使用switch-case。原因：switch-case执行效率稍高。 for (①；②；④) { ③; } // 1-2-3-4-2-3-4-...-2 ①; while (②) { ③; ④; } // 1-2-3-4-2-3-4-...-2 do { ③; ④; } while (②); // 1-3-4-2-3-4-...-2 class PrimeNumberTest { public static void main(String[] args) { boolean isFlag = true; int count = 0; // 获取当前时间距离1970-01-01 00:00:00 的毫秒数 long start = System.currentTimeMillis(); for (int i = 2; i \u003c= 100000; i++) { for (int j = 2; j \u003c= Math.sqrt(i); j++) { if (i % j == 0) { isFlag = false; break; } } if (isFlag == true) { count++; } isFlag = true; } long end = System.currentTimeMillis(); System.out.println(\"prime number count: \" + count); System.out.println(\"elapsed time: \" + (end - start)); } } 使用范围 不同 相同 break switch-case，循环结构中 结束当前循环 关键字后面不能声明执行语句 continue 循环结构中 结束当次循环 关键字后面不能声明执行语句 label: for (int i = 2; i \u003c 100000; i++) { for (int j = 2; j \u003c Math.sqrt(i); j++) { if (i % j == 0) { // break; 默认跳出包裹此关键字的最近一层循环。 // continue; // break label; //结束指定标识的一层循环结构 // continue label; //结束指定标识的一层循环结构的当次循环 continue label; } count++; } } 循环语句的四个组成部分 初始化部分 循环条件部分 循环体部分 迭代部分 总结： 写while循环千万小心不要丢了迭代条件。一旦丢了，就可能导致死循环。 我们写程序，要避免出现死循环。 for循环和while循环是可以互相转化的。区别：for循环和while循环的初始化条件部分的作用范围不同。 do-while循环至少会执行一次循环体。 ","date":"2021-03-10","objectID":"/java-shk-2/:5:0","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"6. 数组 ","date":"2021-03-10","objectID":"/java-shk-2/:6:0","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"6.1 Array的概念与基础使用 数组的理解： 数组（Array），是多个相同数据类型按照一定顺序排列的集合，并使用一个名字命名， 并通过编号的方式对这些数据进行统一管理。 数据相关的概念：数组名，元素，下标（索引），数组的长度（元素的个数） 数据的特点： 数组是有序排列的。 数组属于引用数据类型的变量，引用数据类型有数组，类，接口。String是一个类。数组的元素，既可以是基本数据类型，也可以是引用数据类型。 创建数组对象会在内存中开辟一整块连续的空间。 数组的长度一旦确定，就不能修改。 数组的分类： 按照维数：一维数组，二维数组。。。 按照元素类型：基本数据类型元素的数组，引用数据类型元素的数组 一维数组的使用 一维数组的声明和初始化 如何调用数组的指定位置的元素 如何获取数组的长度 如何遍历数组 数组元素的默认初始化值 数组的内存解析 package com.atguigu.java; import java.util.Iterator; public class ArrayTest { public static void main(String[] args) { // 1. 一维数组的声明和初始化 int num; // 声明 num = 10; // 初始化 int id = 1001; //声明 + 初始化 int[] ids; //声明 // 1.1 静态初始化：数组的初始化和数组元素的赋值操作同时进行 ids = new int[]{1001, 1002, 1003, 1004}; // 1.2 动态初始化：数组的初始化和数组元素的赋值操作分开进行 String[] names = new String[5]; // 也是正确的写法（类型推断） int[] arr4 = {1,2,3,4,5}; // 错误的写法： // int[] arr1 = new int[]; // int[5] arr2 = new int[5]; // int[] arr3 = new int[3]{1,2,3}; // 总结：数组一旦初始化完成，其长度就确定了。 // 2. 如何调用数组的指定位置的元素：通过角标的方式调用。 // 数组的角标（或索引）从0开始，到数组的长度-1结束。 names[0] = \"aaa\"; names[1] = \"bbb\"; names[2] = \"ccc\"; names[3] = \"ddd\"; names[4] = \"eee\"; // 3. 如何获取数组的长度。 // 属性：length System.out.println(names.length); // 5 // 4. 如何遍历数组 for (int i = 0; i \u003c names.length; i++) { System.out.println(names[i]); } } } package com.atguigu.java; public class ArrayTest1 { public static void main(String[] args) { // 5. 数组元素的默认初始化值 // \u003e 数组元素是整型：0 // \u003e 数组元素是浮点型：0.0 // \u003e 数组元素是char型：ASCII0的char或'\\u0000'(null) // \u003e 数组元素是boolean型：false // \u003e 数组元素是引用数据类型：null，String时也是null，而不是空字符串 // int[] arr = new int[4]; for (int i = 0; i \u003c arr.length; i++) { System.out.println(arr[i]); } System.out.println(\"************\"); float[] arr1 = new float[4]; for (int i = 0; i \u003c arr1.length; i++) { System.out.println(arr1[i]); } System.out.println(\"************\"); char[] arr2 = new char[4]; for (int i = 0; i \u003c arr2.length; i++) { System.out.println(\"----\" + arr2[i] + \"====\"); } System.out.println(\"************\"); boolean[] arr3 = new boolean[4]; for (int i = 0; i \u003c arr3.length; i++) { System.out.println(\"----\" + arr3[i] + \"====\"); } } } package com.atguigu.java; public class ArrayTest2 { public static void main(String[] args) { // 1. 二维数组的声明和初始化 // 静态初始化 int[] arr = new int[]{1,2,3}; // 一维数组 // 动态初始化1 String[][] arr2 = new String[3][2]; // 动态初始化2 String[][] arr3 = new String[3][]; // 错误的情况 // String[][] arr4 = new String[][4]; // String[4][3] arr5 = new String[][]; } } 内存解析： 栈（stack）：局部变量 堆（heap）：new出来的结构，对象，数组 方法区：常量池，静态域 ","date":"2021-03-10","objectID":"/java-shk-2/:6:1","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"6.2 Arrays工具类的使用 package com.atguigu.java; import java.util.Arrays; // java.util.Arrays: 操作数组的工具类，包含了用来操作数组的方法 public class ArraysTest { public static void main(String[] args) { // 1. 判断两个数组是否相等。 int[] arr1 = new int[]{1,2,3,4}; int[] arr2 = new int[]{1,3,2,4}; boolean isEquals = Arrays.equals(arr1, arr2); System.out.println(isEquals); // 2. 输出数组信息 System.out.println(Arrays.toString(arr1)); // 3. 将指定值填充到数组之中 Arrays.fill(arr1, 10); System.out.println(Arrays.toString(arr1)); // 4. 对数组排序 Arrays.sort(arr2); System.out.println(Arrays.toString(arr2)); // 5. 二分查找 int[] arr3 = new int[] {-98, -34, 2, 34, 54, 66, 79, 105, 210, 333}; int index = Arrays.binarySearch(arr3, 211); System.out.println(index); } } ","date":"2021-03-10","objectID":"/java-shk-2/:6:2","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"1. 硬件介绍 ","date":"2020-11-18","objectID":"/java-shk/:1:0","tags":["Java"],"title":"Java零基础教程（一.概论）","uri":"/java-shk/"},{"categories":null,"content":"1.1 CPU（中央处理器） 冯诺伊曼体系结构：冯诺伊曼被人们称为“计算机之父”。计算机由输入设备，输出设备，存储器，运算器，控制器构成。现代计算机中的CPU负责其中的运算与控制功能。 赫兹：现代计算机的计算速度以千兆赫（GHz）来表述。英文进制：KHz，MHz，GHz Intel i7-6700HQ：“6”第六代，HQ标压版本，U低压版本 摩尔定律：每一美元所能买到的电脑性能，每隔18-24个月翻一倍以上。 ","date":"2020-11-18","objectID":"/java-shk/:1:1","tags":["Java"],"title":"Java零基础教程（一.概论）","uri":"/java-shk/"},{"categories":null,"content":"1.2 存储 硬盘 硬盘存储的数据断电不丢失（持久化设备）。在windows系统中，A/B盘的位置是预留给软驱的（软驱已经淘汰）。 内存 Read-Access Memory，内存存储数据速度比硬盘快10倍以上，其部分解决了CPU运算过快，而硬盘数据存取太慢的问题。断电会导致数据丢失 bit：二进制表示0/1 byte：8 bits，内存中每个byte拥有唯一的地址。 进制：1KB = 1024B, 1MB = 1024KB, 1GB = 1024MB, 1T = 1024GB, 1PB = 1024TB, EB,ZB,YB,以此类推。 ROM：手机的“硬盘”，例如16GB，128GB。但是经常被大众（误）叫做手机内存。 ","date":"2020-11-18","objectID":"/java-shk/:1:2","tags":["Java"],"title":"Java零基础教程（一.概论）","uri":"/java-shk/"},{"categories":null,"content":"1.3 输入输出 输入设备： 鼠标键盘； 输出设备： 显示器打印机 1920x1080：像素矩阵 2K屏幕：比如2244x1080（2244\u003e2000） 屏幕尺寸：屏幕对角线长度 像素密度：sqrt(长度像素数^2 + 宽度像素数^2) / 屏幕尺寸 ","date":"2020-11-18","objectID":"/java-shk/:1:3","tags":["Java"],"title":"Java零基础教程（一.概论）","uri":"/java-shk/"},{"categories":null,"content":"1.4 通信设备 ","date":"2020-11-18","objectID":"/java-shk/:1:4","tags":["Java"],"title":"Java零基础教程（一.概论）","uri":"/java-shk/"},{"categories":null,"content":"2. 计算机发展史 图灵：计算机之父，人工智能之父 冯诺伊曼：计算机之父，博弈论之父 www（万维网）：简称web。www可以让Web客户端（如浏览器）访问浏览Web服务器上的页面。是一个由许多互相连接的超文本组成的系统，通过互联网访问。在这个系统中，每个有用的事物，称为一样资源，并且由一个全局统一资源标识符（URI）标识；这些资源通过超文本传输协议HTTP（Hypertext Transfer Protocol）传送给用户，用户通过点击链接来获得资源。 万维网vs因特网vs互联网：他们是包含关系。万维网是无数个网络站点和网页集合。因特网除了万维网，还包括电子邮件等。 BS架构，CS架构：browser server（例如百度搜索）； client server（例如QQ） ","date":"2020-11-18","objectID":"/java-shk/:2:0","tags":["Java"],"title":"Java零基础教程（一.概论）","uri":"/java-shk/"},{"categories":null,"content":"3. Java语言概述 ","date":"2020-11-18","objectID":"/java-shk/:3:0","tags":["Java"],"title":"Java零基础教程（一.概论）","uri":"/java-shk/"},{"categories":null,"content":"3.1 编程语言 机器语言 -\u003e 汇编语言 -\u003e 高级语言（面向过程）-\u003e 高级语言（面向对象） 执行效率越来越低，但开发效率越来越高。 TIOBE语言热度排行榜 ","date":"2020-11-18","objectID":"/java-shk/:3:1","tags":["Java"],"title":"Java零基础教程（一.概论）","uri":"/java-shk/"},{"categories":null,"content":"3.2 Java语言的历史 Java由SUN（Stanford University Network）于1995年推出的编程语言。 1991 - Green项目，最初命名Oak（橡树） 1994 - 开发组意识到Oak适合互联网（可以在Web浏览器中运行，使得用户可以使用图形界面进行交互） 1996 - 发布JDK1.0 2004 - 发布JDK1.5，因为具有里程碑特性，更名为JDK5.0 2005 - J2SE改名为JavaSE，J2EE改名为JavaEE，J2ME改名为JavaME 2009 - Oracle收购SUN 2014 - 发布JDK8.0，是继JDK5.0以来变化最大的版本，也是业界常用的版本。 其他常用于后台开发的语言：Java，PhP，Python，Go，NodeJS JavaSE：桌面应用（例如QQ） JavaEE：企业互联网后台开发 JavaME：移动端开发 现在JavaSE不常开发桌面应用了，之前SE与EE是并列关系，但是这里我们把SE当作EE的基础知识。 Java应用领域： 企业级应用 Android平台应用 大数据平台开发 ","date":"2020-11-18","objectID":"/java-shk/:3:2","tags":["Java"],"title":"Java零基础教程（一.概论）","uri":"/java-shk/"},{"categories":null,"content":"3.3 Java语言特性 特性： 面向对象（封装，继承，多态） 健壮性（去掉指针，提供了内存管理机制，但Java程序也会出现内存泄漏和内存溢出的问题！） 跨平台性（Write Once, Run Anywhere）只需要安装一个Java虚拟机（JVM），JVM有不同操作系统对应的版本Win，Linux，Mac等。 ","date":"2020-11-18","objectID":"/java-shk/:3:3","tags":["Java"],"title":"Java零基础教程（一.概论）","uri":"/java-shk/"},{"categories":null,"content":"3.4 环境搭建 常见简称： JDK：（Java Development Kit） JRE：（Java Runtime Environment）运行环境 JDK = JRE + 开发工具集（例如Javac编译工具等） JRE = JVM + JavaSE标准类库 jdk-8u131: JDK8.0，“u”-update，131补丁 Steps： 安装JDK8.0（不建议安装在系统C盘下，下一步。。。下一步） 安装JRE（理论上JDK安装包里包含JRE，但是Eclipse需要识别单独的JRE） 配置环境变量（使得javac等命令可以在任意目录执行） path环境变量：Windows操作系统执行命令时，索要搜寻的路径 Administrator的用户变量适用于当前登陆用户，而系统变量则适用于所有用户。 ","date":"2020-11-18","objectID":"/java-shk/:3:4","tags":["Java"],"title":"Java零基础教程（一.概论）","uri":"/java-shk/"},{"categories":null,"content":"4. 第一个程序HelloWorld 程序执行的流程：javac编译生成.class文件，java运行.class文件。 $ javac HelloWorld.java # 生成 HelloChina.class $ java HelloChina class HelloChina { public static void main(String[] args) { System.out.println(\"Hello, World!\"); } } 总结： 一个java文件中可以声明多个class， 但只能最多有一个类声明为public，而且public只能加在与文件名相同的类前面。 程序的入口是main方法，格式是固定的。 程序行以分号结尾。 编译以后，会生成一个或多个class文件，文件名与源文件中类名相同。 单行注释//, 多行注释/**/, javadoc文档注释javadoc -d myHello -author -version ","date":"2020-11-18","objectID":"/java-shk/:4:0","tags":["Java"],"title":"Java零基础教程（一.概论）","uri":"/java-shk/"},{"categories":null,"content":"5. Eclipse使用 先创建包（例如：com.atguigu.contact）,再创建类（例如HelloWorld.java）。 运行，右键Run As 快捷键 package com.atguigu.java; import java.util.ArrayList; /* * Eclipse中的快捷键 * 1. 补全代码的声明: alt + /; ctrl + space * 2. 快速修复: ctrl + 1; cmd + 1 * 3. 批量导包: ctrl + shift + o; cmd + shift + o * 4. 单行注释: ctrl + /; cmd + / * 5. 多行注释: ctrl + shift + /; ? * 6. 取消多行注释: ctrl + shift + \\; ? * 7. 复制指定行的代码: ctrl + alt + down/up; cmd + alt + down/up * 8. 删除指定行: ctrl + d; cmd + d * 9. 上下移动行: alt + up/down; alt + up/down * 10. 切换到下一行代码空位: shift + enter; shift + enter * 11. 切换到上一行代码空位: ctrl + shift + enter; cmd + shift + enter * 12. 如何查看源码: ctrl + 选中指定结构; cmd + 选中指定结构 * 如何搜索源码: ctrl + shift + t; cmd + shift + t * 13. 退回到前一个编辑的页面: alt + left; * 14. 进入到下一个编辑的页面: alt + right; * 15. 光标选中指定的类，查看继承树结构: ctrl + t; cmd + t * 16. 复制代码: ctrl + c; cmd + c * 17. 撤销: ctrl + z; cmd + z * 18. 反撤销: ctrl + y; cmd + y * 19. 剪切: ctrl + x; cmd + x * 20. 粘贴: ctrl + v; cmd + v * 21. 保存: ctrl + s; cmd + s * 22. 全选: ctrl + a; cmd + a * 23. 格式化代码: ctrl + shift + f; cmd + shift + f * 24. 选中数行，整体往后移动: tab; tab * 25. 选中数行，整体往前移动: shift + tab; shift + tab * 26. 在当前类中，现实类结构，并支持搜索指定的方法，属性等: ctrl + o; cmd + o * 27. 批量修改指定的变量名，方法名，类名等: alt + shift + r; ? * 28. 选中的结构大小写切换，变成大写: ctrl + shift + x; cmd + shift + x * 29. 选中的结构大小写切换，变成小写: ctrl + shift + y; cmd + shift + y * 30. 调出生成getter/setter/构造器结构: alt + shift + s; ? * 31. 显式当前选择资源（工程或文件）的属性: alt + enter; cmd + enter * * * 32. 快速查找， 参照选中的word快速定位到下一个: ctrl + k; cmd + k * 33. 关闭当前窗口: ctrl + w * 34. 关闭所有窗口: ctrl + shift + w * 35. 查看指定的结构使用过的地方: ctrl + alt + g; cmd + alt + g * 36. 查找和替换: ctrl + f; cmd + f * 37. 最大化当前的view: ctrl + m * 38. 直接定位到当前行首位: home * 39. 直接定位到当前行末尾：end * * */ public class EclipseKeys { final double PROJECT_ACCCOUNT_ID = 3.14; public static void main(String[] args) { ArrayList list = new ArrayList(); int n = 1; n = 2; n = 3; } } class User { private int id; private String name; } 添加注释模版 Window -\u003e Preferences -\u003e Java -\u003e Code Style -\u003e Code Templates ","date":"2020-11-18","objectID":"/java-shk/:5:0","tags":["Java"],"title":"Java零基础教程（一.概论）","uri":"/java-shk/"},{"categories":null,"content":"6. IntelliJ IDEA的使用 IntelliJ模块的概念：IntelliJ的project相当于Eclipse的workspace，IntelliJ的module相当于Eclipse的project。在IntelliJ中，一个project可以是一个电商项目，其中秒杀，登陆，等都可以作为其中的模块module。 module下在自动产生的src下创建package，在package内创建java文件。 常用配置： 设置自动导包：Auto Import: 勾选Add unambiguous imports on the fly，勾选Optimize imports on the fly 方法分隔符：show method separators 自动完成代码时忽略大小写：case sensitive completion 多个tab放到多行：show tabs in single row 自动编译：勾选build project automatically, 勾选compile independent modules in parallel 快捷键： 复制行：command + d 下面添加行：shift + enter 上面添加行：alt + command + enter 删除行：command + delete 左/右选中：shift + left/right 左/右选中词：alt + shift + left/right 移动光标到行首行尾：command + left/right 移动光标到前后词：alt + left/right 快速修复：alt + enter 查询类成员：fn + command + f12 调整缩进：tab, shift + tab surround with：option + command + t 查看函数参数选项：command + p 生成构造器，get set方法：command + n psvm或main: public static void main()快捷插入 sout: System.out.println() 其他模版：postfix completion, live templates ","date":"2020-11-18","objectID":"/java-shk/:6:0","tags":["Java"],"title":"Java零基础教程（一.概论）","uri":"/java-shk/"},{"categories":null,"content":"Chapter 1: The Machine Learning Landscape 下载github库中csv数据集: import urllib.request DOWNLOAD_ROOT = \"https://raw.githubusercontent.com/ageron/handson-ml2/master/\" os.makedirs(datapath, exist_ok=True) for filename in (\"oecd_bli_2015.csv\", \"gdp_per_capita.csv\"): print(\"Downloading\", filename) url = DOWNLOAD_ROOT + \"datasets/lifesat/\" + filename urllib.request.urlretrieve(url, datapath + filename) 预处理pivot: def prepare_country_stats(oecd_bli, gdp_per_capita): # 筛选行 oecd_bli = oecd_bli[oecd_bli[\"INEQUALITY\"]==\"TOT\"] # 抽取多行数据为多列数据 oecd_bli = oecd_bli.pivot(index=\"Country\", columns=\"Indicator\", values=\"Value\") # 列重命名 gdp_per_capita.rename(columns={\"2015\": \"GDP per capita\"}, inplace=True) gdp_per_capita.set_index(\"Country\", inplace=True) # join full_country_stats = pd.merge(left=oecd_bli, right=gdp_per_capita, left_index=True, right_index=True) # 排序 full_country_stats.sort_values(by=\"GDP per capita\", inplace=True) # 剔除不需要的行 remove_indices = [0, 1, 6, 8, 33, 34, 35] keep_indices = list(set(range(36)) - set(remove_indices)) # 按整数索引行 return full_country_stats[[\"GDP per capita\", 'Life satisfaction']].iloc[keep_indices] # df.pivot()作用： # Country | INDICATOR | Value Country | Dwe....... | Housing .. | ... # ---------------------------- ===》 ---------------------------------------- # Australia| Dwe...... | 1.10 Australia| 1.10 | 20.00 | ... # Australia| Housing ..| 20.00 Austria | ... # ... ... 保存图片: # Where to save the figures PROJECT_ROOT_DIR = \".\" CHAPTER_ID = \"fundamentals\" IMAGES_PATH = os.path.join(PROJECT_ROOT_DIR, \"images\", CHAPTER_ID) os.makedirs(IMAGES_PATH, exist_ok=True) def save_fig(fig_id, tight_layout=True, fig_extension=\"png\", resolution=300): path = os.path.join(IMAGES_PATH, fig_id + \".\" + fig_extension) print(\"Saving figure\", fig_id) if tight_layout: plt.tight_layout() plt.savefig(path, format=fig_extension, dpi=resolution) 在图片上加注释: sample_data.plot(kind='scatter', x=\"GDP per capita\", y='Life satisfaction', figsize=(5,3)) plt.axis([0, 60000, 0, 10]) position_text = { \"Hungary\": (5000, 1), # 文本框左下角xy \"Korea\": (18000, 1.7), \"France\": (29000, 2.4), \"Australia\": (40000, 3.0), \"United States\": (52000, 3.8), } for country, pos_text in position_text.items(): pos_data_x, pos_data_y = sample_data.loc[country] country = \"U.S.\" if country == \"United States\" else country # xy：箭头位置， xytext：文本框位置，shrink：箭头缩短10% plt.annotate(country, xy=(pos_data_x, pos_data_y), xytext=pos_text, arrowprops=dict(facecolor='black', width=0.5, shrink=0.1, headwidth=5)) plt.plot(pos_data_x, pos_data_y, \"ro\") plt.xlabel(\"GDP per capita (USD)\") save_fig('money_happy_scatterplot') plt.show() 如果数据集中某些样本缺少一些特征（比如5%的顾客没有声明年龄），可以尝试的方法：1）忽略所有样本的年龄，2）忽略缺少年龄特征的样本，3）补缺（比如年龄的中位数）4）训练两个模型，一个包含所有特征，一个不含缺失特征。 Holdout validation: 在training set上效果好的模型，不一定在新数据上表现好，所以我们需要训练集外的数据来评判模型泛化能力。在test set上表现好的模型也只能表示其在该特定test set上表现好，还需要第三个数据集客观评判。所以，常见的处理是把数据集分为training dataset，validation dataset，和test dataset。用training dataset训练模型，确定模型参数。用validation dataset挑选一系列模型（比如确定hyperparameter）。通过validation dataset上的表现，选出最优模型再在training+validation上训练。最后通过test dataset客观评价模型的泛化能力。（思考kaggle的open和private数据集） ","date":"2020-10-25","objectID":"/handson-ml2-1/:1:0","tags":["machine learning"],"title":"《机器学习实战（第二版）》-读书笔记1","uri":"/handson-ml2-1/"},{"categories":null,"content":"数据的读入 ","date":"2020-10-19","objectID":"/kaggle-regression-eda/:1:0","tags":["kaggle","eda"],"title":"Kaggle Regression Eda","uri":"/kaggle-regression-eda/"},{"categories":null,"content":"特征的理解 ","date":"2020-10-19","objectID":"/kaggle-regression-eda/:2:0","tags":["kaggle","eda"],"title":"Kaggle Regression Eda","uri":"/kaggle-regression-eda/"},{"categories":null,"content":"特征的数据类型 df.info(verbose=True) # 查看每列缺省情况和数据类型 Pandas dtype Python type NumPy type Usage object str or mixed string_, unicode_, mixedtypes 字符串文本 int64 int int_, int8, int16, int32, int64, uint8, uint16, uint32, uint64 整数 float64 float float_, float16, float32, float64 浮点数 bool bool bool_ 真假 datetime64 NA datetime64[ns] 日期与时间 timedelta[ns] NA NA 日期时间差 category NA NA Finite list of text values ","date":"2020-10-19","objectID":"/kaggle-regression-eda/:2:1","tags":["kaggle","eda"],"title":"Kaggle Regression Eda","uri":"/kaggle-regression-eda/"},{"categories":null,"content":"特征类型 这个步骤是用来理解数据中每一列的具体含义，通过查看feature与label的关系，可以检查是否符合自己的直观感受。比如，通常情况下，房子越大，房子越新，房价越高，等等。可以通过数据类型将每个feature划归到对应的特征类型，便于后续的分析与建模。 类型1: ID 主要查看数据集是否为event level，看是否需要聚合操作将每个ID的行为总结。数据集可以是交易数据，每行数据为一笔交易，也可以是看房数据，同一套房子可能触发多个看房事件。例如，聚合每套房子的看房者数量，可以一定程度上帮助预测房子的火热程度。 类型2: Numerical 区别于类别型，数值型的特征值是可比较的，包含连续型和离散型。连续型的例子可以是价格，面积，温度, 时间。离散型的例子可以是用户打分（例如五星好评）。对于时间特征，可以做差生成时间段特征。 类型3: Categorical def specify_feature_type(df): numerical_cols = df.select_dtypes(include='number').columns.tolist() object_cols = df.select_dtypes(include='object').columns.tolist() id_features = ['Id'] label = ['SalePrice'] numerical_features = list(set(numerical_cols) - set(id_features) - set(label)) categorical_features = object_cols return id_features, numerical_features, categorical_features, label id_features, numerical_features, categorical_features, label = specify_feature_type(df) assert len(id_features) + len(numerical_features) + len(categorical_features) + len(label) == df.shape[1] ","date":"2020-10-19","objectID":"/kaggle-regression-eda/:2:2","tags":["kaggle","eda"],"title":"Kaggle Regression Eda","uri":"/kaggle-regression-eda/"},{"categories":null,"content":"特征的分布与预测能力 对于numerical feaure，可以计算feature与label的线性相关性Pearson Correlation Coefficient (PCC)，并将强相关性关系画出来。 def rank_feature_by_corr(df, method='pearson'): \"\"\"calculate Pearson correlation coefficient between feature and label, and rank the results\"\"\" feature_corr = dict() for feature in numerical_features: feature_corr[feature] = df[feature].corr(df[label[0]], method) corr_df = pd.DataFrame(feature_corr.items(), columns=['feature', 'corr']) corr_df['abs'] = np.abs(corr_df['corr']) return corr_df.sort_values('abs', ascending=False).reset_index(drop=True) def plot_feature_correlation(df, feature): fig = px.scatter(df, x=feature, y=label[0], \\ marginal_x=\"histogram\", marginal_y=\"histogram\",\\ width=600, height=450) fig.show() pcc_rank = rank_feature_by_corr(df) for i in range(2): plot_feature_correlation(df, pcc_rank.loc[i,'feature']) 而对于categorical feature, 可以画出feature列中每种类别的label分布。 import plotly.figure_factory as ff def plot_label_distribution_per_class(df, feature): hist_data = [] group_labels = [] for name, group in df.groupby(feature): hist_data.append(group[label[0]]) group_labels.append(name) # Create distplot with curve_type set to 'normal' fig = ff.create_distplot(hist_data, group_labels, show_hist=False) # Add title fig.update_layout(title_text='Curve and Rug Plot') fig.show() plot_label_distribution_per_class(df, categorical_features[0]) 也可以用heatmap将两两之间的相关性画出来。 fig = px.imshow(df.corr()) fig.show() ","date":"2020-10-19","objectID":"/kaggle-regression-eda/:2:3","tags":["kaggle","eda"],"title":"Kaggle Regression Eda","uri":"/kaggle-regression-eda/"},{"categories":null,"content":"参考 pandas数据类型 Kaggle房价预测 correlation between categorical and numerical variable ","date":"2020-10-19","objectID":"/kaggle-regression-eda/:3:0","tags":["kaggle","eda"],"title":"Kaggle Regression Eda","uri":"/kaggle-regression-eda/"},{"categories":null,"content":"Example 1. DataFrame的5种基本操作 1.筛选行，2.选取列，3.增加行列，4.分组总结，5.排序 一个简单的工资数据集： df = spark.createDataFrame([ (1, 'sales', 4200), (2, 'admin', 3100), (3, 'sales', 4000), (4, 'sales', 4000), (5, 'admin', 2700), (6, 'dev', 3400), (7, 'dev', 5200), (8, 'dev', 3700), (9, 'dev', 4400), (10, 'dev', 4400) ], schema=['id', 'dept', 'salary']) df.show() # +---+-----+------+ # | id| dept|salary| # +---+-----+------+ # | 1|sales| 4200| # | 2|admin| 3100| # | 3|sales| 4000| # | 4|sales| 4000| # | 5|admin| 2700| # | 6| dev| 3400| # | 7| dev| 5200| # | 8| dev| 3700| # | 9| dev| 4400| # | 10| dev| 4400| # +---+-----+------+ Q1: 列出dev部门工资大于4000的所有id。(filter, select, show) df.filter((F.col('dept') == 'dev') \u0026 (F.col('salary') \u003e 4000)).select(['id', 'salary']).show() # +---+------+ # | id|salary| # +---+------+ # | 6| 3400| # | 7| 5200| # | 8| 3700| # | 9| 4400| # | 10| 4400| # +---+------+ Q2: 求基础工资的10%奖金列，并补全列名dept-\u003edepartment。(withColumn, withColumnRenamed) df.withColumn('bonus', F.col('salary')*0.1).withColumnRenamed('dept', 'department').show() # +---+----------+------+-----+ # | id|department|salary|bonus| # +---+----------+------+-----+ # | 1| sales| 4200|420.0| # | 2| admin| 3100|310.0| # | 3| sales| 4000|400.0| # | 4| sales| 4000|400.0| # | 5| admin| 2700|270.0| # | 6| dev| 3400|340.0| # | 7| dev| 5200|520.0| # | 8| dev| 3700|370.0| # | 9| dev| 4400|440.0| # | 10| dev| 4400|440.0| # +---+----------+------+-----+ Q3: 求每个部门的最低工资，平均工资，最高工资。(groupby, agg, alias, sort), 并按平均工资降序排序。 df.groupby('dept').agg(F.min(F.col('salary')).alias('minimum'), \\ F.avg(F.col('salary')).alias('mean'), \\ F.max(F.col('salary')).alias('maximum'))\\ .sort('mean', ascending=False).show() # +-----+-------+------------------+-------+ # | dept|minimum| mean|maximum| # +-----+-------+------------------+-------+ # | dev| 3400| 4220.0| 5200| # |sales| 4000|4066.6666666666665| 4200| # |admin| 2700| 2900.0| 3100| # +-----+-------+------------------+-------+ ","date":"2020-09-03","objectID":"/spark-practice-101/:1:0","tags":["spark"],"title":"Spark 101: DataFrame基本使用","uri":"/spark-practice-101/"},{"categories":null,"content":"Example 2. groupby 与 window 参考：Youtube, How do spark window functions work? Q1: 求部门工资数组，和部门总工资。(groupby, agg, collect_list) df = df.groupby('dept').agg( F.expr('collect_list(salary)').alias('list_salary'), F.expr('avg(salary)').alias('average_salary'), F.expr('sum(salary)').alias('total_salary') ).show() # +-----+--------------------+------------------+------------+ # | dept| list_salary| average_salary|total_salary| # +-----+--------------------+------------------+------------+ # | dev|[3400, 5200, 3700...| 4220.0| 21100| # |sales| [4200, 4000, 4000]|4066.6666666666665| 12200| # |admin| [3100, 2700]| 2900.0| 5800| # +-----+--------------------+------------------+------------+ Q2: 在每条数据旁列出所在部门的工资情况（上问的答案）。(Window, partitionBy, over) windowSpec = Window.partitionBy('dept') df = df.withColumn('list_salary', F.collect_list(F.col('salary')).over(windowSpec))\\ .withColumn('average_salary', F.avg(F.col('salary')).over(windowSpec))\\ .withColumn('total_salary', F.sum(F.col('salary')).over(windowSpec)).show() # +---+-----+------+--------------------+------------------+------------+ # | id| dept|salary| list_salary| average_salary|total_salary| # +---+-----+------+--------------------+------------------+------------+ # | 6| dev| 3400|[3400, 5200, 3700...| 4220.0| 21100| # | 7| dev| 5200|[3400, 5200, 3700...| 4220.0| 21100| # | 8| dev| 3700|[3400, 5200, 3700...| 4220.0| 21100| # | 9| dev| 4400|[3400, 5200, 3700...| 4220.0| 21100| # | 10| dev| 4400|[3400, 5200, 3700...| 4220.0| 21100| # | 1|sales| 4200| [4200, 4000, 4000]|4066.6666666666665| 12200| # | 3|sales| 4000| [4200, 4000, 4000]|4066.6666666666665| 12200| # | 4|sales| 4000| [4200, 4000, 4000]|4066.6666666666665| 12200| # | 2|admin| 3100| [3100, 2700]| 2900.0| 5800| # | 5|admin| 2700| [3100, 2700]| 2900.0| 5800| # +---+-----+------+--------------------+------------------+------------+ Q3: 将工资在其部门顺序，在部门内扫描得到前缀和（相等的工资同时扫描）。(orderBy) windowSpec = Window.partitionBy('dept').orderBy(F.asc('salary')) df = df.withColumn('list_salary', F.collect_list(F.col('salary')).over(windowSpec))\\ .withColumn('average_salary', F.avg(F.col('salary')).over(windowSpec))\\ .withColumn('total_salary', F.sum(F.col('salary')).over(windowSpec)).show() # +---+-----+------+--------------------+------------------+------------+ # | id| dept|salary| list_salary| average_salary|total_salary| # +---+-----+------+--------------------+------------------+------------+ # | 6| dev| 3400| [3400]| 3400.0| 3400| # | 8| dev| 3700| [3400, 3700]| 3550.0| 7100| # | 9| dev| 4400|[3400, 3700, 4400...| 3975.0| 15900| # | 10| dev| 4400|[3400, 3700, 4400...| 3975.0| 15900| # | 7| dev| 5200|[3400, 3700, 4400...| 4220.0| 21100| # | 3|sales| 4000| [4000, 4000]| 4000.0| 8000| # | 4|sales| 4000| [4000, 4000]| 4000.0| 8000| # | 1|sales| 4200| [4000, 4000, 4200]|4066.6666666666665| 12200| # | 5|admin| 2700| [2700]| 2700.0| 2700| # | 2|admin| 3100| [2700, 3100]| 2900.0| 5800| # +---+-----+------+--------------------+------------------+------------+ 注：注意观察id9\u002610的重复工资，相等的工资条将导致工资前缀和的同时扫描。请看下问一个更贴切实际的前缀和实例。 Q4: Q3问题不变（相等的工资先后扫描）。(rowsBetween) windowSpec = Window.partitionBy('dept').orderBy(F.asc('salary'))\\ .rowsBetween(Window.unboundedPreceding, Window.currentRow) df = df.withColumn('list_salary', F.collect_list(F.col('salary')).over(windowSpec))\\ .withColumn('average_salary', F.avg(F.col('salary')).over(windowSpec))\\ .withColumn('total_salary', F.sum(F.col('salary')).over(windowSpec)).show() # +---+-----+------+--------------------+------------------+------------+ # | id| dept|salary| list_salary| average_salary|total_salary| # +---+-----+------+--------------------+------------------+------------+ # | 6| dev| 3400| [3400]| 3400.0| 3400| # | 8| dev| 3700| [3400, 3700]| 3550.0| 7100| # | 9| dev| 4400| [3400, 3700, 4400]|3833.3333333333335| 11500| # | 10| dev| 4400|[3400, 3700, 4400...| 3975.0| 15900| # | 7| dev| 5200|[3400, 3700, 4400...| 4220.0| 21100| # | 3|sales| 4000| [4000]| 4000.0| 4000| # | 4|sales| 4000| [4000, 4000]| 4000.0| 8000| # | ","date":"2020-09-03","objectID":"/spark-practice-101/:2:0","tags":["spark"],"title":"Spark 101: DataFrame基本使用","uri":"/spark-practice-101/"},{"categories":null,"content":"Example 3. Join与Skew Join join可以把两张表内关键字匹配的数据做笛卡尔乘积，放入结果表。 参考： Medium, 6 spark exercises to rule them all 数据集：三张表sales, products, sellers, 大约6GB，使用local模式。 Q1: 三张表各有多少记录？(parquet, count) DATASET_PATH = './DatasetToCompleteTheSixSparkExercises' products = spark.read.parquet(f'{DATASET_PATH}/products_parquet') sales = spark.read.parquet(f'{DATASET_PATH}/sales_parquet') sellers = spark.read.parquet(f'{DATASET_PATH}/sellers_parquet') sales.count(), products.count(), sellers.count() # (20000040, 75000000, 10) Q2: 有多少种商品至少被卖出过一次？(distinct) sales.select(['product_id']).distinct().count() # 993429 Q3: 订单中最常见的商品是哪个？(sort, limit) sales.groupby(['product_id']).count().sort('count', ascending=False).limit(1).show() # +----------+--------+ # |product_id| count| # +----------+--------+ # | 0|19000000| # +----------+--------+ Q4: 统计sales中product_id的分布情况 (groupby, groupby) key_stats = sales.groupby('product_id').count().withColumnRenamed('count', 'pid_count')\\ .groupby('pid_count').count().toPandas() key_stats = key_stats.sort_values('pid_count') key_stats['frequency'] = key_stats['count'] / sum(key_stats['count']) key_stats['cum_freq'] = np.cumsum(key_stats['frequency']) key_stats # 先通过groupby得到key size， 再按照小key到大key排列，最后通过groupby统计每个key size的数量 # pid_count count frequency cum_freq # 0 1 986847 0.993374 0.993374 # 2 2 6550 0.006593 0.999968 # 1 3 31 0.000031 0.999999 # 3 19000000 1 0.000001 1.000000 plt.plot(np.log10(key_stats['pid_count']), key_stats['cum_freq']) Q5: 每天各卖多少种商品？(countDistinct) sales.groupby(['date']).agg(F.countDistinct(\"product_id\").alias(\"cnt\")).sort(\"cnt\", ascending=False).show() # +----------+------+ # | date| cnt| # +----------+------+ # |2020-07-06|100765| # |2020-07-09|100501| # |2020-07-01|100337| # |2020-07-03|100017| # |2020-07-02| 99807| # |2020-07-05| 99796| # |2020-07-04| 99791| # |2020-07-07| 99756| # |2020-07-08| 99662| # |2020-07-10| 98973| # +----------+------+ Q6: 求订单盈利（数量x价格）的平均值。(join, skewed data) 由于订单中的商品集中在少数商品ID，使用product_id进行join会造成skewed data,降低并行效率。 df = sales.join(products, on='product_id') df = df.withColumn('revenue', sales['num_pieces_sold'] * products['price']) df.select(F.avg('revenue')).show() # +------------------+ # | avg(revenue)| # +------------------+ # |1246.1338560822878| # +------------------+ 可以对product常见key加盐，可以先join两表加盐的key部分，再join两表未加盐的普通key部分，最后union。这样可以把集中分布的key加盐溶解，提高集群的并行效率。 def skew_join(skew_df, other_df, on, topK, how='inner', SALT_RANGE=100): # STEP1: find topK popular keys in skew_df topKkey = skew_df.groupby(on).agg({'*': 'count'}).withColumnRenamed('count(1)', '_skew_key_cnt')\\ .sort('_skew_key_cnt', ascending=False).limit(topK) # STEP2: split skew_df, other_df into pop and unpop halves skew_df_pop = skew_df.join(F.broadcast(topKkey), on=on).drop('_skew_key_cnt') skew_df_unpop = skew_df.join(F.broadcast(topKkey), on=on, how='left_anti').drop('_skew_key_cnt') other_df_pop = other_df.join(F.broadcast(topKkey), on=on).drop('_skew_key_cnt') other_df_unpop = other_df.join(F.broadcast(topKkey), on=on, how='left_anti').drop('_skew_key_cnt') # STEP3: salt skew_df_pop, replicate other_df_pop skew_df_pop = skew_df_pop.withColumn('_skew_salt', (F.rand() * SALT_RANGE).cast(types.IntegerType())) other_df_pop = other_df_pop.withColumn('_skew_salts', F.array([F.lit(i) for i in range(SALT_RANGE+1)])) other_df_pop = other_df_pop.select('*', F.explode('_skew_salts').alias('_skew_salt')).drop('_skew_salts') # STEP4: join seperately and union res_pop = skew_df_pop.join(other_df_pop, on=on+['_skew_salt'], how=how).drop('_skew_salt') res_unpop = skew_df_unpop.join(other_df_unpop, on=on, how=how) return res_pop.union(res_unpop) df = skew_join(sales, products, on=['product_id'], topK=10) df = df.withColumn('revenue', sales['num_pieces_sold'] * products['price']) df.select(F.avg('revenue')).show() # +------------------+ # | avg(revenue)| # +------------------+ # |1246.1338560822878| # +------------------+ Q7: 对每个销售员，求一个订单对其目标的平均贡献。(broadcast) 注：比如销售员0目标250件总共拥有三笔订单，订单1卖10件，订单2卖8件，订单3卖7件。那么每张订","date":"2020-09-03","objectID":"/spark-practice-101/:3:0","tags":["spark"],"title":"Spark 101: DataFrame基本使用","uri":"/spark-practice-101/"},{"categories":null,"content":"Example 4. UDF Q1: 在sales数据中创建列，根据order_id和bill_raw_text计算每条销售数据bill的hash值，并查看是否有hash冲突。(udf) hash规则： 当order_id为奇数，计算sha256；当order_id为偶数时，迭代计算md5，迭代次数为大写A出现的次数。 import hashlib from pyspark.sql.types import StringType def fancy_hash(order_id, bill_raw_text): res = bill_raw_text.encode('utf-8') # 1) even case if int(order_id) % 2 == 0: cnt_A = bill_raw_text.count('A') for _ in range(cnt_A): res = hashlib.md5(res).hexdigest().encode('utf-8') res = res.decode('utf-8') else: res = hashlib.sha256(res).hexdigest() return res # Convert the fancy_hash python function into its UDF fancy_hash_udf = F.udf(lambda arg1, arg2: fancy_hash(arg1, arg2), StringType()) sales.withColumn('hashed_bill', fancy_hash_udf(sales['order_id'], sales['bill_raw_text']))\\ .groupby('hashed_bill').agg(F.count('*').alias('cnt')).filter(F.col('cnt') \u003e 1).show() # 返回为空，即无哈希冲突 ","date":"2020-09-03","objectID":"/spark-practice-101/:4:0","tags":["spark"],"title":"Spark 101: DataFrame基本使用","uri":"/spark-practice-101/"},{"categories":null,"content":"Example 5. UDF 数据集DataFrame [startDate: timestamp, binaryIds: array\u003cbigint\u003e] 寻找最新的100个binaryId ","date":"2020-09-03","objectID":"/spark-practice-101/:5:0","tags":["spark"],"title":"Spark 101: DataFrame基本使用","uri":"/spark-practice-101/"},{"categories":null,"content":"什么是数据倾斜？ 对于Spark/Hadoop等分布式系统，机器间工作量的不均匀比单纯的工作量大更难处理，因为单纯的工作量大基本通过scale-out就可以解决。假设有100个任务并行处理，若任务间工作量相当，20台机器要比10台机器耗时减半（假设机器性能相当）。然而当任务间工作量相差巨大时（例如，任务中10个大任务，90个小任务，工作量差别1M倍），很难通过scale-out的方式充分利用并行优势，此时，完成总耗时取决于最慢的大任务何时完成（木桶原理）。 对于Spark这种计算引擎，工作量主要在于所需处理的数据量。因此当任务划分时，数据分布不均匀，即发生了数据倾斜。 ","date":"2020-08-30","objectID":"/spark-data-skew/:1:0","tags":["spark"],"title":"Spark: 解决数据倾斜的N种姿势","uri":"/spark-data-skew/"},{"categories":null,"content":"数据是如何倾斜的？ 当Spark产生shuffle操作时，相同key的数据会被放在相同的partition。因此当某一个key的数据量过大（即popular key），会造成partition间工作量巨大差别，造成数据倾斜。这样不仅影响了并行效率，更加容易造成内存不足，产生OOM（Out Of Memory）报错使整个应用崩溃。 常见会触发shuffle的算子：distinct, groupByKey, reduceByKey, aggregateByKey, join, cogroup, repartition。 ","date":"2020-08-30","objectID":"/spark-data-skew/:2:0","tags":["spark"],"title":"Spark: 解决数据倾斜的N种姿势","uri":"/spark-data-skew/"},{"categories":null,"content":"如何识别数据倾斜？ 观察stage进度条，发现大多数task很快执行完，但是剩余task等待时间巨长甚至出现OOM报错。（如上图） 查看Spark Web UI里的Shuffle Read Size/Records，查看任务间数据量分布是否均匀。 计算key的分布。（如下） df.select(\"key\").sample(false, 0.1) // 数据采样 .(k =\u003e (k, 1)).reduceBykey(_ + _) // 统计 key 出现的次数 .map(k =\u003e (k._2, k._1)).sortByKey(false) // 根据 key 出现次数进行排序 .take(10) // 取前 10 个。 ","date":"2020-08-30","objectID":"/spark-data-skew/:3:0","tags":["spark"],"title":"Spark: 解决数据倾斜的N种姿势","uri":"/spark-data-skew/"},{"categories":null,"content":"发生了数据倾斜怎么办？ ","date":"2020-08-30","objectID":"/spark-data-skew/:4:0","tags":["spark"],"title":"Spark: 解决数据倾斜的N种姿势","uri":"/spark-data-skew/"},{"categories":null,"content":"思路1 - 过滤异常数据 如果数据包含大量异常key，过滤掉就好了。 异常key： 空值 Null 无效数据，大量重复的测试数据或是对结果影响不大的有效数据 有效数据，业务导致的正常数据分布 对于情况1\u00262，直接过滤即可。对于3，直接过滤不适用，尝试以下其他方法。 ","date":"2020-08-30","objectID":"/spark-data-skew/:4:1","tags":["spark"],"title":"Spark: 解决数据倾斜的N种姿势","uri":"/spark-data-skew/"},{"categories":null,"content":"思路2 - 提高shuffle并行度 通过增加partition的方法，让每个task执行更少的不同key，把原本被分配到同一task的不同key分配到不同task。 RDD 操作 可在需要 Shuffle 的操作算子上直接设置并行度或者使用 spark.default.parallelism 设置。如果是 Spark SQL，还可通过 SET spark.sql.shuffle.partitions=[num_tasks] 设置并行度。默认参数由不同的 Cluster Manager 控制。 dataFrame 和 sparkSql 可以设置 spark.sql.shuffle.partitions=[num_tasks] 参数控制 shuffle 的并发度，默认为200。 TIPS 可以把数据倾斜类比为 hash 冲突。提高并行度就类似于 提高 hash 表的大小。 ","date":"2020-08-30","objectID":"/spark-data-skew/:4:2","tags":["spark"],"title":"Spark: 解决数据倾斜的N种姿势","uri":"/spark-data-skew/"},{"categories":null,"content":"思路3 - 自定义Partitioner ","date":"2020-08-30","objectID":"/spark-data-skew/:4:3","tags":["spark"],"title":"Spark: 解决数据倾斜的N种姿势","uri":"/spark-data-skew/"},{"categories":null,"content":"思路4 - Broadcast机制 对于Join算子，若一边数据足够小到放入内存，可以通过Broadcast方法广播到Worker中。这样的Broadcast Join完全避免了shuffle，彻底消除了数据倾斜产生的条件。 from pyspark.sql.functions import broadcast result = broadcast(A).join(B, [\"join_col\"], \"left\") ","date":"2020-08-30","objectID":"/spark-data-skew/:4:4","tags":["spark"],"title":"Spark: 解决数据倾斜的N种姿势","uri":"/spark-data-skew/"},{"categories":null,"content":"思路5 - 拆分join再union 对于Join算子，若一边数据倾斜，另一边数据均匀，且无法map端join（broadcast），可以把两边大表各拆分为popular key与unpopular key部分，分别join再union。 join例子： left （数据倾斜）和 right（数据均匀） 采样统计left中Top K popular key，把两表按照key是否popular分拆 left = leftSkew + leftUnskew right = rightSkew + rightUnskew 左加盐，右膨胀 对leftSkew加盐，即key -\u003e (key, rand(N)), 这样大key会被分配到不同partition 对rightSkew做flatMap操作把每条数据转化为N条数据，即key -\u003e (key, 1), (key, 2), ... (key, N) 分别join再union，即Union ( Join(leftSkew, rightSkew), Join(leftUnskew, rightUnskew) ) ","date":"2020-08-30","objectID":"/spark-data-skew/:4:5","tags":["spark"],"title":"Spark: 解决数据倾斜的N种姿势","uri":"/spark-data-skew/"},{"categories":null,"content":"思路6 - 大表key加盐，小表扩大N倍join 对于数据倾斜表中key都很大的情况，分拆popular key与unpopular key意义不大。可直接对大表整体加盐，小表扩大N倍后再join，即此思路为思路5的局部优化Join(leftSkew, rightSkew)。 例子 创建两个表来模拟，其中大表数据倾斜，小表相对均匀 from math import exp from random import randint from datetime import datetime def count_elements(splitIndex, iterator): n = sum(1 for _ in iterator) yield (splitIndex, n) def get_part_index(splitIndex, iterator): for it in iterator: yield (splitIndex, it) num_parts = 18 # create the large skewed rdd skew_rdd = sc.parallelize(range(0,num_parts), num_parts).flatMap(lambda x: range(0, int(exp(x)))) skew_rdd = skew_rdd.mapPartitionsWithIndex(lambda idx, x: get_part_index(idx, x)) skew_df = spark.createDataFrame(skewed_large_rdd,['x','y']) small_rdd = sc.parallelize(range(0,num_parts), num_parts).map(lambda x: (x, x)) small_df = spark.createDataFrame(small_rdd,['a','b']) # skew_df: small_df: # x, y a, b # ==== ==== # 0, 0 0, 0 # 1, 0 1, 1 # 1, 1 2, 2 # 2, 0 3, 3 # 2, 1 4, 4 # 2, 2 5, 5 # 2, 3 6, 6 # 2, 4 7, 7 # 2, 5 8, 8 # 2, 6 9, 9 # ... ... 大表key加盐，小表扩大N（=100）倍 salt_bins = 100 from pyspark.sql import functions as F skew_df_salt = skew_df.withColumn('salt', (F.rand()*salt_bins).cast('int')).cache() small_df_rep = small_df.withColumn('replicate', F.array([F.lit(i) for i in range(salt_bins)])) small_df_rep = small_df_rep.select('*', F.explode('replicate').alias('salt')).drop('replicate').cache() # skew_df: small_df: # x, y, salt a, b, salt # ========== ========== # 0, 0, 24 0, 0, 0 # 1, 0, 53 0, 0, 1 # 1, 1, 24 0, 0, 2 # 2, 0, 37 0, 0, 3 # 2, 1, 99 0, 0, 4 # 2, 2, 87 0, 0, 5 # 2, 3, 14 0, 0, 6 # 2, 4, 94 0, 0, 7 # 2, 5, 12 0, 0, 8 # 2, 6, 5 0, 0, 9 # ... ... 最后join %%time # measure excution time in jupyter notebook res = skew_df_salt.join(small_df_rep, (skew_df_salt['x'] == small_df_rep['a'])\\ \u0026 (skew_df_salt['salt'] == small_df_rep['salt'])) res.count() # res: # x, y, b # ========= # 0, 0, 0 # 1, 0, 1 # 1, 1, 1 # 2, 0, 2 # 2, 1, 3 # 2, 2, 2 # 2, 3, 2 # 2, 4, 2 # 2, 5, 2 # 2, 6, 2 # ... ","date":"2020-08-30","objectID":"/spark-data-skew/:4:6","tags":["spark"],"title":"Spark: 解决数据倾斜的N种姿势","uri":"/spark-data-skew/"},{"categories":null,"content":"思路7 - map端先局部聚合 ","date":"2020-08-30","objectID":"/spark-data-skew/:4:7","tags":["spark"],"title":"Spark: 解决数据倾斜的N种姿势","uri":"/spark-data-skew/"},{"categories":null,"content":"思路8 - 加盐局部聚合 + 去盐全局聚合 ","date":"2020-08-30","objectID":"/spark-data-skew/:4:8","tags":["spark"],"title":"Spark: 解决数据倾斜的N种姿势","uri":"/spark-data-skew/"},{"categories":null,"content":"参考 Arganzheng’s Blog, Spark数据倾斜及其解决方案 ","date":"2020-08-30","objectID":"/spark-data-skew/:5:0","tags":["spark"],"title":"Spark: 解决数据倾斜的N种姿势","uri":"/spark-data-skew/"},{"categories":null,"content":"什么是Job, Stage, Task? Spark数据处理是像流水线一样，通过一系列操作（算子）完成对RDD的处理, 即RDD1 -\u003e RDD2 -\u003e ...。操作分为两类：Transformation和Action。Spark使用lazy evaluation模式，即Transformation操作下达后，实际并不立刻运行，只有当遇到Action时才把之前所有的Transformation和当前Action运行完毕。每当一个Action触发，就会生成一个Job。因此Job以Action划分。Job之间是串行的，只有当前job结束，才会启动下一个job。 一个Job会被划分为一个或多个stage。在一个stage中，任务是可以并行计算的。stage是按照ShuffleDependency来进行划分的。两种依赖方式为窄依赖（narrow dependency）与宽依赖（wide dependency）。区分两种依赖的方法是看：父RDD的partition是否被多个（\u003e1）子RDD的partition使用，若未被多个子RDD的partition使用，则为窄依赖，不需shuffle，不划分stage； 否则为宽依赖，划分stage。上图对比了两种依赖方式的不同。具体划分stage的算法是: 从最后一个RDD开始，从后往前推，找该RDD和父RDD之间的依赖关系，如果是窄依赖，会继续找父RDD的父RDD，如果是宽依赖，就会从该RDD开始到前面所有的RDD划分为一个stage，递归的出口是直到找不到父RDD，最后把所有的RDD划分为一个stage。 一个例子： 一个stage并行的任务称为task，对应一个partition的处理，即task总数为stage的partition总数。 ","date":"2020-08-29","objectID":"/spark-fundamentals/:1:0","tags":["spark"],"title":"Spark FAQ","uri":"/spark-fundamentals/"},{"categories":null,"content":"参考 Wide vs Narrow Dependencies github blog stackoverflow, Does stages in an application run parallel in spark Queirozf Apache Spark Architecture Overview: Jobs, Stages, Tasks, etc cnblogs, qingyunzong csdn, Z_Data Spark by Examples, Spark Repartition vs Coalesce Arganzheng’s Blog, Spark数据倾斜及其解决方案 ","date":"2020-08-29","objectID":"/spark-fundamentals/:2:0","tags":["spark"],"title":"Spark FAQ","uri":"/spark-fundamentals/"},{"categories":null,"content":"目录结构 /bin (/usr/bin, /usr/local/bin): binary,存放最经常使用的命令 /sbin (/usr/sbin, /usr/local/sbin): s: super user, 存放系统管理员使用的系统管理程序 /home: 存放普通用户的主目录，每个用户都有一个自己的目录 /root: 超级权限者的用户主目录(This is not the root (/) filesystem. It is the home directory for the root user.) /lib: 系统开机所需要最基本的动态连接共享库，类似Windows的DLL文件。几乎所有应用程序都需要用到这些共享库 /etc: 系统管理所需要的配置文件和子目录 /usr: 用户的很多应用程序和文件都放在这个目录下，类似Windows的program files目录 /proc,/srv,/sys: 内核相关目录（不要轻易修改） /dev: 硬件以文件的形式存放在该处 /media: U盘，光驱，等等 /mnt: 用户临时挂载的文件系统 /opt: 存放安装软件 /usr/local: 存放安装软件所安装的目录，一般是通过编译源码的方式安装的程序 /var: 存放经常被修改的东西，比如日志文件 ","date":"2020-08-19","objectID":"/linux-intro/:1:0","tags":["linux"],"title":"Linux入门","uri":"/linux-intro/"},{"categories":null,"content":"Vi/Vim快捷键 拷贝当前行yy, 拷贝当前行以下的5行5yy,粘贴p 删除当前行dd, 删除当前行以下的5行5dd 查找关键词/keyword,下一个出现n 显示行号:set nu,隐藏行号:set nonu 阅览最首行gg最末行G 撤销输入动作u 移动光标至第20行20+shift g ","date":"2020-08-19","objectID":"/linux-intro/:2:0","tags":["linux"],"title":"Linux入门","uri":"/linux-intro/"},{"categories":null,"content":"开关重启命令 sync # 把内存数据同步到磁盘，以下操作前先执行该命令 shutdown -h now # 立即关机 shutdown -h 1 # 1min 关机 shutdown -r now # 立即重启 halt # 等同于关机 reboot # 立即重启 ","date":"2020-08-19","objectID":"/linux-intro/:3:0","tags":["linux"],"title":"Linux入门","uri":"/linux-intro/"},{"categories":null,"content":"用户管理 useradd xiaoming # 自动创建home下同名目录 passwd xiaoming # 指定密码 userdel xiaoming # 删除用户xiaoming，home下其目录会保留 userdel -r xiaoming # 删除用户xiaoming，home下其目录不会保留 su - xiaoming # 切换用户登陆， 权限不足会给提示，exit返回到原先用户 groupadd zuming # 创建组 groupdel zuming # 删除组 useradd -g zuming xiaoming # 创建用户时，指定组 id xiaoming # 查询用户信息 usermod -g zuming2 xiaoming # 修改用户所在组 用户配置文件在： /etc/passwd （用户id，组id，家目录，shell） 组配置文件在：/etc/group 口令配置文件（密码，登录信息）：/etc/shadow(加密的) ","date":"2020-08-19","objectID":"/linux-intro/:4:0","tags":["linux"],"title":"Linux入门","uri":"/linux-intro/"},{"categories":null,"content":"实用命令 man ls # 显示ls用法 help cd # 显示cd用法 touch filename # 创建空文件 cat -n filename ｜ more # 打开文件内容（只读方式）, -n 显示行号，more分页显示 more filename # 按页显示文件，空格翻页，Enter下一行，ctrl+f/b less filename # 分页查看，lazy加载，利于显示大文件 \"less is more\" ls -l \u003e filename # 重定向（覆盖） ls -l \u003e\u003e filename # 追加（append到尾部） head -n 5 filename # 只显示文件前5行（默认10行） tail -n 5 filename # 只显示文件后5行（默认10行） -f追踪文件更新，日志监控经常用 date \"+%Y-%m-%d %H:%M:%S\" # 按格式显示当前年月日时分秒，“+”必要， -s设定 cal # 显示当前日历 find [scope] [-name 文件名, -user 用户, -size 文件大小] grep [-n 显示匹配行行号， -i 忽略大小写] 查找内容 源文件 cat hello.txt | grep -ni yes # 在hello.txt中，不区分大小写的查找yes grep -r [keyword] /data/reports zip -r xxx.zip files unzip -d 位置 xxx.zip tar -zcvf a.tar.gz a1.txt a2.txt tar -zxvf a.tar.gz ","date":"2020-08-19","objectID":"/linux-intro/:5:0","tags":["linux"],"title":"Linux入门","uri":"/linux-intro/"},{"categories":null,"content":"组管理，权限管理 在linux中的每个用户必须属于一个组，不能独立于组外。在linux中每个文件有所有者，所在组，其他组的概念。 ","date":"2020-08-19","objectID":"/linux-intro/:6:0","tags":["linux"],"title":"Linux入门","uri":"/linux-intro/"},{"categories":null,"content":"任务调度 crontab -e crontab -l crontab -r 45 22 * * * 在22点45分执行 0 17 * * 1 每周一17点0分执行 0 5 1,15 * * 每月1号15号凌晨5点执行 40 4 * * 1-5 每周一到周五凌晨4点40分执行 */10 4 * * * 每天凌晨4点每隔10分执行一次 0 0 1,15 * 1 每月1号和15号，每周一的0点0分执行。星期几和几号最好不要同时出现，容易混乱 ","date":"2020-08-19","objectID":"/linux-intro/:7:0","tags":["linux"],"title":"Linux入门","uri":"/linux-intro/"},{"categories":null,"content":"进程管理 ps -a/u/x | more ps -ef | grep sshd # 查看sshd的父进程ID kill [pid] pstree -p top netstat -anp | more # 查看网络服务 USER 用户名称 PID 进程号 %CPU 进程占用CPU的百分比 %MEM 进程占用物理内存的百分比 VSZ 进程占用的虚拟内存大小（KB） RSS 进程占用的物理内存大小（KB） TT 终端名称 STAT 进程状态 S-睡眠 R-正在运行 Z-僵死 STARTED 进程的启动时间 TIME 使用CPU总时间 COMMAND 启动进程的命令和参数 ","date":"2020-08-19","objectID":"/linux-intro/:8:0","tags":["linux"],"title":"Linux入门","uri":"/linux-intro/"},{"categories":null,"content":"服务管理 开机流程： 开机 -\u003e BIOS -\u003e /boot -\u003e init process (1) -\u003e 运行级别 -\u003e 运行级别对应的服务 service [service name] start|stop|restart|reload|status ls -l /etc/init.d chkconfig --list 服务的运行级别(runlevel)： 运行级别0: 系统停机状态，系统默认运行级别不能设为0，否则不能正常启动 运行级别1: 单用户工作状态，root权限，用于系统维护，禁止远程登录 运行级别2: 多用户状态（没有NFS），不支持网络 运行级别3: 完全的多用户状态（有NFS），登陆后进入控制台命令行模式 运行级别4: 系统未使用，保留 运行级别5: X11控制台，登陆后进入图形GUI模式 运行级别6: 系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动 ","date":"2020-08-19","objectID":"/linux-intro/:9:0","tags":["linux"],"title":"Linux入门","uri":"/linux-intro/"},{"categories":null,"content":"Ubuntu su root # 切换root用户，因为初始root未设置密码，提示错误 sudo passwd # 设置root密码 su root # 切换root用户，设置root密码后可以成功切换 ","date":"2020-08-19","objectID":"/linux-intro/:10:0","tags":["linux"],"title":"Linux入门","uri":"/linux-intro/"},{"categories":null,"content":"什么是精确率（precision）与召回率（recall）？ Precision和Recall是衡量模型预测能力的指标。在简单的分类问题（种类数=2）中，根据实际答案与模型预测，可分为如下4种情况： True Positive (TP) - 正确预测了阳类 True Negative (TN) - 正确预测了阴类 False Positive (FP) - 错误预测了阳类（实际为阴类） False Negative (FN) - 错误预测了阴类（实际为阳类） 注：True和False表示预测是否正确，Positive和Negative表示预测结果 精准率和召回率定义： Precision = TP / (TP + FP) Recall = TP / (TP + FN) 他们区别在分母不同，所取值范围均为0～1 ","date":"2020-08-12","objectID":"/precision-recall/:1:0","tags":["Machine Learning"],"title":"Precision和Recall","uri":"/precision-recall/"},{"categories":null,"content":"如何理解Precision和Recall？ 信息检索中，Precision又叫查准率（找得对），Recall又叫查全率（找得全）。 举个例子，池塘有大龙虾30只，小龙虾70只。我们发明了一只捕大龙虾神器专捕大龙虾。神器一网下去，捕到大龙虾20只，小龙虾5只。那么： 精准率 = 20 /（20 + 5） = 0.80 召回率 = 20 / 30 = 0.67 我们来看3个极端神器的Precision和Recall。 神器谨慎版：只捕了一只，且为大龙虾。Precision = 1/1 = 1.0, Recall = 1/30 = 0.033 神器电鱼版：捕了全池塘的100只。Precision = 30/100 = 0.3, Recall = 30/30 = 1.0 神器专业版：补了30只，且全为大龙虾。Precision = 30/30 = 1.0, Recall = 30/30 = 1.0 实际应用中，Precision和Recall往往不能兼得。有时我们更在意Precision，而有时我们更在意Recall。比如判断视频是否适合儿童观看（适合-正，不适合-负），我们更青睐high precision - low recall的分类器（声称安全的视频真是安全的，但可能也拦截了其他安全的视频）。再比如报警器判断是否有小偷（有小偷-正，无小偷-负），我们更青睐low precision - high recall的警报器（声称有小偷的时候可能是误报，但是真有小偷的时候它通常会响）。 ","date":"2020-08-12","objectID":"/precision-recall/:2:0","tags":["Machine Learning"],"title":"Precision和Recall","uri":"/precision-recall/"},{"categories":null,"content":"PR曲线 机器学习模型往往先预测概率（scoring），再根据概率决策分类（label）。比如score高于threshold输出positive，低于输出negative。这样Precision与Recall将是Threshold的函数，即P(t)和R(t)。如果把P(t)和R(t)作为坐标画在坐标中,就形成了PR曲线，其中(1,1)为理想点。我们可以用PR曲线下的面积（AUPR）来衡量模型表现。 相比于ROC曲线，PR曲线对不平衡数据集的性能描述更为准确。 ","date":"2020-08-12","objectID":"/precision-recall/:3:0","tags":["Machine Learning"],"title":"Precision和Recall","uri":"/precision-recall/"},{"categories":null,"content":"参考 如何解释召回率与精确率？ - 知乎 推荐系统评测指标—准确率(Precision)、召回率(Recall)、F值(F-Measure) ","date":"2020-08-12","objectID":"/precision-recall/:4:0","tags":["Machine Learning"],"title":"Precision和Recall","uri":"/precision-recall/"},{"categories":null,"content":"什么是Cookie ","date":"2020-08-09","objectID":"/cookie-track-user/:1:0","tags":["AdTech"],"title":"网络广告是如何用cookie来追踪用户的？","uri":"/cookie-track-user/"},{"categories":null,"content":"参考 Web客户端追踪(上)-Cookie追踪 网络广告代理商是如何通过 cookie 收集用户信息的？ - LO的回答 - 知乎 RTB广告竞价系统的算法介绍 你是如何被广告跟踪的？ - 巴伐利亚啤酒馆的文章 - 知乎 第一方Cookie和第三方Cookie 第一方Cookie与第三方Cookie的区别 第一方和第三方cookie是什么？ ETP,ITP,NO-TP,是时候把第三方Cookie讲清楚了 ","date":"2020-08-09","objectID":"/cookie-track-user/:2:0","tags":["AdTech"],"title":"网络广告是如何用cookie来追踪用户的？","uri":"/cookie-track-user/"},{"categories":null,"content":"PySpark的特性 Immutable Changes create new object references Old versions are unchanged Lazy Compute does not happen until output is requested ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:1:0","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"Pandas VS PySpark ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:2:0","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"Load CSV # Pandas df = pd.read_csv(\"datafile.csv\") # PySpark df = spark.read.options(header=True, inferSchema=True).csv(\"datafile.csv\") ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:2:1","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"View Dataframe # Pandas df # PySpark df.show() ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:2:2","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"Columns \u0026 Data Types # Pandas df.columns df.dtypes # PySpark df.columns df.dtypes ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:2:3","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"Rename Columns # Pandas df.columns = ['a', 'b', 'c'] df.rename(columns = {'old': 'new'}) # PySpark df.toDF('a', 'b', 'c') df.withColumnRenamed('old', 'new') ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:2:4","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"Drop Columns # Pandas df.drop('colx', axis=1) # PySpark df.drop('colx') ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:2:5","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"Filtering # Pandas df[df.col1 \u003c 20] df[(df.col1 \u003c 20) \u0026 (df.col2 == 6)] # 注意括号 # PySpark df[df.col1 \u003c 20] df[(df.col1 \u003c 20) \u0026 (df.col2 == 6)] # 注意括号 ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:2:6","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"Add Column # Pandas df['col3'] = 1 / df.col1 # 除以0得infty # PySpark df.withColumn('col3', 1 / df.col1) # 除以0得Null ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:2:7","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"Fill Nulls # Pandas df.fillna(0) # more options # PySpark df.fillna(0) ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:2:8","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"Aggregation # Pandas df.groupby(['col1', 'col2']).agg({'col3': 'mean', 'col4': 'min'}) # PySpark df.groupby(['col1', 'col2']).agg({'col3': 'mean', 'col4': 'min'}) ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:2:9","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"标准的转化 # Pandas import numpy as np df['logCol'] = np.log(df.col) # PySpark import pyspark.sql.functions as F df.withColumn('logCol', F.log(df.col)) 使用pyspark.sql.functions里的函数，可以直接调用JVM，即Java引擎，而非使用较慢的python。 例子Row Conditional Statements # Pandas df['status'] = df.apply(lambda r: 1 if r.col1 \u003e 20 else 2 if r.col2 == 6 else 3, axis=1) # PySpark import pyspark.sql.functions as F df.withColumn('status', \\ F.when(df.col1 \u003e 20, 1) \\ .when(df.col2 == 6, 2) \\ .otherwise(3)) ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:3:0","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"更复杂的转化，python必要时 # Pandas df['col5'] = df.col1.apply(lambda x : x + 1) # PySpark import pyspark.sql.functions as F from pyspark.sql.types import DoubleType # udf必须deterministic，pyspark优化默认相同运算结果相同 fn = F.udf(lambda x : x + 1, DoubleType()) df.withColumn('col5', fn(df.col1)) ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:4:0","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"Join # Pandas leftDF.merge(rightDF, on='key') leftDF.merge(rightDF, left_on='a', right_on='b') # PySpark leftDF.join(rightDF, on='key') leftDF.join(rightDF, leftDF.a == rightDF.b) 默认为inner join ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:5:0","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"统计 # Pandas df.describe() # PySpark df.describe().show() df.selectExpr(\"percentile_approx(col1, array(.25, .5, .75)) as col1\").show() ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:6:0","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"统计图 # Pandas df.hist() # PySpark df.sample(False, 0.1).toPandas().hist() ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:7:0","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"SQL # Pandas NA # PySpark df.createOrReplaceTempView('foo') df2 = spark.sql('select * from foo') ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:8:0","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"使用习惯 使用pyspark.sql.functions内置函数。 在cluster中保持和driver相同的版本和库。 观测状态http://localhost:4040/ Learn about SSH port forwarding 不要： Try to iterate through rows Hard code a master in your dirver Use spark-submit for that df.toPandas().head() instead do: df.limit(5).toPandas() 参考 Spark Submit 2017 ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:9:0","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"1. Git概述 Git这种分布式版本控制工具，客户端提取的不是最新版本的文件快照，而是把代码仓库完整地镜像下来（本地库）。这样任何一处协同工作用的文件发生故障，事后都可以用其他客户端的本地仓库进行恢复。因为每个客户端的每一次文件提取操作，实际上都是一次对整个文件仓库的完整备份。 ","date":"2020-07-28","objectID":"/git-github/:1:0","tags":["git"],"title":"Git与Github使用","uri":"/git-github/"},{"categories":null,"content":"2. 常用命令 设置用户签名 git config --global user.name 用户名 设置用户签名 git config --global user.email 邮箱 注意：这里设置用户签名和将来登陆Github的账号没有任何关系。 初始化本地库 git init 查看本地库状态 git status 将工作区的文件添加到暂存区 git add 文件名 将暂存区的文件提交到本地库 git commit -m \"日志信息\" 文件名 查看版本信息（HEAD经过的历史记录） git reflog 查看版本详细信息 git log 版本穿梭 git reset --hard 版本号 （版本号可以通过git reflog查询）通过HEAD^或HEAD~移动HEAD到相对位置 注意：上图中，链表结构从新版本指向旧版本，merge情况下指向两个父（旧）版本。 勘误：命令行结果中版本号应为i8fe5。左图中未显示8d83a版本号。 ","date":"2020-07-28","objectID":"/git-github/:2:0","tags":["git"],"title":"Git与Github使用","uri":"/git-github/"},{"categories":null,"content":"3. 分支操作 查看分支 git branch -v 创建分支 git branch 分支名 切换分支 git checkout 分支名 合并分支 git merge 分支名（在master分支上，合并hot-fix分支） 删除分支 git branch -d 分支名 冲突产生的原因：合并分支时，两个分支在同一个文件的同一个位置有两套完全不同的修改。Git无法替我们决定使用哪一个。必须人为决定新代码内容。 冲突 \u003c\u003c\u003c\u003c\u003c\u003c\u003c HEAD abc (当前分支修改) ======= def (并入分支修改) \u003e\u003e\u003e\u003e\u003e\u003e\u003e hot-fix 注意：人为决定采用哪种修改后，仍然需要git add与git commit使得合并过程从merging到merged状态。 理解底层指针：Head指针指向分支名（如master），master指针指向版本号 ","date":"2020-07-28","objectID":"/git-github/:3:0","tags":["git"],"title":"Git与Github使用","uri":"/git-github/"},{"categories":null,"content":"4. 团队协作机制 查看本地保存到远程库地址 git remove -v 给远程库起别名 git remove add 别名 远程地址 例如git remote add origin https://github.com/username/reponame.git 将本地当前分支推送到远程某分支 git push 远程库别名 远程库分支 例如 git push origin master 将远程某分支拉取到本地当前分支 git pull 远程库别名 远程库分支 例如 git pull origin master 取得远程库某分支 git fetch 远程库别名 远程库分支 例如 git fetch origin master 克隆远程库到本地 git clone 远程库地址 （clone会做三件事：1.拉取代码 2.初始化本地库 3. 创建别名） 注意：push是将本地库代码推送到远程库，如果本地库代码跟远程库代码版本不一致，push的操作是会被拒绝的。也就是说，要想push成功，一定要保证本地库的版本要比远程库的版本高！因此一个成熟的程序员在动手改本地代码之前，一定会先检查下远程库跟本地代码的区别！如果本地的代码版本已经落后，切记要先pull拉取一下远程库的代码，将本地代码更新到最新以后，然后再修改，提交，推送！ 问题：What’s the main difference between git fetch and git pull? git fetch fetches remote updates but doesn’t merge; git pull fetches remote updates and merges. git fetch origin master git checkout origin/master git merge origin/master 注意：“origin” is the default name for the remote repo. ","date":"2020-07-28","objectID":"/git-github/:4:0","tags":["git"],"title":"Git与Github使用","uri":"/git-github/"},{"categories":null,"content":"5. 工作流 Steps: (junior)创建分支feature (junior)推送feature分支 (senior)切换分支，审查代码 (senior)切换master，合并feature (senior)推送master分支 TODO ","date":"2020-07-28","objectID":"/git-github/:5:0","tags":["git"],"title":"Git与Github使用","uri":"/git-github/"},{"categories":null,"content":"撤销 git checkout unstaged.py # revert unstaged changes git reset HEAD staged.py # revert staged changes # overwrite the previous commit with staged changes. # ONLY LOCAL: avoid amending commits that have already been made public git commit --amend git revert HEAD # roll back to previous commit git revert commitID # roll back git remote -v # list remote repos verbosely git remote show origin # describe a single remote repo git branch -r # list remote branches git remote update will update all of your branches set to track remote ones, but not merge any changes in. Rebasing instead of merging rewrites history and maintains linearity, making for cleaner code. git checkout new-feature git rebase master git log --graph --oneline git checkout master git merge new-feature # fast forward merge, linear history git push --delete origin new-feature # delete remote branch git branch -d new-feature # delete local branch git fetch git rebase origin/master git add health_checks.py git rebase --continue ","date":"2020-07-28","objectID":"/git-github/:6:0","tags":["git"],"title":"Git与Github使用","uri":"/git-github/"},{"categories":null,"content":"参考 Git scm official Understanding branches in Git CS Visualized: Useful Git Commands - Lydia Hallie What is the difference between ‘git remote update’, ‘git fetch’ and ‘git pull’? Listing and deleting Git commits that are under no branch (dangling?) How can I undo git reset –hard HEAD~1? How do I check out a remote Git branch? git 理解 Head指针\u0026Branch指针–reset\u0026checkout ","date":"2020-07-28","objectID":"/git-github/:7:0","tags":["git"],"title":"Git与Github使用","uri":"/git-github/"},{"categories":null,"content":" while位 ","date":"2020-07-26","objectID":"/leetcode-bit-manipulation/:0:0","tags":["leetcode"],"title":"Leetcode：位运算","uri":"/leetcode-bit-manipulation/"},{"categories":null,"content":"342. Power of Four (easy) 简述：判断是否为4的幂 思路：mask挪位置 联系：出自693 # class Solution(object): # def isPowerOfFour(self, num): # \"\"\" # :type num: int # :rtype: bool # \"\"\" # base = 1 while base \u003c= num: # if base == num: # return True # 要点1-1: 偶数位为1 base \u003c\u003c= 2 # return False ","date":"2020-07-26","objectID":"/leetcode-bit-manipulation/:1:0","tags":["leetcode"],"title":"Leetcode：位运算","uri":"/leetcode-bit-manipulation/"},{"categories":null,"content":"476. Number Complement (easy) 简述：将所给数二进制取反输出对应十进制 思路：利用stack 联系：出自342 # class Solution(object): # def findComplement(self, num): # \"\"\" # :type num: int # :rtype: int # \"\"\" # stack = [] # while num: # stack.append(1 ^ (num \u0026 1)) # num = num \u003e\u003e 1 # res = 0 # while stack: res = (res \u003c\u003c 1) + stack.pop() # return res ","date":"2020-07-26","objectID":"/leetcode-bit-manipulation/:2:0","tags":["leetcode"],"title":"Leetcode：位运算","uri":"/leetcode-bit-manipulation/"},{"categories":null,"content":"693. Binary Number with Alternating Bits (easy) 简述：判断所给数二进制是否间隔均不同，即...0101...或者...1010... 思路：while异常退出，逐位判断 联系：342 # class Solution(object): # def hasAlternatingBits(self, n): # \"\"\" # :type n: int # :rtype: bool # \"\"\" # state = n \u0026 1 # while n: # n = n \u003e\u003e 1 # 要点1-1: python位与，位xor if state ^ (n \u0026 1) != 1: # return False # state ^= 1 # return True ","date":"2020-07-26","objectID":"/leetcode-bit-manipulation/:3:0","tags":["leetcode"],"title":"Leetcode：位运算","uri":"/leetcode-bit-manipulation/"},{"categories":null,"content":"477. Total Hamming Distance (medium) 简述：求所有数对hamming距离之和 思路：找出每一位位置上，多少个数为1或为0 联系：342 # class Solution(object): # def totalHammingDistance(self, nums): # \"\"\" # :type nums: List[int] # :rtype: int # \"\"\" # res = 0 # for i in range(32): countZeros = sum([x \u0026 (1\u003c\u003ci) == 0 for x in nums]) res += countZeros * (len(nums) - countZeros) # return res ","date":"2020-07-26","objectID":"/leetcode-bit-manipulation/:4:0","tags":["leetcode"],"title":"Leetcode：位运算","uri":"/leetcode-bit-manipulation/"},{"categories":null,"content":"201. Bitwise AND of Numbers Range (medium) 简述：求区间内所有数位AND值 思路：只要区间跨过1，末位AND值为0，递归求解 联系： # class Solution(object): # def rangeBitwiseAnd(self, m, n): # \"\"\" # :type m: int # :type n: int # :rtype: int # \"\"\" # if m == n: # return m # if n == m + 1: # return m \u0026 n # 要点1-1: 区间跨过1，末位AND值为0，递归 return self.rangeBitwiseAnd(m \u003e\u003e 1, n \u003e\u003e 1) \u003c\u003c 1 与关系 ","date":"2020-07-26","objectID":"/leetcode-bit-manipulation/:5:0","tags":["leetcode"],"title":"Leetcode：位运算","uri":"/leetcode-bit-manipulation/"},{"categories":null,"content":"191. Number of 1 Bits (easy) 简述：求所给数二进制里多少位是1 思路：n \u0026 (n-1)去掉最后一位1 联系： # class Solution(object): # def hammingWeight(self, n): # \"\"\" # :type n: int # :rtype: int # \"\"\" # res = 0 # while n: # n \u0026 (n-1) 去掉最后一位1 n = n \u0026 (n - 1) # res += 1 # return res ","date":"2020-07-26","objectID":"/leetcode-bit-manipulation/:6:0","tags":["leetcode"],"title":"Leetcode：位运算","uri":"/leetcode-bit-manipulation/"},{"categories":null,"content":"231. Power of Two (easy) 简述：判断是否为2的幂 思路：二进制中有且仅有1个1 联系：出自191 # class Solution(object): # def isPowerOfTwo(self, n): # \"\"\" # :type n: int # :rtype: bool # \"\"\" # return n \u0026 (n-1) == 0 and n != 0 ","date":"2020-07-26","objectID":"/leetcode-bit-manipulation/:7:0","tags":["leetcode"],"title":"Leetcode：位运算","uri":"/leetcode-bit-manipulation/"},{"categories":null,"content":"461. Hamming Distance (easy) 简述：求所给数对的hamming distance 思路：先亦或，再数多少个1 联系：出自191 # class Solution(object): # def hammingDistance(self, x, y): # \"\"\" # :type x: int # :type y: int # :rtype: int # \"\"\" num = x ^ y # res = 0 # while num: num = num \u0026 (num - 1) # res += 1 # return res 异或关系 ","date":"2020-07-26","objectID":"/leetcode-bit-manipulation/:8:0","tags":["leetcode"],"title":"Leetcode：位运算","uri":"/leetcode-bit-manipulation/"},{"categories":null,"content":"136. Single Number (easy) 简述：数组中除某元素外每个元素出现两次，找出该元素 思路：碰碰对 联系： # class Solution(object): # def singleNumber(self, nums): # \"\"\" # :type nums: List[int] # :rtype: int # \"\"\" res = 0 # for num in nums: # res ^= num # return res ","date":"2020-07-26","objectID":"/leetcode-bit-manipulation/:9:0","tags":["leetcode"],"title":"Leetcode：位运算","uri":"/leetcode-bit-manipulation/"},{"categories":null,"content":"389. Find the Difference (easy) 简述：字符串shuffle后添加一个字符，找出该字符 思路：碰碰对 联系：出自136 # class Solution(object): # def findTheDifference(self, s, t): # \"\"\" # :type s: str # :type t: str # :rtype: str # \"\"\" # res = 0 # # 要点1-1: python中ord与chr的使用 # for c in s: # res = res ^ ord(c) # for c in t: # res = res ^ ord(c) # return chr(res) ","date":"2020-07-26","objectID":"/leetcode-bit-manipulation/:10:0","tags":["leetcode"],"title":"Leetcode：位运算","uri":"/leetcode-bit-manipulation/"},{"categories":null,"content":" In-Order ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:0:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"230. Kth Smallest Element in a BST (medium) 简述：在BST中，求第k小的值 思路：inorder，记录遍历idx 联系：模板题 # class Solution(object): # def kthSmallest(self, root, k): # \"\"\" # :type root: TreeNode # :type k: int # :rtype: int # \"\"\" # self.idx, self.res = 0, None # self.k = k # self.inorder(root) # return self.res # def inorder(self, root): # if root is None or self.res is not None: # return # if self.res is not None: # return # self.inorder(root.left) # self.idx += 1 # if self.idx == self.k: # self.res = root.val # self.inorder(root.right) ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:1:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"938. Range Sum of BST (easy) 简述：求BST中值介于[L,R]的节点值的和 思路：inorder + 短路判断 联系：出自230 # class Solution(object): # def rangeSumBST(self, root, L, R): # \"\"\" # :type root: TreeNode # :type L: int # :type R: int # :rtype: int # \"\"\" # self.res = 0 # self.L, self.R = L, R # self.inorder(root) # return self.res # def inorder(self, root): # if root is None: # return # self.inorder(root.left) # if self.L \u003c= root.val \u003c= self.R: # self.res += root.val if root.val \u003e self.R: return # self.inorder(root.right) ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:2:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"538. Convert BST to Greater Tree (easy) 简述：改变BST各节点值，使得节点值为后缀和 思路：inorder从后到前遍历 联系：出自230 # class Solution(object): # def convertBST(self, root): # \"\"\" # :type root: TreeNode # :rtype: TreeNode # \"\"\" # self.running_total = 0 # self.inorder(root) # return root # def inorder(self, root): # if root is None: # return None # self.inorder(root.right) root.val += self.running_total self.running_total = root.val # self.inorder(root.left) ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:3:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"501. Find Mode in Binary Search Tree (easy) 简述：求BST中出现最多的值 思路：inorder建立字典 联系：出自230 # class Solution(object): # def findMode(self, root): # \"\"\" # :type root: TreeNode # :rtype: List[int] # \"\"\" # if root is None: # return [] # self.memo = dict() # self.inorder(root) # 要点2-1: python语法，总结value mode = max(self.memo.values()) res = [key for key in self.memo if self.memo[key] == mode] # return res # def inorder(self, root): # if root is None: # return # self.inorder(root.left) # 要点2-2: 异常if用来，初始化key不在字典中的情况 if root.val not in self.memo: self.memo[root.val] = 0 # self.memo[root.val] += 1 # self.inorder(root.right) ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:4:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"530. Minimum Absolute Difference in BST (easy) 简述：在BST节点对中，求最小的相差绝对值 思路：BST的in-order将返回排序数组 联系：出自230 # class Solution(object): # def getMinimumDifference(self, root): # \"\"\" # :type root: TreeNode # :rtype: int # \"\"\" # self.res = sys.maxsize self.prev = None # self.inorder(root) # return self.res # def inorder(self, root): # if root is None: # return # self.inorder(root.left) # if self.prev is not None: # self.res = min(self.res, abs(root.val - self.prev)) # self.prev = root.val # self.inorder(root.right) ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:5:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"783. Minimum Distance Between BST Nodes (easy) 简述：在BST节点对中，求最小的距离（相差） 思路：inorder，记录历史 联系：出自530 # class Solution(object): # def minDiffInBST(self, root): # \"\"\" # :type root: TreeNode # :rtype: int # \"\"\" # self.prev, self.res = None, sys.maxsize # self.inorder(root) # return self.res # def inorder(self, root): # if root is None: # return None # self.inorder(root.left) # if self.prev is not None: # self.res = min(self.res, root.val - self.prev) # self.prev = root.val # self.inorder(root.right) ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:6:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"897. Increasing Order Search Tree (easy) 简述：把BST变为单向链表 思路：记录遍历前的node 联系：出自530 # class Solution(object): # def increasingBST(self, root): # \"\"\" # :type root: TreeNode # :rtype: TreeNode # \"\"\" # self.dummy = TreeNode(0) # self.p = self.dummy # self.inorder(root) # return self.dummy.right # def inorder(self, root): # if root is None: # return # self.inorder(root.left) root.left, self.p.right, self.p.left = None, root, None self.p = self.p.right # self.inorder(root.right) Pre-Order ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:7:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"144. Binary Tree Preorder Traversal (medium) 简述：二叉树pre-order遍历 思路：recursive简单，主要尝试iterative 联系： # class Solution(object): # def preorderTraversal(self, root): # \"\"\" # :type root: TreeNode # :rtype: List[int] # \"\"\" # if root is None: # return [] # 要点1-1: 用stack存待搜索树 stack = [root] # res = [] # while stack: # node = stack.pop() # res.append(node.val) # if node.right is not None: # stack.append(node.right) # if node.left is not None: # stack.append(node.left) # return res ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:8:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"965. Univalued Binary Tree (easy) 简述：判断树中节点值是否单一 思路：遍历时，维护全局变量 联系： # class Solution(object): # def isUnivalTree(self, root): # \"\"\" # :type root: TreeNode # :rtype: bool # \"\"\" # if root.left is None and root.right is None: # return True # self.rootval, self.res = root.val, True # self.preOrder(root) # return self.res # def preOrder(self, root): # \"\"\" # :type root: TreeNode # :rtype: bool # \"\"\" # if root is None: # return # if root.val != self.rootval: # self.res = False # self.preOrder(root.left) # self.preOrder(root.right) Post-Order backtrack ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:9:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"404. Sum of Left Leaves (easy) 简述：求二叉树中，所有左叶节点和 思路：左转向下时标注“左”，右转向下时标注“右” 联系： # class Solution(object): # def sumOfLeftLeaves(self, root): # \"\"\" # :type root: TreeNode # :rtype: int # \"\"\" # self.res = 0 self.inorder(root, False) # return self.res # def inorder(self, root, isLeft): # if root is None: # return # self.inorder(root.left, True) # if root.left is None and root.right is None and isLeft: # self.res += root.val # self.inorder(root.right, False) Non-recursive ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:10:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"510. Inorder Successor in BST II (medium) 简述：给二叉树中某个节点，树中找in-order顺序中的下一个节点（此题节点额外含有：子-\u003e父） 思路：while 联系： # class Solution(object): # def inorderSuccessor(self, node): # \"\"\" # :type node: Node # :rtype: Node # \"\"\" # if node is None: # return None # if node.right: # curr = node.right # while curr.left: # curr = curr.left # return curr # else: # curr = node # while curr.parent and curr == curr.parent.right: # curr = curr.parent # return curr.parent ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:11:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"222. Count Complete Tree Nodes (medium) 简述：complete二叉树 （complete指从上到下，从左到右尽量排满），求树中节点个数 思路：最优复杂度O(logN*logN) 联系：树与二分法很漂亮的结合题 # class Solution(object): # def countNodes(self, root): # \"\"\" # :type root: TreeNode # :rtype: int # \"\"\" # if root is None: # return 0 # height = self.findHeight(root) # res_full = 2**height - 1 # 要点3-1: 二分法模板 # left, right = 1, 2**height # while left + 1 \u003c right: # mid = (left + right) // 2 # if self.pathHasNode(root, height, mid - 1): # left = mid # else: # right = mid # if self.pathHasNode(root, height, right - 1): # return res_full + right # else: # return res_full + left # def findHeight(self, root): # res, p = 0, root # while p.left: # res += 1 # p = p.left # return res # 要点3-2: path encoding def pathHasNode(self, root, height, encoding_int): # p = root # 要点3-3: 构造mask，将encoded path从高位到地位二进制扫描出来 # mask = 2**(height-1) # for _ in range(height): if encoding_int \u0026 mask == 0: # if p.left is None: # return False # p = p.left # else: # if p.right is None: # return False # p = p.right mask \u003e\u003e= 1 # return True ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:12:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"701. Insert into a Binary Search Tree (medium) 简述：将所给值插入BST（假设原BST不含所给值） 思路：用BST性质 联系： # class Solution(object): # def insertIntoBST(self, root, val): # \"\"\" # :type root: TreeNode # :type val: int # :rtype: TreeNode # \"\"\" # 要点1-1：边界情况 if root is None: return TreeNode(val) # p = root # while True: # if val \u003e p.val: # if p.right is None: # p.right = TreeNode(val) # return root # else: # p = p.right # else: # if p.left is None: # p.left = TreeNode(val) # return root # else: # p = p.left ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:13:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"94. Binary Tree Inorder Traversal (medium) 简述：不用递归，in-order遍历二叉树 思路：左子树为优先级 联系：出自510 # class Solution(object): # def inorderTraversal(self, root): # \"\"\" # :type root: TreeNode # :rtype: List[int] # \"\"\" if root is None: return [] dummy = TreeNode(0) dummy.right = root stack = [dummy] inorder = [] while stack: node = stack.pop() if node.right: # 想处理此节点，先把此节点的右子树加入优先级栈 node = node.right while node: stack.append(node) node = node.left if stack: inorder.append(stack[-1].val) return inorder ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:14:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":" Title -- ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:0:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"100. Same Tree (easy) 简述：判断两棵二叉树是否相同 思路：分治法 联系：模板题 # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None # class Solution(object): # def isSameTree(self, p, q): # \"\"\" # :type p: TreeNode # :type q: TreeNode # :rtype: bool # \"\"\" # if p is None and q is None: # return True # if p is None or q is None: # return False return p.val == q.val and \\ self.isSameTree(p.left, q.left) and \\ self.isSameTree(p.right, q.right) ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:1:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"572. Subtree of Another Tree (easy) 简述：判断t是否为s的子树（相同也算子树） 思路：构造isSame()辅助 联系：出自100 # class Solution(object): # def isSubtree(self, s, t): # \"\"\" # :type s: TreeNode # :type t: TreeNode # :rtype: bool # \"\"\" # if s is None: # return False return self.isSame(s, t) or self.isSubtree(s.left, t) or self.isSubtree(s.right, t) # def isSame(self, s, t): # if s is None and t is None: # return True # if s is None or t is None: # return False # return s.val == t.val and \\ # self.isSame(s.left, t.left) and \\ # self.isSame(s.right, t.right) ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:2:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"101. Symmetric Tree (easy) 简述：判断二叉树是否对称 思路：改造为判断两棵树是否对称 联系：出自100 # class Solution(object): # def isSymmetric(self, root): # \"\"\" # :type root: TreeNode # :rtype: bool # \"\"\" # if root is None: # return True # return self._isSymmetric(root.left, root.right) # 要点1-1: 下划线命名helper函数，添加参数 def _isSymmetric(self, r1, r2): # if r1 is None and r2 is None: # return True # if r1 is None or r2 is None: # return False # return r1.val == r2.val and \\ # self._isSymmetric(r1.left, r2.right) and \\ # self._isSymmetric(r1.right, r2.left) ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:3:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"270. Closest Binary Search Tree Value (easy) 简述：在BST里找最接近目标的值 思路：分治 联系：出自100 # class Solution(object): # def closestValue(self, root, target): # \"\"\" # :type root: TreeNode # :type target: float # :rtype: int # \"\"\" # if root.left is None and root.right is None: # return root.val # if target == root.val: # return root.val # if target \u003e root.val: # if root.right is None: # return root.val # tmp_res = self.closestValue(root.right, target) if abs(root.val - target) \u003c= abs(tmp_res - target): # return root.val # else: # return tmp_res # else: # if root.left is None: # return root.val # tmp_res = self.closestValue(root.left, target) if abs(root.val - target) \u003c= abs(tmp_res - target): # return root.val # else: # return tmp_res ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:4:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"104. Maximum Depth of Binary Tree (easy) 简述：求二叉树最大深度, 通常定义如下 （此题按节点数量算深度） I learned that depth and height are properties of a node: The depth of a node is the number of edges from the node to the tree’s root node. A root node will have a depth of 0. The height of a node is the number of edges on the longest path from the node to a leaf. A leaf node will have a height of 0. Properties of a tree: The height of a tree would be the height of its root node, or equivalently, the depth of its deepest node. The diameter (or width) of a tree is the number of nodes on the longest path between any two leaf nodes. The tree below has a diameter of 6 nodes. depth往根（上）数，height往最远的叶（下）数，height等于maxDepth 思路：分治法，也可以遍历法 联系：出自100 # class Solution(object): # def maxDepth(self, root): # \"\"\" # :type root: TreeNode # :rtype: int # \"\"\" # if root is None: # return 0 # return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1 ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:5:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"111. Minimum Depth of Binary Tree (easy) 简述：求二叉树最小深度 思路：分治法 联系：出自104 # class Solution(object): # def minDepth(self, root): # \"\"\" # :type root: TreeNode # :rtype: int # \"\"\" # if root is None: # return 0 if root.left is None and root.right is None: return 1 if root.left is None: return self.minDepth(root.right) + 1 if root.right is None: return self.minDepth(root.left) + 1 # return min(self.minDepth(root.left), self.minDepth(root.right)) + 1 ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:6:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"226. Invert Binary Tree (easy) 简述：左右反转二叉树 思路：分治 联系：出自100 # class Solution(object): # def invertTree(self, root): # \"\"\" # :type root: TreeNode # :rtype: TreeNode # \"\"\" # if root is None: # return None # if root.left is None and root.right is None: # return root root.left, root.right = self.invertTree(root.right), self.invertTree(root.left) # return root ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:7:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"669. Trim a Binary Search Tree (easy) 简述：裁剪BST，使得裁剪后元素位于区间[L, R](R\u003e=L)内 思路：根节点三种情况：\u003cL, \u003eR, LR之间 联系：出自100 # class Solution(object): # def trimBST(self, root, L, R): # \"\"\" # :type root: TreeNode # :type L: int # :type R: int # :rtype: TreeNode # \"\"\" # if root is None: # return None # if root.val \u003c L: # return self.trimBST(root.right, L, R) # if root.val \u003e R: # return self.trimBST(root.left, L, R) root.left, root.right = self.trimBST(root.left, L, R), self.trimBST(root.right, L, R) # return root ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:8:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"110. Balanced Binary Tree (easy) 简述：判断二叉树是否平衡，即每个节点左右子树高度差不超过1 思路：分治+全局变量 联系：出自104 # class Solution(object): # def isBalanced(self, root): # \"\"\" # :type root: TreeNode # :rtype: bool # \"\"\" # 要点2-1: 添加全局变量 self._isBalanced = True # height = self.findHeight(root) # return self._isBalanced # def findHeight(self, root): # 要点2-2: 添加短路判断 if root is None or not self._isBalanced: return 0 # left_height = self.findHeight(root.left) # right_height = self.findHeight(root.right) # if abs(left_height - right_height) \u003e 1: # self._isBalanced = False # return max(left_height, right_height) + 1 ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:9:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"543. Diameter of Binary Tree (easy) 简述：求二叉树的直径，即节点间的最长路径（可不经过根节点） 思路：分治+全局变量 联系：出自110 # class Solution(object): # def diameterOfBinaryTree(self, root): # \"\"\" # :type root: TreeNode # :rtype: int # \"\"\" # 要点1-1: 添加全局变量 self.res = 0 # self.findDepth(root) # return self.res # def findDepth(self, root): # if root is None: # return 0 # left_depth = self.findDepth(root.left) # right_depth = self.findDepth(root.right) self.res = max(self.res, left_depth + right_depth) # return max(left_depth, right_depth) + 1 ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:10:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"124. Binary Tree Maximum Path Sum (hard) 简述：求二叉树中路径最大和（任意节点到任意节点，不必经过根节点） 思路：分治+全局变量 联系：出自110 # class Solution(object): # def maxPathSum(self, root): # \"\"\" # :type root: TreeNode # :rtype: int # \"\"\" # 要点1-1: python最小整数 self.res = -sys.maxsize - 1 # self.maxSumFromRoot(root) # return self.res # def maxSumFromRoot(self, root): # if root is None: # return 0 # if root.left is None and root.right is None: # self.res = max(self.res, root.val) # return root.val # left_max = self.maxSumFromRoot(root.left) # right_max = self.maxSumFromRoot(root.right) self.res = max(self.res, root.val + \\ max(0, left_max, right_max, left_max + right_max)) # return max(root.val, root.val + left_max, root.val + right_max) ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:11:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"257. Binary Tree Paths (easy) 简述：打印二叉树所有根到叶路径 思路：分治 联系：出自100 # class Solution(object): # def binaryTreePaths(self, root): # \"\"\" # :type root: TreeNode # :rtype: List[str] # \"\"\" # if root is None: # return [] # if root.left is None and root.right is None: # return [str(root.val)] # left_paths = self.binaryTreePaths(root.left) # right_paths = self.binaryTreePaths(root.right) # res = [] # res += [str(root.val) + '-\u003e' + p for p in left_paths] # res += [str(root.val) + '-\u003e' + p for p in right_paths] # return res ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:12:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"654. Maximum Binary Tree (medium) 简述：给数组，按规则构造树，规则：数组最大值为根，最大值左边为左子树，最大值右边为右子树，左右子树继续符合规则 思路：递归定义，分治 联系：出自100 # class Solution(object): # def constructMaximumBinaryTree(self, nums): # \"\"\" # :type nums: List[int] # :rtype: TreeNode # \"\"\" # if not nums: # return None # root = TreeNode(max(nums)) # root.left = self.constructMaximumBinaryTree(nums[0:nums.index(max(nums))]) # root.right = self.constructMaximumBinaryTree(nums[nums.index(max(nums))+1:]) # return root ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:13:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"108. Convert Sorted Array to Binary Search Tree (easy) 简述：给已排序的数组，构造相应的平衡BST 思路：中点作为pivot 联系：出自654 # class Solution(object): # def sortedArrayToBST(self, nums): # \"\"\" # :type nums: List[int] # :rtype: TreeNode # \"\"\" # if not nums: # return None # mid = len(nums) // 2 # root = TreeNode(nums[mid]) # root.left = self.sortedArrayToBST(nums[0: mid]) # root.right = self.sortedArrayToBST(nums[mid + 1:]) # return root ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:14:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"606. Construct String from Binary Tree (easy) 简述：按preorder规则通过添加括号把二叉树转为字符串，以保证树与字符串的一一对应。 思路：如果左子树为空，可添加一对空括号 联系：出自654 # class Solution(object): # def tree2str(self, t): # \"\"\" # :type t: TreeNode # :rtype: str # \"\"\" # if t is None: # return \"\" # if t.left is None and t.right is None: # return str(t.val) if t.left is None: return str(t.val) + '()(' + self.tree2str(t.right) + ')' if t.right is None: return str(t.val) + '(' + self.tree2str(t.left) + ')' # return str(t.val) + '(' + self.tree2str(t.left) + ')(' + self.tree2str(t.right) + ')' ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:15:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"1120. Maximum Average Subtree (medium) 简述：求子树中最大平均值 思路：维护平均值，辅助函数返回树的总和与总节点个数 联系：出自110 # class Solution(object): # def maximumAverageSubtree(self, root): # \"\"\" # :type root: TreeNode # :rtype: float # \"\"\" # 要点1-1: 初始为最小浮点数 self.res = float('-inf') # res_cnt, res_sum = self.findSum(root) # return self.res # def findSum(self, root): # if root is None: # return 0, 0 # if root.left is None and root.right is None: # self.res = max(self.res, root.val) # return 1, root.val # left_cnt, left_sum = self.findSum(root.left) # right_cnt, right_sum = self.findSum(root.right) # res_cnt = left_cnt + right_cnt + 1 # res_sum = left_sum + right_sum + root.val # self.res = max(self.res, res_sum * 1.0 / res_cnt) # return res_cnt, res_sum ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:16:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"563. Binary Tree Tilt (easy) 简述：按定义求树的tilt，定义：节点tilt-左子树节点和与右子树节点和差值的绝对值，树的tilt-所有节点tilt的和 思路：辅助函数findSum(), 维护全局变量 联系：出自110 # class Solution(object): # def findTilt(self, root): # \"\"\" # :type root: TreeNode # :rtype: int # \"\"\" # self.res = 0 # total_sum = self.findSum(root) # return self.res # def findSum(self, root): # if root is None: # return 0 # if root.left is None and root.right is None: # return root.val # left_sum, right_sum = self.findSum(root.left), self.findSum(root.right) self.res += abs(left_sum - right_sum) return left_sum + right_sum + root.val ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:17:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"366. Find Leaves of Binary Tree (medium) 简述：二叉树剥洋葱，返回最外层（叶节点），然后次外层（倒数第二层节点），以此类推 思路：标注节点高度，构造节点-\u003e高度映射，再返回反向索引 联系：出自110 # class Solution(object): # def findLeaves(self, root): # \"\"\" # :type root: TreeNode # :rtype: List[List[int]] # \"\"\" # 要点2-1: 全局变量，映射 height_memo = dict() # self.label_height(root, height_memo) # # 要点2-2: 反向索引inverted index return self.convert_memo(height_memo) # def label_height(self, root, height_memo): # if root is None: # return 0 # if root.left is None and root.right is None: # height_memo[root] = 1 # return 1 # left_height = self.label_height(root.left, height_memo) # right_height = self.label_height(root.right, height_memo) # res_height = max(left_height, right_height) + 1 # height_memo[root] = res_height # return res_height # def convert_memo(self, height_memo): # res = dict() # for k, v in height_memo.items(): # if v not in res: # res[v] = list() # res[v].append(k.val) # ans = [] # for i in range(len(res.keys())): # ans.append(res[i + 1]) # return ans ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:18:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"617. Merge Two Binary Trees (easy) 简述：合并两棵二叉树，合并后节点为两棵对应节点之和 思路：分治 联系：出自669 # class Solution(object): # def mergeTrees(self, t1, t2): # \"\"\" # :type t1: TreeNode # :type t2: TreeNode # :rtype: TreeNode # \"\"\" # if t1 is None: # return t2 # if t2 is None: # return t1 # root = TreeNode(t1.val + t2.val) # root.left = self.mergeTrees(t1.left, t2.left) # root.right = self.mergeTrees(t1.right, t2.right) # return root ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:19:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"1490. Clone N-ary Tree (medium) 简述：深拷贝N元树 思路：递归定义，分治 联系：出自100 # class Solution(object): # def cloneTree(self, root): # \"\"\" # :type root: Node # :rtype: Node # \"\"\" # if root is None: # return None # root_copy = Node(val=root.val) # for el in root.children: # root_copy.children.append(self.cloneTree(el)) # return root_copy ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:20:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"814. Binary Tree Pruning (medium) 简述：二叉树树中节点只能为0或1，裁剪二叉树，使得最后没有全为0的子树 思路：分治 联系：出自100 # class Solution(object): # def pruneTree(self, root): # \"\"\" # :type root: TreeNode # :rtype: TreeNode # \"\"\" # if root is None: # return None # if root.left is None and root.right is None: # if root.val == 0: # return None # else: # return root # left_pruned = self.pruneTree(root.left) # right_pruned = self.pruneTree(root.right) if left_pruned is None and right_pruned is None and root.val == 0: return None # root.left, root.right = left_pruned, right_pruned # return root ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:21:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"236. Lowest Common Ancestor of a Binary Tree (medium) 简述：求两节点在二叉树里的LCA（假设两节点都在树中） 思路：分治 联系：出自100 # class Solution(object): # 要点1-1: 三种情况：1）两个节点都在树中返回lca， 2）一个在树中返回该节点，3）两个都不在返回None def lowestCommonAncestor(self, root, p, q): # \"\"\" # :type root: TreeNode # :type p: TreeNode # :type q: TreeNode # :rtype: TreeNode # \"\"\" # if root is None: # return None # if root == p or root == q: # return root # left_lca = self.lowestCommonAncestor(root.left, p, q) # right_lca = self.lowestCommonAncestor(root.right, p, q) # if left_lca and right_lca: # return root # if left_lca: # return left_lca # if right_lca: # return right_lca # return None ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:22:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"235. Lowest Common Ancestor of a Binary Search Tree (easy) 简述：求两节点在BST里的LCA（假设两节点都在树中） 思路：分治，根据情况走一边子树 联系：出自236 # class Solution(object): # def lowestCommonAncestor(self, root, p, q): # \"\"\" # :type root: TreeNode # :type p: TreeNode # :type q: TreeNode # :rtype: TreeNode # \"\"\" # if root is None: # return None # if root == p or root == q: # return root # if p.val \u003c root.val \u003c q.val or q.val \u003c root.val \u003c p.val: # return root # if root.val \u003c p.val: # return self.lowestCommonAncestor(root.right, p, q) # else: # return self.lowestCommonAncestor(root.left, p, q) ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:23:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"156. Binary Tree Upside Down (medium) 简述：上下翻转二叉树，所给二叉树的性质：右节点是空或是有兄弟节点的叶节点 思路：画图按例子翻转 联系：出自226 # class Solution(object): # def upsideDownBinaryTree(self, root): # \"\"\" # :type root: TreeNode # :rtype: TreeNode # \"\"\" # if root is None: # return None # if root.left is None and root.right is None: # return root # res = self.upsideDownBinaryTree(root.left) root.left.left, root.left.right = root.right, root # root.left, root.right = None, None # return res ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:24:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"114. Flatten Binary Tree to Linked List (medium) 简述：in-place转化二叉树成链表结构 思路：分治 联系：出自226 # class Solution(object): # def flatten(self, root): # \"\"\" # :type root: TreeNode # :rtype: None Do not return anything, modify root in-place instead. # \"\"\" # tail = self.flatten_tail(root) # def flatten_tail(self, root): # if root is None: # return None # if root.left is None and root.right is None: # return root # if root.left is None: # return self.flatten_tail(root.right) # if root.right is None: # left_tail = self.flatten_tail(root.left) # root.left, root.right = None, root.left # return left_tail # left_tail = self.flatten_tail(root.left) # right_tail = self.flatten_tail(root.right) # root.left, root.right, left_tail.right = None, root.left, root.right # return right_tail VERSION II (from girikuncoro’s post) # class Solution(object): # def __init__(self): self.prev = None # def flatten(self, root): # \"\"\" # :type root: TreeNode # :rtype: None Do not return anything, modify root in-place instead. # \"\"\" # if root is None: # return # self.flatten(root.right) # self.flatten(root.left) # # 要点1-1: 先右子树再左子树，这样会把右子树通过prev移花接木到左子树尾部 root.right = self.prev # root.left = None # self.prev = root ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:25:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"298. Binary Tree Longest Consecutive Sequence (medium) 简述：在二叉树中找连续值路径（路径这里指从父节点向下） 思路：分治，维护全局变量 联系：出自110 # class Solution(object): # def longestConsecutive(self, root): # \"\"\" # :type root: TreeNode # :rtype: int # \"\"\" # self.res = 0 # self.longest_from_root(root) # return self.res # def longest_from_root(self, root): # if root is None: # return 0 # if root.left is None and root.right is None: # self.res = max(self.res, 1) # return 1 # 要点1-1: 无论当前节点与左右子节点是否差1，都要执行搜索 left_longest = self.longest_from_root(root.left) right_longest = self.longest_from_root(root.right) # curr = 1 # if root.left and root.val + 1 == root.left.val: # curr = max(curr, left_longest + 1) # if root.right and root.val + 1 == root.right.val: # curr = max(curr, right_longest + 1) # self.res = max(self.res, curr) # return curr ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:26:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"285. Inorder Successor in BST (medium) 简述：BST中找所给节点的下一个按序节点，即比所给节点大的最小节点 思路：分治 联系：出自100 # class Solution(object): # def inorderSuccessor(self, root, p): # \"\"\" # :type root: TreeNode # :type p: TreeNode # :rtype: TreeNode # \"\"\" # if root is None: # return None # if p.val \u003e= root.val: # return self.inorderSuccessor(root.right, p) # left_res = self.inorderSuccessor(root.left, p) # if left_res is None: # return root # return left_res ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:27:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"671. Second Minimum Node In a Binary Tree (easy) 简述：二叉树满足：每个节点有0或2个子节点，当2个子节点时，root.val = min(root.left.val, root.right.val)，求树中第二小的节点值 思路：分治，注意比较时的初始化 联系：出自100 # class Solution(object): # def findSecondMinimumValue(self, root): # \"\"\" # :type root: TreeNode # :rtype: int # \"\"\" # if root is None: # return -1 # if root.left is None and root.right is None: # return -1 # left_res = self.findSecondMinimumValue(root.left) # right_res = self.findSecondMinimumValue(root.right) # 要点1-1: 初始化比较值，题目要求无第二最小值，返回-1 if left_res == -1: left_res = sys.maxsize if right_res == -1: right_res = sys.maxsize # if root.val == root.left.val == root.right.val: res = min(left_res, right_res) return res if res != sys.maxsize else -1 # else: # if root.val == root.left.val: # return min(left_res, root.right.val) # else: # return min(right_res, root.left.val) ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:28:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"模板 # def binarySearch(nums, target): # if len(nums) == 0: # return -1 # start, end = 0, len(nums) - 1 while start + 1 \u003c end: # 要点3-1 mid = (start + end) // 2 # 要点3-2: python动态数据类型 # if nums[start] \u003c target: start = mid # 要点3-3: mid不+-1 # else: # end = mid # if nums[start] == target: # return start # if nums[end] == target: # return end # return -1 找位置 ","date":"2020-07-07","objectID":"/leetcode-binary-search/:0:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"34. Find First and Last Position of Element in Sorted Array (medium) 简述：已排序数组，求目标值第一次和最后一次出现的位置 思路：拆解为两个子函数，findFirst()和findLast() 联系：基础模板题 # class Solution(object): # def searchRange(self, nums, target): # \"\"\" # :type nums: List[int] # :type target: int # :rtype: List[int] # \"\"\" # first, last = self.findFirst(nums, target), self.findLast(nums, target) # return [first, last] # def findFirst(self, nums, target): # if len(nums) == 0: # return -1 # left, right = 0, len(nums) - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 if nums[mid] \u003c target: # 要点2-1 # left = mid # else: # right = mid # if nums[left] == target: # return left # if nums[right] == target: # return right # return -1 # def findLast(self, nums, target): # if len(nums) == 0: # return -1 # left, right = 0, len(nums) - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 if nums[mid] \u003e target: # 要点2-2 # right = mid # else: # left = mid # if nums[right] == target: # return right # if nums[left] == target: # return left # return -1 ","date":"2020-07-07","objectID":"/leetcode-binary-search/:1:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"35. Search Insert Position (easy) 简述：已排序数组，求插入位置保证插入后依然排序 思路：类似findFirst() 联系：出自34 # class Solution(object): # def searchInsert(self, nums, target): # \"\"\" # :type nums: List[int] # :type target: int # :rtype: int # \"\"\" # # 要点1-1: 注意输入边界情况 if target \u003c nums[0]: return 0 if target \u003e nums[-1]: return len(nums) # left, right = 0, len(nums) - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 # if nums[mid] \u003c target: # left = mid # else: # right = mid # if nums[left] \u003e= target: # return left # return right ","date":"2020-07-07","objectID":"/leetcode-binary-search/:2:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"744. Find Smallest Letter Greater Than Target (easy) 简述：已排序的数组，求大于目标的最前位置 思路：类似findFirst() 联系：出自34 # class Solution(object): # def nextGreatestLetter(self, letters, target): # \"\"\" # :type letters: List[str] # :type target: str # :rtype: str # \"\"\" # left, right = 0, len(letters) - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 # if letters[mid] \u003c= target: # left = mid # else: # right = mid # if letters[left] \u003e target: # return letters[left] # if letters[right] \u003e target: # return letters[right] # return letters[0] ","date":"2020-07-07","objectID":"/leetcode-binary-search/:3:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"702. Search in a Sorted Array of Unknown Size (medium) 简述：已排序数组，但不知size，求目标值位置 思路：扩右边直到包含目标值，再二分 联系：出自34 # class Solution(object): # def search(self, reader, target): # \"\"\" # :type reader: ArrayReader # :type target: int # :rtype: int # \"\"\" # # 要点1-1: 倍增右边界 right = 1 while reader.get(right) \u003c target: right *= 2 left = right // 2 # while left + 1 \u003c right: # mid = (left + right) // 2 # if reader.get(mid) == target: # return mid # if reader.get(mid) \u003c target: # left = mid # else: # right = mid # if reader.get(left) == target: # return left # if reader.get(right) == target: # return right # return -1 ","date":"2020-07-07","objectID":"/leetcode-binary-search/:4:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"74. Search a 2D Matrix (medium) 简述：已排序的2D数组(每行排序，一行最后元素小于下行最前元素)，求目标值是否存在 思路：只是1D数组layout变化，模板不变 联系：出自34 # class Solution(object): # def searchMatrix(self, matrix, target): # \"\"\" # :type matrix: List[List[int]] # :type target: int # :rtype: bool # \"\"\" # if not matrix or not matrix[0]: # return False # M, N = len(matrix), len(matrix[0]) # left, right = 0, M * N - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 # row, col = mid // N, mid % N # if matrix[row][col] == target: # return True # if matrix[row][col] \u003c target: # left = mid # else: # right = mid # return matrix[left//N][left%N] == target or matrix[right//N][right%N] == target ","date":"2020-07-07","objectID":"/leetcode-binary-search/:5:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"240. Search a 2D Matrix II (medium) 简述：已排序的2D数组(每行排序，每列排序)，求目标值是否存在 思路：斜对角线一个个坐标走，不是二分题 联系：出自74，不是二分 # class Solution(object): # def searchMatrix(self, matrix, target): # \"\"\" # :type matrix: List[List[int]] # :type target: int # :rtype: bool # \"\"\" # if not matrix or not matrix[0]: # return False # M, N = len(matrix), len(matrix[0]) # x, y = M - 1, 0 # while True: # if not (0 \u003c= x \u003c M and 0 \u003c= y \u003c N): # return False # if matrix[x][y] == target: # return True # # 要点1-1: 不是二分，走坐标 if matrix[x][y] \u003e target: x -= 1 else: y += 1 # return False ","date":"2020-07-07","objectID":"/leetcode-binary-search/:6:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"658. Find K Closest Elements (medium) 简述：已排序数组，求k个最邻近目标的元素们 思路：先找到最邻近目标的元素，再往两边扩展 联系：出自34 # class Solution(object): # def findClosestElements(self, arr, k, x): # \"\"\" # :type arr: List[int] # :type k: int # :type x: int # :rtype: List[int] # \"\"\" # left, right = 0, len(arr) - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 # if arr[mid] \u003c x: # left = mid # else: # right = mid # # 要点1-1: 最后的范围左右开区间(left, right) return self.expand(arr, left, right, k, x) # def expand(self, arr, left, right, k, x): # cnt = 0 # while cnt \u003c k: # if right \u003e= len(arr) or abs(arr[left] - x) \u003c= abs(arr[right] - x): # left -= 1 # else: # right += 1 # cnt += 1 return arr[left + 1 : left + 1 + k] 非单调 ","date":"2020-07-07","objectID":"/leetcode-binary-search/:7:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"153. Find Minimum in Rotated Sorted Array (medium) 简述：rotate过的排序数组(无重复元素)，求最小值 思路：pivot出现在前半段，经过顺序为 中\u003c右\u003c左，pivot出现在后半段，经过顺序为 右\u003c左\u003c中 联系：左右关系无法判断, 应判断中右关系 # class Solution(object): # def findMin(self, nums): # \"\"\" # :type nums: List[int] # :rtype: int # \"\"\" # left, right = 0, len(nums) - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 if nums[mid] \u003e nums[right]: # left = mid # else: # right = mid # return min(nums[left], nums[right]) ","date":"2020-07-07","objectID":"/leetcode-binary-search/:8:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"33. Search in Rotated Sorted Array (medium) 简述：rotate过的排序数组(无重复元素)，求目标值位置 思路：先找pivot，再传统二分 联系：出自153 # class Solution(object): # def search(self, nums, target): # \"\"\" # :type nums: List[int] # :type target: int # :rtype: int # \"\"\" # if len(nums) == 0: # return -1 # pivot = self.findPivot(nums) # L = len(nums) # left, right = 0, L - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 # # 要点1-1: 访问排序数组时转化坐标 if nums[(mid + pivot) % L] \u003e target: # right = mid # else: # left = mid # if nums[(left + pivot) % L] == target: # return (left + pivot) % L # if nums[(right + pivot) % L] == target: # return (right + pivot) % L # return -1 def findPivot(self, nums): # left, right = 0, len(nums) - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 # if nums[mid] \u003e nums[right]: # left = mid # else: # right = mid # if nums[left] \u003c nums[right]: # return left # else: # return right ","date":"2020-07-07","objectID":"/leetcode-binary-search/:9:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"154. Find Minimum in Rotated Sorted Array II (hard) 简述：rotate过的排序数组(有重复元素)，求最小元素 思路：11111011 (最坏情况linear查找) 联系：出自33 # class Solution(object): # def findMin(self, nums): # \"\"\" # :type nums: List[int] # :rtype: int # \"\"\" # left, right = 0, len(nums) - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 # if nums[right] \u003e nums[mid]: # right = mid # elif nums[right] \u003c nums[mid]: # left = mid else: # 要点1-1: 如何把线性查找与二分查找合并 right = right - 1 # return min(nums[left], nums[right]) ","date":"2020-07-07","objectID":"/leetcode-binary-search/:10:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"852. Peak Index in a Mountain Array (easy) 简述：山形数组，求山峰位置 思路：思考山峰若在前半段发生什么(A[mid-1] \u003e A[mid] \u003e A[mid+1])，若在后半段发生什么(A[mid-1] \u003c A[mid] \u003c A[mid+1]) 联系：思考方式出自153，都是在想目标出现前后半段的性质差别，二分保证充要 # class Solution(object): # def peakIndexInMountainArray(self, A): # \"\"\" # :type A: List[int] # :rtype: int # \"\"\" # left, right = 0, len(A) - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 # if A[mid] \u003e A[mid+1] and A[mid] \u003e A[mid-1]: # return mid # if A[mid] \u003e A[mid+1] and A[mid] \u003c A[mid-1]: # right = mid # else: # left = mid # if A[left] \u003e A[right]: # return left # else: # return right ","date":"2020-07-07","objectID":"/leetcode-binary-search/:11:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"162. Find Peak Element (medium) 简述：重峦叠嶂数组(相邻不等)，求任意一个山峰位置 思路：类似852，但并不充要 # class Solution(object): # def findPeakElement(self, nums): # \"\"\" # :type nums: List[int] # :rtype: int # \"\"\" # left, right = 0, len(nums) - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 # if nums[mid] \u003e nums[mid - 1] and nums[mid] \u003e nums[mid + 1]: # return mid # if nums[mid] \u003e nums[mid - 1] and nums[mid] \u003c nums[mid + 1]: # left = mid # else: # right = mid # if nums[left] \u003e nums[right]: # return left # else: # return right 找状态 ","date":"2020-07-07","objectID":"/leetcode-binary-search/:12:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"278. First Bad Version (easy) 简述：OOOOXXX, 求第一个失败版本idx 思路：目标出现前后半段导致mid状态差别 联系： # # The isBadVersion API is already defined for you. # # @param version, an integer # # @return a bool # # def isBadVersion(version): # class Solution(object): # def firstBadVersion(self, n): # \"\"\" # :type n: int # :rtype: int # \"\"\" # left, right = 1, n # while left + 1 \u003c right: # mid = (left + right) // 2 # if isBadVersion(mid): # right = mid # else: # left = mid # if isBadVersion(left): # return left # return right ","date":"2020-07-07","objectID":"/leetcode-binary-search/:13:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"374. Guess Number Higher or Lower (easy) 简述：1-n猜数字，api回答高低，求目标数字 思路：从目标开始后面都会猜高 联系：出自278 # # The guess API is already defined for you. # # @param num, your guess # # @return -1 if my number is lower, 1 if my number is higher, otherwise return 0 # # def guess(num): # class Solution(object): # def guessNumber(self, n): # \"\"\" # :type n: int # :rtype: int # \"\"\" # left, right = 1, n # while left + 1 \u003c right: # mid = (left + right) // 2 # api_res = guess(mid) # if api_res == 0: # return mid # if api_res == 1: # left = mid # else: # right = mid # return left if guess(left) == 0 else right ","date":"2020-07-07","objectID":"/leetcode-binary-search/:14:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"69. Sqrt(x) (easy) 简述：求根号x，取整 思路：从正确答案后，平方大于x 联系：出自278 # class Solution(object): # def mySqrt(self, x): # \"\"\" # :type x: int # :rtype: int # \"\"\" # left, right = 1, x # while left + 1 \u003c right: # mid = (left + right) // 2 # if mid * mid == x: # return mid # if mid * mid \u003e x: # right = mid # else: # left = mid # return right if right * right \u003c= x else left ","date":"2020-07-07","objectID":"/leetcode-binary-search/:15:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"302. Smallest Rectangle Enclosing Black Pixels (hard) 简述：二值化图片，黑色像素相连，给一个黑色像素坐标，求包围黑色区域的最小矩形面积 思路：从黑色坐标向上下左右找边界，一旦超过边界将再无黑色行列 联系：出自278 # class Solution(object): # def minArea(self, image, x, y): # \"\"\" # :type image: List[List[str]] # :type x: int # :type y: int # :rtype: int # \"\"\" # m, n = len(image), len(image[0]) # def row_has_black(row): # for j in range(n): # if image[row][j] == '1': # return True # return False # def col_has_black(col): # for i in range(m): # if image[i][col] == '1': # return True # return False def find_upper(): # left, right = 0, x # while left + 1 \u003c right: # mid = (left + right) // 2 # if row_has_black(mid): # right = mid # else: # left = mid # if row_has_black(left): # return left # return right def find_lower(): # left, right = x, m - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 # if row_has_black(mid): # left = mid # else: # right = mid # if row_has_black(right): # return right # return left def find_left(): # left, right = 0, y # while left + 1 \u003c right: # mid = (left + right) // 2 # if col_has_black(mid): # right = mid # else: # left = mid # if col_has_black(left): # return left # return right def find_right(): # left, right = y, n - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 # if col_has_black(mid): # left = mid # else: # right = mid # if col_has_black(right): # return right # return left # upper, lower, left, right = find_upper(), find_lower(), find_left(), find_right() return (lower - upper + 1) * (right - left + 1) 二分答案 ","date":"2020-07-07","objectID":"/leetcode-binary-search/:16:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"274. H-Index (medium) 简述：引用数组，求hIndex–h篇每篇至少h引用，其余每篇不超过h引用 思路：二分答案，答案经过一次状态改变 联系： # class Solution(object): # def hIndex(self, citations): # \"\"\" # :type citations: List[int] # :rtype: int # \"\"\" # if not citations: # return 0 # left, right = 0, len(citations) # while left + 1 \u003c right: # h = (left + right) // 2 cnt = sum([x \u003e= h for x in citations]) # if cnt == h: # return h # if cnt \u003e h: # left = h # else: # right = h # cnt = sum([x \u003e= right for x in citations]) # if cnt \u003e= right: # return right # return left ","date":"2020-07-07","objectID":"/leetcode-binary-search/:17:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"275. H-Index II (hard) 简述：引用数组(已排序)，求hIndex–h篇每篇至少h引用，其余每篇不超过h引用 思路：不是二分答案，注意结尾情况 联系：出自274，但不属于二分答案 # class Solution(object): # def hIndex(self, citations): # \"\"\" # :type citations: List[int] # :rtype: int # \"\"\" # if not citations: # return 0 # N = len(citations) # left, right = 0, N - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 # if N - mid \u003e= citations[mid]: # left = mid # else: # right = mid # 要点1-1: 结尾情况很难想全 if N - right \u003e= citations[right]: return citations[right] if N - right \u003e= citations[left]: return N - right if N - left \u003e= citations[left]: return citations[left] return N - left ","date":"2020-07-07","objectID":"/leetcode-binary-search/:18:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"Coursera specializations offered by UM Course I Time Value of Money ","date":"2020-07-06","objectID":"/coursera-umich-fffsdm/:0:0","tags":null,"title":"Foundational Finance for Strategic Decision Making","uri":"/coursera-umich-fffsdm/"},{"categories":null,"content":"Simple Future Value (FV) PV = Present Value (unit: $) FV = Present Value (unit: $) n = # of Periods (#) r = Interest Rate (%, not $) \u003e 0 (assumption) Insight: A dollar today is worth more than a dollar tomorrow. You cannot compare money across time. Example: Power of Compounding! Peter Minuit bought the Manhattan Island from Native Americans for $24 in 1626. Suppose that Native Americans could have earned 6% on their investments all these years. How much would they have today (year 2020)? $224,244,683,837.58 Some Important Formulae Future Value of a Single Cash Flow Invested for n Periods $$F = P(1+r)^n$$ Present Value of a Single Cash Flow Received n Periods from Now $$P = F\\frac{1}{(1+r)^n}$$ Future Value of a Stream of Cash Flows as of n Periods from Now $$F = C_1(1+r)^{n-1} + C_2(1+r)^{n-2} + \\cdots + C_{n-1}(1+r) + C_n$$ Present Value of a Stream of Cash Flows $$P = \\frac{C_1}{1+r} + \\frac{C_2}{(1+r)^2} + \\cdots + \\frac{C_n}{(1+r)^n}$$ ","date":"2020-07-06","objectID":"/coursera-umich-fffsdm/:1:0","tags":null,"title":"Foundational Finance for Strategic Decision Making","uri":"/coursera-umich-fffsdm/"},{"categories":null,"content":"Hugo: 一个静态网页生成器，将markdown格式的博文编译为HTML，CSS，JavaScript Github Pages: 静态网页托管服务，将hugo转化后的博客公开给读者访问 reference: Mogeko博客《使用 Hugo + GitHub Pages 搭建个人博客》 ","date":"2020-07-03","objectID":"/hugo-blog-site/:0:0","tags":null,"title":"使用 Hugo + Github Pages 搭建个人博客","uri":"/hugo-blog-site/"},{"categories":null,"content":"Step 1 - 创建Github Pages对应的repo repo name: [username].github.io reference: Github Pages official page ","date":"2020-07-03","objectID":"/hugo-blog-site/:1:0","tags":null,"title":"使用 Hugo + Github Pages 搭建个人博客","uri":"/hugo-blog-site/"},{"categories":null,"content":"Step 2 - 安装Hugo (Mac系统) brew install hugo reference: Hugo official quickstart ","date":"2020-07-03","objectID":"/hugo-blog-site/:2:0","tags":null,"title":"使用 Hugo + Github Pages 搭建个人博客","uri":"/hugo-blog-site/"},{"categories":null,"content":"Step 3 - 使用Hugo创建本地博客文件夹 hugo new site myBlog cd myBlog 创建myBlog文件夹来存放博客站点。其中： content存放markdown博文 themes存放皮肤主题 config.toml配置站点 ","date":"2020-07-03","objectID":"/hugo-blog-site/:3:0","tags":null,"title":"使用 Hugo + Github Pages 搭建个人博客","uri":"/hugo-blog-site/"},{"categories":null,"content":"Step 4 - 安装皮肤主题 此博客使用mogege主题，原repo 安装主题至themes下 git clone https://github.com/Mogeko/mogege.git themes/mogege ","date":"2020-07-03","objectID":"/hugo-blog-site/:4:0","tags":null,"title":"使用 Hugo + Github Pages 搭建个人博客","uri":"/hugo-blog-site/"},{"categories":null,"content":"Step 5 - 创建页面 hugo new about.md hugo new posts/my-first-post.md 在content下自动生成页面，meta data包括： title: 页面标题 date: 创建时间 draft: 是否为草稿。建立server时，草稿需要加上--buildDrafts参数才能在public正确显示 description: 描述 (optional) tags:: 标签，用于文章分类 (optional) ","date":"2020-07-03","objectID":"/hugo-blog-site/:5:0","tags":null,"title":"使用 Hugo + Github Pages 搭建个人博客","uri":"/hugo-blog-site/"},{"categories":null,"content":"Step 6 - 配置网站 修改配置文件config.toml baseURL = \"https://xuwenzhe.github.io\" # \u003chead\u003e 里面的 baseurl 信息，填你的博客地址 title = \"Wenzhe's Blog\" # 浏览器的标题 languageCode = \"zh-cn\" # 语言 hasCJKLanguage = true # 开启可以让「字数统计」统计汉字 theme = \"mogege\" # 主题 (需要自己下载) paginate = 11 # 每页的文章数 enableEmoji = true # 支持 Emoji enableRobotsTXT = true # 支持 robots.txt googleAnalytics = \"\" # Google 统计 id preserveTaxonomyNames = true [blackfriday] hrefTargetBlank = true nofollowLinks = true noreferrerLinks = true [Permalinks] posts = \"/:year/:filename/\" [menu] [[menu.main]] name = \"Blog\" url = \"/posts/\" weight = 1 [[menu.main]] name = \"Categories\" url = \"/categories/\" weight = 2 [[menu.main]] name = \"Tags\" url = \"/tags/\" weight = 3 [[menu.main]] name = \"About\" url = \"/about/\" weight = 4 [params] since = 2020 author = \"Wenzhe\" # Author's name avatar = \"/images/me/avatar.png\" # Author's avatar subtitle = \"Just for Fun\" # Subtitle cdn_url = \"\" # Base CDN URL home_mode = \"\" # post or other enableGitalk = true # gitalk 评论系统 google_verification = \"\" description = \"\" # (Meta) 描述 keywords = \"\" # site keywords beian = \"\" baiduAnalytics = \"\" license= '本文采用\u003ca rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003e知识共享署名-非商业性使用 4.0 国际许可协议\u003c/a\u003e进行许可' [params.social] GitHub = \"https://github.com/xuwenzhe\" Twitter = \"xxoo\" Email = \"xxoo\" Instagram = \"xxoo\" Wechat = \"/images/me/wechat.png\" # Wechat QRcode image Facebook = \"xxoo\" Telegram = \"xxoo\" Dribbble = \"xxoo\" Medium = \"xxoo\" [params.gitalk] # Github: https://github.com/gitalk/gitalk clientID = \"\" # Your client ID clientSecret = \"\" # Your client secret repo = \"\" # The repo to store comments owner = \"\" # Your GitHub ID admin= \"\" # Required. Github repository owner and collaborators. (Users who having write access to this repository) id= \"location.pathname\" # The unique id of the page. labels= \"gitalk\" # Github issue labels. If you used to use Gitment, you can change it perPage= 15 # Pagination size, with maximum 100. pagerDirection= \"last\" # Comment sorting direction, available values are 'last' and 'first'. createIssueManually= false # If it is 'false', it is auto to make a Github issue when the administrators login. distractionFreeMode= false # Enable hot key (cmd|ctrl + enter) submit comment. ","date":"2020-07-03","objectID":"/hugo-blog-site/:6:0","tags":null,"title":"使用 Hugo + Github Pages 搭建个人博客","uri":"/hugo-blog-site/"},{"categories":null,"content":"Step 7 - 本地预览 hugo server --buildDrafts -w --buildDrafts: 生成draft博文 -w: 监控修改，自动更新修改过的站点 此时，在http://localhost:1313已经可以访问到博客啦 ","date":"2020-07-03","objectID":"/hugo-blog-site/:7:0","tags":null,"title":"使用 Hugo + Github Pages 搭建个人博客","uri":"/hugo-blog-site/"},{"categories":null,"content":"Step 8 - 编译发布 在myBlog文件夹中编译 hugo 此时，编译后的静态文件会存放在public文件夹 cd public # 进入public文件夹 git init # 建立本地git仓库 git remote add origin https://github.com/[username]/[username].github.io.git # 关联 git add . # add git commit -m \"[commit message]\" # commit git push -u origin master # push 之后发布新博文可以在public直接执行后三条命令add,commit,push即可。 记得draft改为false ","date":"2020-07-03","objectID":"/hugo-blog-site/:8:0","tags":null,"title":"使用 Hugo + Github Pages 搭建个人博客","uri":"/hugo-blog-site/"},{"categories":null,"content":"this is wenzhe’s about ","date":"2020-07-02","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"}]