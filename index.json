[{"categories":null,"content":"什么是数据倾斜？ 对于Spark/Hadoop等分布式系统，机器间工作量的不均匀比单纯的工作量大更难处理，因为单纯的工作量大基本通过scale-out就可以解决。假设有100个任务并行处理，若任务间工作量相当，20台机器要比10台机器耗时减半（假设机器性能相当）。然而当任务间工作量相差巨大时（例如，任务中10个大任务，90个小任务，工作量差别1M倍），很难通过scale-out的方式充分利用并行优势，此时，完成总耗时取决于最慢的大任务何时完成（木桶原理）。 对于Spark这种计算引擎，工作量主要在于所需处理的数据量。因此当任务划分时，数据分布不均匀，即发生了数据倾斜。 ","date":"2020-08-30","objectID":"/spark-data-skew/:1:0","tags":["spark"],"title":"Spark: N Ways to Optimize Data Skew","uri":"/spark-data-skew/"},{"categories":null,"content":"数据是如何倾斜的？ 当Spark产生shuffle操作时，相同key的数据会被放在相同的partition。因此当某一个key的数据量过大（即popular key），会造成partition间工作量巨大差别，造成数据倾斜。这样不仅影响了并行效率，更加容易造成内存不足，产生OOM（Out Of Memory）报错使整个应用崩溃。 常见会触发shuffle的算子：distinct, groupByKey, reduceByKey, aggregateByKey, join, cogroup, repartition。 ","date":"2020-08-30","objectID":"/spark-data-skew/:2:0","tags":["spark"],"title":"Spark: N Ways to Optimize Data Skew","uri":"/spark-data-skew/"},{"categories":null,"content":"如何识别数据倾斜？ 观察stage进度条，发现大多数task很快执行完，但是剩余task等待时间巨长甚至出现OOM报错。（如上图） 查看Spark Web UI里的Shuffle Read Size/Records，查看任务间数据量分布是否均匀。 计算key的分布。（如下） df.select(\"key\").sample(false, 0.1) // 数据采样 .(k =\u003e (k, 1)).reduceBykey(_ + _) // 统计 key 出现的次数 .map(k =\u003e (k._2, k._1)).sortByKey(false) // 根据 key 出现次数进行排序 .take(10) // 取前 10 个。 ","date":"2020-08-30","objectID":"/spark-data-skew/:3:0","tags":["spark"],"title":"Spark: N Ways to Optimize Data Skew","uri":"/spark-data-skew/"},{"categories":null,"content":"发生了数据倾斜怎么办？ ","date":"2020-08-30","objectID":"/spark-data-skew/:4:0","tags":["spark"],"title":"Spark: N Ways to Optimize Data Skew","uri":"/spark-data-skew/"},{"categories":null,"content":"思路1 - 过滤异常数据 如果数据包含大量异常key，过滤掉就好了。 异常key： 空值 Null 无效数据，大量重复的测试数据或是对结果影响不大的有效数据 有效数据，业务导致的正常数据分布 对于情况1\u00262，直接过滤即可。对于3，直接过滤不适用，尝试以下其他方法。 ","date":"2020-08-30","objectID":"/spark-data-skew/:4:1","tags":["spark"],"title":"Spark: N Ways to Optimize Data Skew","uri":"/spark-data-skew/"},{"categories":null,"content":"思路2 - 提高shuffle并行度 通过增加partition的方法，让每个task执行更少的不同key，把原本被分配到同一task的不同key分配到不同task。 RDD 操作 可在需要 Shuffle 的操作算子上直接设置并行度或者使用 spark.default.parallelism 设置。如果是 Spark SQL，还可通过 SET spark.sql.shuffle.partitions=[num_tasks] 设置并行度。默认参数由不同的 Cluster Manager 控制。 dataFrame 和 sparkSql 可以设置 spark.sql.shuffle.partitions=[num_tasks] 参数控制 shuffle 的并发度，默认为200。 TIPS 可以把数据倾斜类比为 hash 冲突。提高并行度就类似于 提高 hash 表的大小。 ","date":"2020-08-30","objectID":"/spark-data-skew/:4:2","tags":["spark"],"title":"Spark: N Ways to Optimize Data Skew","uri":"/spark-data-skew/"},{"categories":null,"content":"思路3 - 自定义Partitioner ","date":"2020-08-30","objectID":"/spark-data-skew/:4:3","tags":["spark"],"title":"Spark: N Ways to Optimize Data Skew","uri":"/spark-data-skew/"},{"categories":null,"content":"思路4 - Broadcast机制 对于Join算子，若一边数据足够小到放入内存，可以通过Broadcast方法广播到Worker中。这样的Broadcast Join完全避免了shuffle，彻底消除了数据倾斜产生的条件。 from pyspark.sql.functions import broadcast result = broadcast(A).join(B, [\"join_col\"], \"left\") ","date":"2020-08-30","objectID":"/spark-data-skew/:4:4","tags":["spark"],"title":"Spark: N Ways to Optimize Data Skew","uri":"/spark-data-skew/"},{"categories":null,"content":"思路5 - 拆分join再union 对于Join算子，若一边数据倾斜，另一边数据均匀，且无法map端join（broadcast），可以把两边大表各拆分为popular key与unpopular key部分，分别join再union。 join例子： left （数据倾斜）和 right（数据均匀） 采样统计left中Top K popular key，把两表按照key是否popular分拆 left = leftSkew + leftUnskew right = rightSkew + rightUnskew 左加盐，右膨胀 对leftSkew加盐，即key -\u003e (key, rand(N)), 这样大key会被分配到不同partition 对rightSkew做flatMap操作把每条数据转化为N条数据，即key -\u003e (key, 1), (key, 2), ... (key, N) 分别join再union，即Union ( Join(leftSkew, rightSkew), Join(leftUnskew, rightUnskew) ) ","date":"2020-08-30","objectID":"/spark-data-skew/:4:5","tags":["spark"],"title":"Spark: N Ways to Optimize Data Skew","uri":"/spark-data-skew/"},{"categories":null,"content":"思路6 - 大表key加盐，小表扩大N倍join 对于数据倾斜表中key都很大的情况，分拆popular key与unpopular key意义不大。可直接对大表整体加盐，小表扩大N倍后再join，即此思路为思路5的局部优化Join(leftSkew, rightSkew)。 例子 创建两个表来模拟，其中大表数据倾斜，小表相对均匀 from math import exp from random import randint from datetime import datetime def count_elements(splitIndex, iterator): n = sum(1 for _ in iterator) yield (splitIndex, n) def get_part_index(splitIndex, iterator): for it in iterator: yield (splitIndex, it) num_parts = 18 # create the large skewed rdd skew_rdd = sc.parallelize(range(0,num_parts), num_parts).flatMap(lambda x: range(0, int(exp(x)))) skew_rdd = skew_rdd.mapPartitionsWithIndex(lambda idx, x: get_part_index(idx, x)) skew_df = spark.createDataFrame(skewed_large_rdd,['x','y']) small_rdd = sc.parallelize(range(0,num_parts), num_parts).map(lambda x: (x, x)) small_df = spark.createDataFrame(small_rdd,['a','b']) # skew_df: small_df: # x, y a, b # ==== ==== # 0, 0 0, 0 # 1, 0 1, 1 # 1, 1 2, 2 # 2, 0 3, 3 # 2, 1 4, 4 # 2, 2 5, 5 # 2, 3 6, 6 # 2, 4 7, 7 # 2, 5 8, 8 # 2, 6 9, 9 # ... ... 大表key加盐，小表扩大N（=100）倍 salt_bins = 100 from pyspark.sql import functions as F skew_df_salt = skew_df.withColumn('salt', (F.rand()*salt_bins).cast('int')).cache() small_df_rep = small_df.withColumn('replicate', F.array([F.lit(i) for i in range(salt_bins)])) small_df_rep = small_df_rep.select('*', F.explode('replicate').alias('salt')).drop('replicate').cache() # skew_df: small_df: # x, y, salt a, b, salt # ========== ========== # 0, 0, 24 0, 0, 0 # 1, 0, 53 0, 0, 1 # 1, 1, 24 0, 0, 2 # 2, 0, 37 0, 0, 3 # 2, 1, 99 0, 0, 4 # 2, 2, 87 0, 0, 5 # 2, 3, 14 0, 0, 6 # 2, 4, 94 0, 0, 7 # 2, 5, 12 0, 0, 8 # 2, 6, 5 0, 0, 9 # ... ... 最后join %%time # measure excution time in jupyter notebook res = skew_df_salt.join(small_df_rep, (skew_df_salt['x'] == small_df_rep['a'])\\ \u0026 (skew_df_salt['salt'] == small_df_rep['salt'])) res.count() # res: # x, y, b # ========= # 0, 0, 0 # 1, 0, 1 # 1, 1, 1 # 2, 0, 2 # 2, 1, 3 # 2, 2, 2 # 2, 3, 2 # 2, 4, 2 # 2, 5, 2 # 2, 6, 2 # ... ","date":"2020-08-30","objectID":"/spark-data-skew/:4:6","tags":["spark"],"title":"Spark: N Ways to Optimize Data Skew","uri":"/spark-data-skew/"},{"categories":null,"content":"思路7 - map端先局部聚合 ","date":"2020-08-30","objectID":"/spark-data-skew/:4:7","tags":["spark"],"title":"Spark: N Ways to Optimize Data Skew","uri":"/spark-data-skew/"},{"categories":null,"content":"思路8 - 加盐局部聚合 + 去盐全局聚合 ","date":"2020-08-30","objectID":"/spark-data-skew/:4:8","tags":["spark"],"title":"Spark: N Ways to Optimize Data Skew","uri":"/spark-data-skew/"},{"categories":null,"content":"参考 Arganzheng’s Blog, Spark数据倾斜及其解决方案 ","date":"2020-08-30","objectID":"/spark-data-skew/:5:0","tags":["spark"],"title":"Spark: N Ways to Optimize Data Skew","uri":"/spark-data-skew/"},{"categories":null,"content":"什么是Job, Stage, Task? Spark数据处理是像流水线一样，通过一系列操作（算子）完成对RDD的处理, 即RDD1 -\u003e RDD2 -\u003e ...。操作分为两类：Transformation和Action。Spark使用lazy evaluation模式，即Transformation操作下达后，实际并不立刻运行，只有当遇到Action时才把之前所有的Transformation和当前Action运行完毕。每当一个Action触发，就会生成一个Job。因此Job以Action划分。Job之间是串行的，只有当前job结束，才会启动下一个job。 一个Job会被划分为一个或多个stage。在一个stage中，任务是可以并行计算的。stage是按照ShuffleDependency来进行划分的。两种依赖方式为窄依赖（narrow dependency）与宽依赖（wide dependency）。区分两种依赖的方法是看：父RDD的partition是否被多个（\u003e1）子RDD的partition使用，若未被多个子RDD的partition使用，则为窄依赖，不需shuffle，不划分stage； 否则为宽依赖，划分stage。上图对比了两种依赖方式的不同。具体划分stage的算法是: 从最后一个RDD开始，从后往前推，找该RDD和父RDD之间的依赖关系，如果是窄依赖，会继续找父RDD的父RDD，如果是宽依赖，就会从该RDD开始到前面所有的RDD划分为一个stage，递归的出口是直到找不到父RDD，最后把所有的RDD划分为一个stage。 一个例子： 一个stage并行的任务称为task，对应一个partition的处理，即task总数为stage的partition总数。 ","date":"2020-08-29","objectID":"/spark-fundamentals/:1:0","tags":["spark"],"title":"Spark FAQ","uri":"/spark-fundamentals/"},{"categories":null,"content":"参考 Wide vs Narrow Dependencies github blog stackoverflow, Does stages in an application run parallel in spark Queirozf Apache Spark Architecture Overview: Jobs, Stages, Tasks, etc cnblogs, qingyunzong csdn, Z_Data Spark by Examples, Spark Repartition vs Coalesce Arganzheng’s Blog, Spark数据倾斜及其解决方案 ","date":"2020-08-29","objectID":"/spark-fundamentals/:2:0","tags":["spark"],"title":"Spark FAQ","uri":"/spark-fundamentals/"},{"categories":null,"content":"目录结构 /bin (/usr/bin, /usr/local/bin): binary,存放最经常使用的命令 /sbin (/usr/sbin, /usr/local/sbin): s: super user, 存放系统管理员使用的系统管理程序 /home: 存放普通用户的主目录，每个用户都有一个自己的目录 /root: 超级权限者的用户主目录(This is not the root (/) filesystem. It is the home directory for the root user.) /lib: 系统开机所需要最基本的动态连接共享库，类似Windows的DLL文件。几乎所有应用程序都需要用到这些共享库 /etc: 系统管理所需要的配置文件和子目录 /usr: 用户的很多应用程序和文件都放在这个目录下，类似Windows的program files目录 /proc,/srv,/sys: 内核相关目录（不要轻易修改） /dev: 硬件以文件的形式存放在该处 /media: U盘，光驱，等等 /mnt: 用户临时挂载的文件系统 /opt: 存放安装软件 /usr/local: 存放安装软件所安装的目录，一般是通过编译源码的方式安装的程序 /var: 存放经常被修改的东西，比如日志文件 ","date":"2020-08-19","objectID":"/linux-intro/:1:0","tags":["linux"],"title":"Linux入门","uri":"/linux-intro/"},{"categories":null,"content":"Vi/Vim快捷键 拷贝当前行yy, 拷贝当前行以下的5行5yy,粘贴p 删除当前行dd, 删除当前行以下的5行5dd 查找关键词/keyword,下一个出现n 显示行号:set nu,隐藏行号:set nonu 阅览最首行gg最末行G 撤销输入动作u 移动光标至第20行20+shift g ","date":"2020-08-19","objectID":"/linux-intro/:2:0","tags":["linux"],"title":"Linux入门","uri":"/linux-intro/"},{"categories":null,"content":"开关重启命令 sync # 把内存数据同步到磁盘，以下操作前先执行该命令 shutdown -h now # 立即关机 shutdown -h 1 # 1min 关机 shutdown -r now # 立即重启 halt # 等同于关机 reboot # 立即重启 ","date":"2020-08-19","objectID":"/linux-intro/:3:0","tags":["linux"],"title":"Linux入门","uri":"/linux-intro/"},{"categories":null,"content":"用户管理 useradd xiaoming # 自动创建home下同名目录 passwd xiaoming # 指定密码 userdel xiaoming # 删除用户xiaoming，home下其目录会保留 userdel -r xiaoming # 删除用户xiaoming，home下其目录不会保留 su - xiaoming # 切换用户登陆， 权限不足会给提示，exit返回到原先用户 groupadd zuming # 创建组 groupdel zuming # 删除组 useradd -g zuming xiaoming # 创建用户时，指定组 id xiaoming # 查询用户信息 usermod -g zuming2 xiaoming # 修改用户所在组 用户配置文件在： /etc/passwd （用户id，组id，家目录，shell） 组配置文件在：/etc/group 口令配置文件（密码，登录信息）：/etc/shadow(加密的) ","date":"2020-08-19","objectID":"/linux-intro/:4:0","tags":["linux"],"title":"Linux入门","uri":"/linux-intro/"},{"categories":null,"content":"实用命令 man ls # 显示ls用法 help cd # 显示cd用法 touch filename # 创建空文件 cat -n filename ｜ more # 打开文件内容（只读方式）, -n 显示行号，more分页显示 more filename # 按页显示文件，空格翻页，Enter下一行，ctrl+f/b less filename # 分页查看，lazy加载，利于显示大文件 \"less is more\" ls -l \u003e filename # 重定向（覆盖） ls -l \u003e\u003e filename # 追加（append到尾部） head -n 5 filename # 只显示文件前5行（默认10行） tail -n 5 filename # 只显示文件后5行（默认10行） -f追踪文件更新，日志监控经常用 date \"+%Y-%m-%d %H:%M:%S\" # 按格式显示当前年月日时分秒，“+”必要， -s设定 cal # 显示当前日历 find [scope] [-name 文件名, -user 用户, -size 文件大小] grep [-n 显示匹配行行号， -i 忽略大小写] 查找内容 源文件 cat hello.txt | grep -ni yes # 在hello.txt中，不区分大小写的查找yes grep -r [keyword] /data/reports zip -r xxx.zip files unzip -d 位置 xxx.zip tar -zcvf a.tar.gz a1.txt a2.txt tar -zxvf a.tar.gz ","date":"2020-08-19","objectID":"/linux-intro/:5:0","tags":["linux"],"title":"Linux入门","uri":"/linux-intro/"},{"categories":null,"content":"组管理，权限管理 在linux中的每个用户必须属于一个组，不能独立于组外。在linux中每个文件有所有者，所在组，其他组的概念。 ","date":"2020-08-19","objectID":"/linux-intro/:6:0","tags":["linux"],"title":"Linux入门","uri":"/linux-intro/"},{"categories":null,"content":"任务调度 crontab -e crontab -l crontab -r 45 22 * * * 在22点45分执行 0 17 * * 1 每周一17点0分执行 0 5 1,15 * * 每月1号15号凌晨5点执行 40 4 * * 1-5 每周一到周五凌晨4点40分执行 */10 4 * * * 每天凌晨4点每隔10分执行一次 0 0 1,15 * 1 每月1号和15号，每周一的0点0分执行。星期几和几号最好不要同时出现，容易混乱 ","date":"2020-08-19","objectID":"/linux-intro/:7:0","tags":["linux"],"title":"Linux入门","uri":"/linux-intro/"},{"categories":null,"content":"进程管理 ps -a/u/x | more ps -ef | grep sshd # 查看sshd的父进程ID kill [pid] pstree -p top netstat -anp | more # 查看网络服务 USER 用户名称 PID 进程号 %CPU 进程占用CPU的百分比 %MEM 进程占用物理内存的百分比 VSZ 进程占用的虚拟内存大小（KB） RSS 进程占用的物理内存大小（KB） TT 终端名称 STAT 进程状态 S-睡眠 R-正在运行 Z-僵死 STARTED 进程的启动时间 TIME 使用CPU总时间 COMMAND 启动进程的命令和参数 ","date":"2020-08-19","objectID":"/linux-intro/:8:0","tags":["linux"],"title":"Linux入门","uri":"/linux-intro/"},{"categories":null,"content":"服务管理 开机流程： 开机 -\u003e BIOS -\u003e /boot -\u003e init process (1) -\u003e 运行级别 -\u003e 运行级别对应的服务 service [service name] start|stop|restart|reload|status ls -l /etc/init.d chkconfig --list 服务的运行级别(runlevel)： 运行级别0: 系统停机状态，系统默认运行级别不能设为0，否则不能正常启动 运行级别1: 单用户工作状态，root权限，用于系统维护，禁止远程登录 运行级别2: 多用户状态（没有NFS），不支持网络 运行级别3: 完全的多用户状态（有NFS），登陆后进入控制台命令行模式 运行级别4: 系统未使用，保留 运行级别5: X11控制台，登陆后进入图形GUI模式 运行级别6: 系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动 ","date":"2020-08-19","objectID":"/linux-intro/:9:0","tags":["linux"],"title":"Linux入门","uri":"/linux-intro/"},{"categories":null,"content":"Ubuntu su root # 切换root用户，因为初始root未设置密码，提示错误 sudo passwd # 设置root密码 su root # 切换root用户，设置root密码后可以成功切换 ","date":"2020-08-19","objectID":"/linux-intro/:10:0","tags":["linux"],"title":"Linux入门","uri":"/linux-intro/"},{"categories":null,"content":"什么是精确率（precision）与召回率（recall）？ Precision和Recall是衡量模型预测能力的指标。在简单的分类问题（种类数=2）中，根据实际答案与模型预测，可分为如下4种情况： True Positive (TP) - 正确预测了阳类 True Negative (TN) - 正确预测了阴类 False Positive (FP) - 错误预测了阳类（实际为阴类） False Negative (FN) - 错误预测了阴类（实际为阳类） 注：True和False表示预测是否正确，Positive和Negative表示预测结果 精准率和召回率定义： Precision = TP / (TP + FP) Recall = TP / (TP + FN) 他们区别在分母不同，所取值范围均为0～1 ","date":"2020-08-12","objectID":"/precision-recall/:1:0","tags":["Machine Learning"],"title":"Precision和Recall","uri":"/precision-recall/"},{"categories":null,"content":"如何理解Precision和Recall？ 信息检索中，Precision又叫查准率（找得对），Recall又叫查全率（找得全）。 举个例子，池塘有大龙虾30只，小龙虾70只。我们发明了一只捕大龙虾神器专捕大龙虾。神器一网下去，捕到大龙虾20只，小龙虾5只。那么： 精准率 = 20 /（20 + 5） = 0.80 召回率 = 20 / 30 = 0.67 我们来看3个极端神器的Precision和Recall。 神器谨慎版：只捕了一只，且为大龙虾。Precision = 1/1 = 1.0, Recall = 1/30 = 0.033 神器电鱼版：捕了全池塘的100只。Precision = 30/100 = 0.3, Recall = 30/30 = 1.0 神器专业版：补了30只，且全为大龙虾。Precision = 30/30 = 1.0, Recall = 30/30 = 1.0 实际应用中，Precision和Recall往往不能兼得。有时我们更在意Precision，而有时我们更在意Recall。比如判断视频是否适合儿童观看（适合-正，不适合-负），我们更青睐high precision - low recall的分类器（声称安全的视频真是安全的，但可能也拦截了其他安全的视频）。再比如报警器判断是否有小偷（有小偷-正，无小偷-负），我们更青睐low precision - high recall的警报器（声称有小偷的时候可能是误报，但是真有小偷的时候它通常会响）。 ","date":"2020-08-12","objectID":"/precision-recall/:2:0","tags":["Machine Learning"],"title":"Precision和Recall","uri":"/precision-recall/"},{"categories":null,"content":"PR曲线 机器学习模型往往先预测概率（scoring），再根据概率决策分类（label）。比如score高于threshold输出positive，低于输出negative。这样Precision与Recall将是Threshold的函数，即P(t)和R(t)。如果把P(t)和R(t)作为坐标画在坐标中,就形成了PR曲线，其中(1,1)为理想点。我们可以用PR曲线下的面积（AUPR）来衡量模型表现。 相比于ROC曲线，PR曲线对不平衡数据集的性能描述更为准确。 ","date":"2020-08-12","objectID":"/precision-recall/:3:0","tags":["Machine Learning"],"title":"Precision和Recall","uri":"/precision-recall/"},{"categories":null,"content":"参考 如何解释召回率与精确率？ - 知乎 推荐系统评测指标—准确率(Precision)、召回率(Recall)、F值(F-Measure) ","date":"2020-08-12","objectID":"/precision-recall/:4:0","tags":["Machine Learning"],"title":"Precision和Recall","uri":"/precision-recall/"},{"categories":null,"content":"什么是Cookie ","date":"2020-08-09","objectID":"/cookie-track-user/:1:0","tags":["AdTech"],"title":"网络广告是如何用cookie来追踪用户的？","uri":"/cookie-track-user/"},{"categories":null,"content":"参考 Web客户端追踪(上)-Cookie追踪 网络广告代理商是如何通过 cookie 收集用户信息的？ - LO的回答 - 知乎 RTB广告竞价系统的算法介绍 你是如何被广告跟踪的？ - 巴伐利亚啤酒馆的文章 - 知乎 第一方Cookie和第三方Cookie 第一方Cookie与第三方Cookie的区别 第一方和第三方cookie是什么？ ETP,ITP,NO-TP,是时候把第三方Cookie讲清楚了 ","date":"2020-08-09","objectID":"/cookie-track-user/:2:0","tags":["AdTech"],"title":"网络广告是如何用cookie来追踪用户的？","uri":"/cookie-track-user/"},{"categories":null,"content":"PySpark的特性 Immutable Changes create new object references Old versions are unchanged Lazy Compute does not happen until output is requested ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:1:0","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"Pandas VS PySpark ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:2:0","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"Load CSV # Pandas df = pd.read_csv(\"datafile.csv\") # PySpark df = spark.read.options(header=True, inferSchema=True).csv(\"datafile.csv\") ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:2:1","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"View Dataframe # Pandas df # PySpark df.show() ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:2:2","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"Columns \u0026 Data Types # Pandas df.columns df.dtypes # PySpark df.columns df.dtypes ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:2:3","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"Rename Columns # Pandas df.columns = ['a', 'b', 'c'] df.rename(columns = {'old': 'new'}) # PySpark df.toDF('a', 'b', 'c') df.withColumnRenamed('old', 'new') ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:2:4","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"Drop Columns # Pandas df.drop('colx', axis=1) # PySpark df.drop('colx') ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:2:5","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"Filtering # Pandas df[df.col1 \u003c 20] df[(df.col1 \u003c 20) \u0026 (df.col2 == 6)] # 注意括号 # PySpark df[df.col1 \u003c 20] df[(df.col1 \u003c 20) \u0026 (df.col2 == 6)] # 注意括号 ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:2:6","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"Add Column # Pandas df['col3'] = 1 / df.col1 # 除以0得infty # PySpark df.withColumn('col3', 1 / df.col1) # 除以0得Null ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:2:7","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"Fill Nulls # Pandas df.fillna(0) # more options # PySpark df.fillna(0) ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:2:8","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"Aggregation # Pandas df.groupby(['col1', 'col2']).agg({'col3': 'mean', 'col4': 'min'}) # PySpark df.groupby(['col1', 'col2']).agg({'col3': 'mean', 'col4': 'min'}) ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:2:9","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"标准的转化 # Pandas import numpy as np df['logCol'] = np.log(df.col) # PySpark import pyspark.sql.functions as F df.withColumn('logCol', F.log(df.col)) 使用pyspark.sql.functions里的函数，可以直接调用JVM，即Java引擎，而非使用较慢的python。 例子Row Conditional Statements # Pandas df['status'] = df.apply(lambda r: 1 if r.col1 \u003e 20 else 2 if r.col2 == 6 else 3, axis=1) # PySpark import pyspark.sql.functions as F df.withColumn('status', \\ F.when(df.col1 \u003e 20, 1) \\ .when(df.col2 == 6, 2) \\ .otherwise(3)) ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:3:0","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"更复杂的转化，python必要时 # Pandas df['col5'] = df.col1.apply(lambda x : x + 1) # PySpark import pyspark.sql.functions as F from pyspark.sql.types import DoubleType # udf必须deterministic，pyspark优化默认相同运算结果相同 fn = F.udf(lambda x : x + 1, DoubleType()) df.withColumn('col5', fn(df.col1)) ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:4:0","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"Join # Pandas leftDF.merge(rightDF, on='key') leftDF.merge(rightDF, left_on='a', right_on='b') # PySpark leftDF.join(rightDF, on='key') leftDF.join(rightDF, leftDF.a == rightDF.b) 默认为inner join ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:5:0","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"统计 # Pandas df.describe() # PySpark df.describe().show() df.selectExpr(\"percentile_approx(col1, array(.25, .5, .75)) as col1\").show() ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:6:0","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"统计图 # Pandas df.hist() # PySpark df.sample(False, 0.1).toPandas().hist() ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:7:0","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"SQL # Pandas NA # PySpark df.createOrReplaceTempView('foo') df2 = spark.sql('select * from foo') ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:8:0","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"使用习惯 使用pyspark.sql.functions内置函数。 在cluster中保持和driver相同的版本和库。 观测状态http://localhost:4040/ Learn about SSH port forwarding 不要： Try to iterate through rows Hard code a master in your dirver Use spark-submit for that df.toPandas().head() instead do: df.limit(5).toPandas() 参考 Spark Submit 2017 ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:9:0","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":" The git directory acts as a database for all the changes tracked in Git and the working tree acts as a sandbox where we can edit the current versions of the files. ","date":"2020-07-28","objectID":"/git-github/:0:0","tags":["git"],"title":"Git与Github使用","uri":"/git-github/"},{"categories":null,"content":"1. 基本操作 git init # 创建仓库 # 登陆当前操作系统的用户范围 (否则为项目级别) git config --global user.name \"My Name\" git config --global user.email \"me@example.com\" git status # 显示 working tree, staging area # 创建文件new-file.py git add new-file.py git commit -m \"[message]\" git status # 修改new-file.py git commit -a -m \"[messsage]\" # -a: shortcut of \"git add, git commit\" for the modified git log # 查看提交(当前分支) git log --oneline # 查看提交（简洁显示） git reflog # 查看HEAD曾经经过的commit # throws away unstaged changes, younger commits becomes dangling (can be retrieved via reflog if within days) git reset --hard [commitID] git reset --hard HEAD^^^ # back 3 commits git reset --hard HEAD~[n] # back n commits git diff file.py # compare file.py between work tree and staging area git diff HEAD file.py # compare between work tree and HEAD commit git show commitID # show details (+-) for one specific commit git mv file.py newname.py # rename a file git rm newname.py # remove a file ","date":"2020-07-28","objectID":"/git-github/:1:0","tags":["git"],"title":"Git与Github使用","uri":"/git-github/"},{"categories":null,"content":"2. 分支合并 git branch -v # 查看分支 git branch feature # 创建分支feature git checkout feature # 切换分支feature git checkout -b feature # 创建并切换分支feature git branch -d feature # 删除分支feature # 合并： 切换到接受修改的分支（e.g. master）增加新内容(e.g. feature上的新内容) git checkout master git merge feature # 冲突 # \u003c\u003c\u003c\u003c\u003c\u003c\u003c HEAD # abc (当前分支修改) # ======= # def (并入分支修改) # \u003e\u003e\u003e\u003e\u003e\u003e\u003e feature git add files git commit -m \"conflict resolved, merging -\u003e merged\" ","date":"2020-07-28","objectID":"/git-github/:2:0","tags":["git"],"title":"Git与Github使用","uri":"/git-github/"},{"categories":null,"content":"3. 远程合作 git remote -v # 查看本地保存的远程库地址 git remote add origin https://github.com/[username]/[reponame].git git push origin master git clone https://github.com/[username]/[reponame].git # pull = fetch + merge git fetch origin master git checkout origin/master git merge origin/master git pull origin master # 如果不是基于Github远程库的最新版所做的修改，不能推送，必须先pull # pull后如果进入冲突状态，则解决冲突后即可再推送(git commit, git push) # 跨团队协作 1) fork 2) clone 3) modified 4) pull request ","date":"2020-07-28","objectID":"/git-github/:3:0","tags":["git"],"title":"Git与Github使用","uri":"/git-github/"},{"categories":null,"content":"4. 工作流 Steps: (junior)创建分支feature (junior)推送feature分支 (senior)切换分支，审查代码 (senior)切换master，合并feature (senior)推送master分支 TODO ","date":"2020-07-28","objectID":"/git-github/:4:0","tags":["git"],"title":"Git与Github使用","uri":"/git-github/"},{"categories":null,"content":"撤销 git checkout unstaged.py # revert unstaged changes git reset HEAD staged.py # revert staged changes # overwrite the previous commit with staged changes. # ONLY LOCAL: avoid amending commits that have already been made public git commit --amend git revert HEAD # roll back to previous commit git revert commitID # roll back ","date":"2020-07-28","objectID":"/git-github/:5:0","tags":["git"],"title":"Git与Github使用","uri":"/git-github/"},{"categories":null,"content":"远程 git push # push changes to remote repo “origin” is the default name for the remote repo git remote -v # list remote repos verbosely git remote show origin # describe a single remote repo git branch -r # list remote branches What’s the main difference between git fetch and git pull? git fetch fetches remote updates but doesn’t merge; git pull fetches remote updates and merges. git fetch git log origin/master git merge origin/master # merge into local git remote update will update all of your branches set to track remote ones, but not merge any changes in. git fetch will update only the branch you’re on, but not merge any changes in. git pull will update and merge any remote changes of the current branch you’re on. This would be the one you use to update a local branch. git log --graph --oneline --all git log -p origin/master git push -u origin new-feature # push to \"origin\" remote repo, with \"new-feature\" branch Rebasing instead of merging rewrites history and maintains linearity, making for cleaner code. git checkout new-feature git rebase master git log --graph --oneline git checkout master git merge new-feature # fast forward merge, linear history git push --delete origin new-feature # delete remote branch git branch -d new-feature # delete local branch git fetch git rebase origin/master git add health_checks.py git rebase --continue ","date":"2020-07-28","objectID":"/git-github/:6:0","tags":["git"],"title":"Git与Github使用","uri":"/git-github/"},{"categories":null,"content":"参考 Git scm official Understanding branches in Git CS Visualized: Useful Git Commands - Lydia Hallie What is the difference between ‘git remote update’, ‘git fetch’ and ‘git pull’? Listing and deleting Git commits that are under no branch (dangling?) How can I undo git reset –hard HEAD~1? How do I check out a remote Git branch? ","date":"2020-07-28","objectID":"/git-github/:7:0","tags":["git"],"title":"Git与Github使用","uri":"/git-github/"},{"categories":null,"content":" while位 ","date":"2020-07-26","objectID":"/leetcode-bit-manipulation/:0:0","tags":["leetcode"],"title":"Leetcode：位运算","uri":"/leetcode-bit-manipulation/"},{"categories":null,"content":"342. Power of Four (easy) 简述：判断是否为4的幂 思路：mask挪位置 联系：出自693 # class Solution(object): # def isPowerOfFour(self, num): # \"\"\" # :type num: int # :rtype: bool # \"\"\" # base = 1 while base \u003c= num: # if base == num: # return True # 要点1-1: 偶数位为1 base \u003c\u003c= 2 # return False ","date":"2020-07-26","objectID":"/leetcode-bit-manipulation/:1:0","tags":["leetcode"],"title":"Leetcode：位运算","uri":"/leetcode-bit-manipulation/"},{"categories":null,"content":"476. Number Complement (easy) 简述：将所给数二进制取反输出对应十进制 思路：利用stack 联系：出自342 # class Solution(object): # def findComplement(self, num): # \"\"\" # :type num: int # :rtype: int # \"\"\" # stack = [] # while num: # stack.append(1 ^ (num \u0026 1)) # num = num \u003e\u003e 1 # res = 0 # while stack: res = (res \u003c\u003c 1) + stack.pop() # return res ","date":"2020-07-26","objectID":"/leetcode-bit-manipulation/:2:0","tags":["leetcode"],"title":"Leetcode：位运算","uri":"/leetcode-bit-manipulation/"},{"categories":null,"content":"693. Binary Number with Alternating Bits (easy) 简述：判断所给数二进制是否间隔均不同，即...0101...或者...1010... 思路：while异常退出，逐位判断 联系：342 # class Solution(object): # def hasAlternatingBits(self, n): # \"\"\" # :type n: int # :rtype: bool # \"\"\" # state = n \u0026 1 # while n: # n = n \u003e\u003e 1 # 要点1-1: python位与，位xor if state ^ (n \u0026 1) != 1: # return False # state ^= 1 # return True ","date":"2020-07-26","objectID":"/leetcode-bit-manipulation/:3:0","tags":["leetcode"],"title":"Leetcode：位运算","uri":"/leetcode-bit-manipulation/"},{"categories":null,"content":"477. Total Hamming Distance (medium) 简述：求所有数对hamming距离之和 思路：找出每一位位置上，多少个数为1或为0 联系：342 # class Solution(object): # def totalHammingDistance(self, nums): # \"\"\" # :type nums: List[int] # :rtype: int # \"\"\" # res = 0 # for i in range(32): countZeros = sum([x \u0026 (1\u003c\u003ci) == 0 for x in nums]) res += countZeros * (len(nums) - countZeros) # return res ","date":"2020-07-26","objectID":"/leetcode-bit-manipulation/:4:0","tags":["leetcode"],"title":"Leetcode：位运算","uri":"/leetcode-bit-manipulation/"},{"categories":null,"content":"201. Bitwise AND of Numbers Range (medium) 简述：求区间内所有数位AND值 思路：只要区间跨过1，末位AND值为0，递归求解 联系： # class Solution(object): # def rangeBitwiseAnd(self, m, n): # \"\"\" # :type m: int # :type n: int # :rtype: int # \"\"\" # if m == n: # return m # if n == m + 1: # return m \u0026 n # 要点1-1: 区间跨过1，末位AND值为0，递归 return self.rangeBitwiseAnd(m \u003e\u003e 1, n \u003e\u003e 1) \u003c\u003c 1 与关系 ","date":"2020-07-26","objectID":"/leetcode-bit-manipulation/:5:0","tags":["leetcode"],"title":"Leetcode：位运算","uri":"/leetcode-bit-manipulation/"},{"categories":null,"content":"191. Number of 1 Bits (easy) 简述：求所给数二进制里多少位是1 思路：n \u0026 (n-1)去掉最后一位1 联系： # class Solution(object): # def hammingWeight(self, n): # \"\"\" # :type n: int # :rtype: int # \"\"\" # res = 0 # while n: # n \u0026 (n-1) 去掉最后一位1 n = n \u0026 (n - 1) # res += 1 # return res ","date":"2020-07-26","objectID":"/leetcode-bit-manipulation/:6:0","tags":["leetcode"],"title":"Leetcode：位运算","uri":"/leetcode-bit-manipulation/"},{"categories":null,"content":"231. Power of Two (easy) 简述：判断是否为2的幂 思路：二进制中有且仅有1个1 联系：出自191 # class Solution(object): # def isPowerOfTwo(self, n): # \"\"\" # :type n: int # :rtype: bool # \"\"\" # return n \u0026 (n-1) == 0 and n != 0 ","date":"2020-07-26","objectID":"/leetcode-bit-manipulation/:7:0","tags":["leetcode"],"title":"Leetcode：位运算","uri":"/leetcode-bit-manipulation/"},{"categories":null,"content":"461. Hamming Distance (easy) 简述：求所给数对的hamming distance 思路：先亦或，再数多少个1 联系：出自191 # class Solution(object): # def hammingDistance(self, x, y): # \"\"\" # :type x: int # :type y: int # :rtype: int # \"\"\" num = x ^ y # res = 0 # while num: num = num \u0026 (num - 1) # res += 1 # return res 异或关系 ","date":"2020-07-26","objectID":"/leetcode-bit-manipulation/:8:0","tags":["leetcode"],"title":"Leetcode：位运算","uri":"/leetcode-bit-manipulation/"},{"categories":null,"content":"136. Single Number (easy) 简述：数组中除某元素外每个元素出现两次，找出该元素 思路：碰碰对 联系： # class Solution(object): # def singleNumber(self, nums): # \"\"\" # :type nums: List[int] # :rtype: int # \"\"\" res = 0 # for num in nums: # res ^= num # return res ","date":"2020-07-26","objectID":"/leetcode-bit-manipulation/:9:0","tags":["leetcode"],"title":"Leetcode：位运算","uri":"/leetcode-bit-manipulation/"},{"categories":null,"content":"389. Find the Difference (easy) 简述：字符串shuffle后添加一个字符，找出该字符 思路：碰碰对 联系：出自136 # class Solution(object): # def findTheDifference(self, s, t): # \"\"\" # :type s: str # :type t: str # :rtype: str # \"\"\" # res = 0 # # 要点1-1: python中ord与chr的使用 # for c in s: # res = res ^ ord(c) # for c in t: # res = res ^ ord(c) # return chr(res) ","date":"2020-07-26","objectID":"/leetcode-bit-manipulation/:10:0","tags":["leetcode"],"title":"Leetcode：位运算","uri":"/leetcode-bit-manipulation/"},{"categories":null,"content":" In-Order ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:0:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"230. Kth Smallest Element in a BST (medium) 简述：在BST中，求第k小的值 思路：inorder，记录遍历idx 联系：模板题 # class Solution(object): # def kthSmallest(self, root, k): # \"\"\" # :type root: TreeNode # :type k: int # :rtype: int # \"\"\" # self.idx, self.res = 0, None # self.k = k # self.inorder(root) # return self.res # def inorder(self, root): # if root is None or self.res is not None: # return # if self.res is not None: # return # self.inorder(root.left) # self.idx += 1 # if self.idx == self.k: # self.res = root.val # self.inorder(root.right) ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:1:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"938. Range Sum of BST (easy) 简述：求BST中值介于[L,R]的节点值的和 思路：inorder + 短路判断 联系：出自230 # class Solution(object): # def rangeSumBST(self, root, L, R): # \"\"\" # :type root: TreeNode # :type L: int # :type R: int # :rtype: int # \"\"\" # self.res = 0 # self.L, self.R = L, R # self.inorder(root) # return self.res # def inorder(self, root): # if root is None: # return # self.inorder(root.left) # if self.L \u003c= root.val \u003c= self.R: # self.res += root.val if root.val \u003e self.R: return # self.inorder(root.right) ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:2:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"538. Convert BST to Greater Tree (easy) 简述：改变BST各节点值，使得节点值为后缀和 思路：inorder从后到前遍历 联系：出自230 # class Solution(object): # def convertBST(self, root): # \"\"\" # :type root: TreeNode # :rtype: TreeNode # \"\"\" # self.running_total = 0 # self.inorder(root) # return root # def inorder(self, root): # if root is None: # return None # self.inorder(root.right) root.val += self.running_total self.running_total = root.val # self.inorder(root.left) ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:3:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"501. Find Mode in Binary Search Tree (easy) 简述：求BST中出现最多的值 思路：inorder建立字典 联系：出自230 # class Solution(object): # def findMode(self, root): # \"\"\" # :type root: TreeNode # :rtype: List[int] # \"\"\" # if root is None: # return [] # self.memo = dict() # self.inorder(root) # 要点2-1: python语法，总结value mode = max(self.memo.values()) res = [key for key in self.memo if self.memo[key] == mode] # return res # def inorder(self, root): # if root is None: # return # self.inorder(root.left) # 要点2-2: 异常if用来，初始化key不在字典中的情况 if root.val not in self.memo: self.memo[root.val] = 0 # self.memo[root.val] += 1 # self.inorder(root.right) ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:4:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"530. Minimum Absolute Difference in BST (easy) 简述：在BST节点对中，求最小的相差绝对值 思路：BST的in-order将返回排序数组 联系：出自230 # class Solution(object): # def getMinimumDifference(self, root): # \"\"\" # :type root: TreeNode # :rtype: int # \"\"\" # self.res = sys.maxsize self.prev = None # self.inorder(root) # return self.res # def inorder(self, root): # if root is None: # return # self.inorder(root.left) # if self.prev is not None: # self.res = min(self.res, abs(root.val - self.prev)) # self.prev = root.val # self.inorder(root.right) ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:5:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"783. Minimum Distance Between BST Nodes (easy) 简述：在BST节点对中，求最小的距离（相差） 思路：inorder，记录历史 联系：出自530 # class Solution(object): # def minDiffInBST(self, root): # \"\"\" # :type root: TreeNode # :rtype: int # \"\"\" # self.prev, self.res = None, sys.maxsize # self.inorder(root) # return self.res # def inorder(self, root): # if root is None: # return None # self.inorder(root.left) # if self.prev is not None: # self.res = min(self.res, root.val - self.prev) # self.prev = root.val # self.inorder(root.right) ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:6:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"897. Increasing Order Search Tree (easy) 简述：把BST变为单向链表 思路：记录遍历前的node 联系：出自530 # class Solution(object): # def increasingBST(self, root): # \"\"\" # :type root: TreeNode # :rtype: TreeNode # \"\"\" # self.dummy = TreeNode(0) # self.p = self.dummy # self.inorder(root) # return self.dummy.right # def inorder(self, root): # if root is None: # return # self.inorder(root.left) root.left, self.p.right, self.p.left = None, root, None self.p = self.p.right # self.inorder(root.right) Pre-Order ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:7:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"144. Binary Tree Preorder Traversal (medium) 简述：二叉树pre-order遍历 思路：recursive简单，主要尝试iterative 联系： # class Solution(object): # def preorderTraversal(self, root): # \"\"\" # :type root: TreeNode # :rtype: List[int] # \"\"\" # if root is None: # return [] # 要点1-1: 用stack存待搜索树 stack = [root] # res = [] # while stack: # node = stack.pop() # res.append(node.val) # if node.right is not None: # stack.append(node.right) # if node.left is not None: # stack.append(node.left) # return res ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:8:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"965. Univalued Binary Tree (easy) 简述：判断树中节点值是否单一 思路：遍历时，维护全局变量 联系： # class Solution(object): # def isUnivalTree(self, root): # \"\"\" # :type root: TreeNode # :rtype: bool # \"\"\" # if root.left is None and root.right is None: # return True # self.rootval, self.res = root.val, True # self.preOrder(root) # return self.res # def preOrder(self, root): # \"\"\" # :type root: TreeNode # :rtype: bool # \"\"\" # if root is None: # return # if root.val != self.rootval: # self.res = False # self.preOrder(root.left) # self.preOrder(root.right) Post-Order backtrack ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:9:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"404. Sum of Left Leaves (easy) 简述：求二叉树中，所有左叶节点和 思路：左转向下时标注“左”，右转向下时标注“右” 联系： # class Solution(object): # def sumOfLeftLeaves(self, root): # \"\"\" # :type root: TreeNode # :rtype: int # \"\"\" # self.res = 0 self.inorder(root, False) # return self.res # def inorder(self, root, isLeft): # if root is None: # return # self.inorder(root.left, True) # if root.left is None and root.right is None and isLeft: # self.res += root.val # self.inorder(root.right, False) Non-recursive ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:10:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"510. Inorder Successor in BST II (medium) 简述：给二叉树中某个节点，树中找in-order顺序中的下一个节点（此题节点额外含有：子-\u003e父） 思路：while 联系： # class Solution(object): # def inorderSuccessor(self, node): # \"\"\" # :type node: Node # :rtype: Node # \"\"\" # if node is None: # return None # if node.right: # curr = node.right # while curr.left: # curr = curr.left # return curr # else: # curr = node # while curr.parent and curr == curr.parent.right: # curr = curr.parent # return curr.parent ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:11:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"222. Count Complete Tree Nodes (medium) 简述：complete二叉树 （complete指从上到下，从左到右尽量排满），求树中节点个数 思路：最优复杂度O(logN*logN) 联系：树与二分法很漂亮的结合题 # class Solution(object): # def countNodes(self, root): # \"\"\" # :type root: TreeNode # :rtype: int # \"\"\" # if root is None: # return 0 # height = self.findHeight(root) # res_full = 2**height - 1 # 要点3-1: 二分法模板 # left, right = 1, 2**height # while left + 1 \u003c right: # mid = (left + right) // 2 # if self.pathHasNode(root, height, mid - 1): # left = mid # else: # right = mid # if self.pathHasNode(root, height, right - 1): # return res_full + right # else: # return res_full + left # def findHeight(self, root): # res, p = 0, root # while p.left: # res += 1 # p = p.left # return res # 要点3-2: path encoding def pathHasNode(self, root, height, encoding_int): # p = root # 要点3-3: 构造mask，将encoded path从高位到地位二进制扫描出来 # mask = 2**(height-1) # for _ in range(height): if encoding_int \u0026 mask == 0: # if p.left is None: # return False # p = p.left # else: # if p.right is None: # return False # p = p.right mask \u003e\u003e= 1 # return True ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:12:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"701. Insert into a Binary Search Tree (medium) 简述：将所给值插入BST（假设原BST不含所给值） 思路：用BST性质 联系： # class Solution(object): # def insertIntoBST(self, root, val): # \"\"\" # :type root: TreeNode # :type val: int # :rtype: TreeNode # \"\"\" # 要点1-1：边界情况 if root is None: return TreeNode(val) # p = root # while True: # if val \u003e p.val: # if p.right is None: # p.right = TreeNode(val) # return root # else: # p = p.right # else: # if p.left is None: # p.left = TreeNode(val) # return root # else: # p = p.left ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:13:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"94. Binary Tree Inorder Traversal (medium) 简述：不用递归，in-order遍历二叉树 思路：左子树为优先级 联系：出自510 # class Solution(object): # def inorderTraversal(self, root): # \"\"\" # :type root: TreeNode # :rtype: List[int] # \"\"\" if root is None: return [] dummy = TreeNode(0) dummy.right = root stack = [dummy] inorder = [] while stack: node = stack.pop() if node.right: # 想处理此节点，先把此节点的右子树加入优先级栈 node = node.right while node: stack.append(node) node = node.left if stack: inorder.append(stack[-1].val) return inorder ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:14:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":" Title -- ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:0:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"100. Same Tree (easy) 简述：判断两棵二叉树是否相同 思路：分治法 联系：模板题 # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None # class Solution(object): # def isSameTree(self, p, q): # \"\"\" # :type p: TreeNode # :type q: TreeNode # :rtype: bool # \"\"\" # if p is None and q is None: # return True # if p is None or q is None: # return False return p.val == q.val and \\ self.isSameTree(p.left, q.left) and \\ self.isSameTree(p.right, q.right) ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:1:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"572. Subtree of Another Tree (easy) 简述：判断t是否为s的子树（相同也算子树） 思路：构造isSame()辅助 联系：出自100 # class Solution(object): # def isSubtree(self, s, t): # \"\"\" # :type s: TreeNode # :type t: TreeNode # :rtype: bool # \"\"\" # if s is None: # return False return self.isSame(s, t) or self.isSubtree(s.left, t) or self.isSubtree(s.right, t) # def isSame(self, s, t): # if s is None and t is None: # return True # if s is None or t is None: # return False # return s.val == t.val and \\ # self.isSame(s.left, t.left) and \\ # self.isSame(s.right, t.right) ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:2:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"101. Symmetric Tree (easy) 简述：判断二叉树是否对称 思路：改造为判断两棵树是否对称 联系：出自100 # class Solution(object): # def isSymmetric(self, root): # \"\"\" # :type root: TreeNode # :rtype: bool # \"\"\" # if root is None: # return True # return self._isSymmetric(root.left, root.right) # 要点1-1: 下划线命名helper函数，添加参数 def _isSymmetric(self, r1, r2): # if r1 is None and r2 is None: # return True # if r1 is None or r2 is None: # return False # return r1.val == r2.val and \\ # self._isSymmetric(r1.left, r2.right) and \\ # self._isSymmetric(r1.right, r2.left) ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:3:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"270. Closest Binary Search Tree Value (easy) 简述：在BST里找最接近目标的值 思路：分治 联系：出自100 # class Solution(object): # def closestValue(self, root, target): # \"\"\" # :type root: TreeNode # :type target: float # :rtype: int # \"\"\" # if root.left is None and root.right is None: # return root.val # if target == root.val: # return root.val # if target \u003e root.val: # if root.right is None: # return root.val # tmp_res = self.closestValue(root.right, target) if abs(root.val - target) \u003c= abs(tmp_res - target): # return root.val # else: # return tmp_res # else: # if root.left is None: # return root.val # tmp_res = self.closestValue(root.left, target) if abs(root.val - target) \u003c= abs(tmp_res - target): # return root.val # else: # return tmp_res ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:4:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"104. Maximum Depth of Binary Tree (easy) 简述：求二叉树最大深度, 通常定义如下 （此题按节点数量算深度） I learned that depth and height are properties of a node: The depth of a node is the number of edges from the node to the tree’s root node. A root node will have a depth of 0. The height of a node is the number of edges on the longest path from the node to a leaf. A leaf node will have a height of 0. Properties of a tree: The height of a tree would be the height of its root node, or equivalently, the depth of its deepest node. The diameter (or width) of a tree is the number of nodes on the longest path between any two leaf nodes. The tree below has a diameter of 6 nodes. depth往根（上）数，height往最远的叶（下）数，height等于maxDepth 思路：分治法，也可以遍历法 联系：出自100 # class Solution(object): # def maxDepth(self, root): # \"\"\" # :type root: TreeNode # :rtype: int # \"\"\" # if root is None: # return 0 # return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1 ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:5:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"111. Minimum Depth of Binary Tree (easy) 简述：求二叉树最小深度 思路：分治法 联系：出自104 # class Solution(object): # def minDepth(self, root): # \"\"\" # :type root: TreeNode # :rtype: int # \"\"\" # if root is None: # return 0 if root.left is None and root.right is None: return 1 if root.left is None: return self.minDepth(root.right) + 1 if root.right is None: return self.minDepth(root.left) + 1 # return min(self.minDepth(root.left), self.minDepth(root.right)) + 1 ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:6:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"226. Invert Binary Tree (easy) 简述：左右反转二叉树 思路：分治 联系：出自100 # class Solution(object): # def invertTree(self, root): # \"\"\" # :type root: TreeNode # :rtype: TreeNode # \"\"\" # if root is None: # return None # if root.left is None and root.right is None: # return root root.left, root.right = self.invertTree(root.right), self.invertTree(root.left) # return root ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:7:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"669. Trim a Binary Search Tree (easy) 简述：裁剪BST，使得裁剪后元素位于区间[L, R](R\u003e=L)内 思路：根节点三种情况：\u003cL, \u003eR, LR之间 联系：出自100 # class Solution(object): # def trimBST(self, root, L, R): # \"\"\" # :type root: TreeNode # :type L: int # :type R: int # :rtype: TreeNode # \"\"\" # if root is None: # return None # if root.val \u003c L: # return self.trimBST(root.right, L, R) # if root.val \u003e R: # return self.trimBST(root.left, L, R) root.left, root.right = self.trimBST(root.left, L, R), self.trimBST(root.right, L, R) # return root ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:8:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"110. Balanced Binary Tree (easy) 简述：判断二叉树是否平衡，即每个节点左右子树高度差不超过1 思路：分治+全局变量 联系：出自104 # class Solution(object): # def isBalanced(self, root): # \"\"\" # :type root: TreeNode # :rtype: bool # \"\"\" # 要点2-1: 添加全局变量 self._isBalanced = True # height = self.findHeight(root) # return self._isBalanced # def findHeight(self, root): # 要点2-2: 添加短路判断 if root is None or not self._isBalanced: return 0 # left_height = self.findHeight(root.left) # right_height = self.findHeight(root.right) # if abs(left_height - right_height) \u003e 1: # self._isBalanced = False # return max(left_height, right_height) + 1 ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:9:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"543. Diameter of Binary Tree (easy) 简述：求二叉树的直径，即节点间的最长路径（可不经过根节点） 思路：分治+全局变量 联系：出自110 # class Solution(object): # def diameterOfBinaryTree(self, root): # \"\"\" # :type root: TreeNode # :rtype: int # \"\"\" # 要点1-1: 添加全局变量 self.res = 0 # self.findDepth(root) # return self.res # def findDepth(self, root): # if root is None: # return 0 # left_depth = self.findDepth(root.left) # right_depth = self.findDepth(root.right) self.res = max(self.res, left_depth + right_depth) # return max(left_depth, right_depth) + 1 ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:10:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"124. Binary Tree Maximum Path Sum (hard) 简述：求二叉树中路径最大和（任意节点到任意节点，不必经过根节点） 思路：分治+全局变量 联系：出自110 # class Solution(object): # def maxPathSum(self, root): # \"\"\" # :type root: TreeNode # :rtype: int # \"\"\" # 要点1-1: python最小整数 self.res = -sys.maxsize - 1 # self.maxSumFromRoot(root) # return self.res # def maxSumFromRoot(self, root): # if root is None: # return 0 # if root.left is None and root.right is None: # self.res = max(self.res, root.val) # return root.val # left_max = self.maxSumFromRoot(root.left) # right_max = self.maxSumFromRoot(root.right) self.res = max(self.res, root.val + \\ max(0, left_max, right_max, left_max + right_max)) # return max(root.val, root.val + left_max, root.val + right_max) ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:11:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"257. Binary Tree Paths (easy) 简述：打印二叉树所有根到叶路径 思路：分治 联系：出自100 # class Solution(object): # def binaryTreePaths(self, root): # \"\"\" # :type root: TreeNode # :rtype: List[str] # \"\"\" # if root is None: # return [] # if root.left is None and root.right is None: # return [str(root.val)] # left_paths = self.binaryTreePaths(root.left) # right_paths = self.binaryTreePaths(root.right) # res = [] # res += [str(root.val) + '-\u003e' + p for p in left_paths] # res += [str(root.val) + '-\u003e' + p for p in right_paths] # return res ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:12:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"654. Maximum Binary Tree (medium) 简述：给数组，按规则构造树，规则：数组最大值为根，最大值左边为左子树，最大值右边为右子树，左右子树继续符合规则 思路：递归定义，分治 联系：出自100 # class Solution(object): # def constructMaximumBinaryTree(self, nums): # \"\"\" # :type nums: List[int] # :rtype: TreeNode # \"\"\" # if not nums: # return None # root = TreeNode(max(nums)) # root.left = self.constructMaximumBinaryTree(nums[0:nums.index(max(nums))]) # root.right = self.constructMaximumBinaryTree(nums[nums.index(max(nums))+1:]) # return root ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:13:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"108. Convert Sorted Array to Binary Search Tree (easy) 简述：给已排序的数组，构造相应的平衡BST 思路：中点作为pivot 联系：出自654 # class Solution(object): # def sortedArrayToBST(self, nums): # \"\"\" # :type nums: List[int] # :rtype: TreeNode # \"\"\" # if not nums: # return None # mid = len(nums) // 2 # root = TreeNode(nums[mid]) # root.left = self.sortedArrayToBST(nums[0: mid]) # root.right = self.sortedArrayToBST(nums[mid + 1:]) # return root ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:14:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"606. Construct String from Binary Tree (easy) 简述：按preorder规则通过添加括号把二叉树转为字符串，以保证树与字符串的一一对应。 思路：如果左子树为空，可添加一对空括号 联系：出自654 # class Solution(object): # def tree2str(self, t): # \"\"\" # :type t: TreeNode # :rtype: str # \"\"\" # if t is None: # return \"\" # if t.left is None and t.right is None: # return str(t.val) if t.left is None: return str(t.val) + '()(' + self.tree2str(t.right) + ')' if t.right is None: return str(t.val) + '(' + self.tree2str(t.left) + ')' # return str(t.val) + '(' + self.tree2str(t.left) + ')(' + self.tree2str(t.right) + ')' ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:15:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"1120. Maximum Average Subtree (medium) 简述：求子树中最大平均值 思路：维护平均值，辅助函数返回树的总和与总节点个数 联系：出自110 # class Solution(object): # def maximumAverageSubtree(self, root): # \"\"\" # :type root: TreeNode # :rtype: float # \"\"\" # 要点1-1: 初始为最小浮点数 self.res = float('-inf') # res_cnt, res_sum = self.findSum(root) # return self.res # def findSum(self, root): # if root is None: # return 0, 0 # if root.left is None and root.right is None: # self.res = max(self.res, root.val) # return 1, root.val # left_cnt, left_sum = self.findSum(root.left) # right_cnt, right_sum = self.findSum(root.right) # res_cnt = left_cnt + right_cnt + 1 # res_sum = left_sum + right_sum + root.val # self.res = max(self.res, res_sum * 1.0 / res_cnt) # return res_cnt, res_sum ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:16:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"563. Binary Tree Tilt (easy) 简述：按定义求树的tilt，定义：节点tilt-左子树节点和与右子树节点和差值的绝对值，树的tilt-所有节点tilt的和 思路：辅助函数findSum(), 维护全局变量 联系：出自110 # class Solution(object): # def findTilt(self, root): # \"\"\" # :type root: TreeNode # :rtype: int # \"\"\" # self.res = 0 # total_sum = self.findSum(root) # return self.res # def findSum(self, root): # if root is None: # return 0 # if root.left is None and root.right is None: # return root.val # left_sum, right_sum = self.findSum(root.left), self.findSum(root.right) self.res += abs(left_sum - right_sum) return left_sum + right_sum + root.val ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:17:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"366. Find Leaves of Binary Tree (medium) 简述：二叉树剥洋葱，返回最外层（叶节点），然后次外层（倒数第二层节点），以此类推 思路：标注节点高度，构造节点-\u003e高度映射，再返回反向索引 联系：出自110 # class Solution(object): # def findLeaves(self, root): # \"\"\" # :type root: TreeNode # :rtype: List[List[int]] # \"\"\" # 要点2-1: 全局变量，映射 height_memo = dict() # self.label_height(root, height_memo) # # 要点2-2: 反向索引inverted index return self.convert_memo(height_memo) # def label_height(self, root, height_memo): # if root is None: # return 0 # if root.left is None and root.right is None: # height_memo[root] = 1 # return 1 # left_height = self.label_height(root.left, height_memo) # right_height = self.label_height(root.right, height_memo) # res_height = max(left_height, right_height) + 1 # height_memo[root] = res_height # return res_height # def convert_memo(self, height_memo): # res = dict() # for k, v in height_memo.items(): # if v not in res: # res[v] = list() # res[v].append(k.val) # ans = [] # for i in range(len(res.keys())): # ans.append(res[i + 1]) # return ans ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:18:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"617. Merge Two Binary Trees (easy) 简述：合并两棵二叉树，合并后节点为两棵对应节点之和 思路：分治 联系：出自669 # class Solution(object): # def mergeTrees(self, t1, t2): # \"\"\" # :type t1: TreeNode # :type t2: TreeNode # :rtype: TreeNode # \"\"\" # if t1 is None: # return t2 # if t2 is None: # return t1 # root = TreeNode(t1.val + t2.val) # root.left = self.mergeTrees(t1.left, t2.left) # root.right = self.mergeTrees(t1.right, t2.right) # return root ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:19:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"1490. Clone N-ary Tree (medium) 简述：深拷贝N元树 思路：递归定义，分治 联系：出自100 # class Solution(object): # def cloneTree(self, root): # \"\"\" # :type root: Node # :rtype: Node # \"\"\" # if root is None: # return None # root_copy = Node(val=root.val) # for el in root.children: # root_copy.children.append(self.cloneTree(el)) # return root_copy ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:20:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"814. Binary Tree Pruning (medium) 简述：二叉树树中节点只能为0或1，裁剪二叉树，使得最后没有全为0的子树 思路：分治 联系：出自100 # class Solution(object): # def pruneTree(self, root): # \"\"\" # :type root: TreeNode # :rtype: TreeNode # \"\"\" # if root is None: # return None # if root.left is None and root.right is None: # if root.val == 0: # return None # else: # return root # left_pruned = self.pruneTree(root.left) # right_pruned = self.pruneTree(root.right) if left_pruned is None and right_pruned is None and root.val == 0: return None # root.left, root.right = left_pruned, right_pruned # return root ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:21:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"236. Lowest Common Ancestor of a Binary Tree (medium) 简述：求两节点在二叉树里的LCA（假设两节点都在树中） 思路：分治 联系：出自100 # class Solution(object): # 要点1-1: 三种情况：1）两个节点都在树中返回lca， 2）一个在树中返回该节点，3）两个都不在返回None def lowestCommonAncestor(self, root, p, q): # \"\"\" # :type root: TreeNode # :type p: TreeNode # :type q: TreeNode # :rtype: TreeNode # \"\"\" # if root is None: # return None # if root == p or root == q: # return root # left_lca = self.lowestCommonAncestor(root.left, p, q) # right_lca = self.lowestCommonAncestor(root.right, p, q) # if left_lca and right_lca: # return root # if left_lca: # return left_lca # if right_lca: # return right_lca # return None ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:22:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"235. Lowest Common Ancestor of a Binary Search Tree (easy) 简述：求两节点在BST里的LCA（假设两节点都在树中） 思路：分治，根据情况走一边子树 联系：出自236 # class Solution(object): # def lowestCommonAncestor(self, root, p, q): # \"\"\" # :type root: TreeNode # :type p: TreeNode # :type q: TreeNode # :rtype: TreeNode # \"\"\" # if root is None: # return None # if root == p or root == q: # return root # if p.val \u003c root.val \u003c q.val or q.val \u003c root.val \u003c p.val: # return root # if root.val \u003c p.val: # return self.lowestCommonAncestor(root.right, p, q) # else: # return self.lowestCommonAncestor(root.left, p, q) ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:23:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"156. Binary Tree Upside Down (medium) 简述：上下翻转二叉树，所给二叉树的性质：右节点是空或是有兄弟节点的叶节点 思路：画图按例子翻转 联系：出自226 # class Solution(object): # def upsideDownBinaryTree(self, root): # \"\"\" # :type root: TreeNode # :rtype: TreeNode # \"\"\" # if root is None: # return None # if root.left is None and root.right is None: # return root # res = self.upsideDownBinaryTree(root.left) root.left.left, root.left.right = root.right, root # root.left, root.right = None, None # return res ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:24:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"114. Flatten Binary Tree to Linked List (medium) 简述：in-place转化二叉树成链表结构 思路：分治 联系：出自226 # class Solution(object): # def flatten(self, root): # \"\"\" # :type root: TreeNode # :rtype: None Do not return anything, modify root in-place instead. # \"\"\" # tail = self.flatten_tail(root) # def flatten_tail(self, root): # if root is None: # return None # if root.left is None and root.right is None: # return root # if root.left is None: # return self.flatten_tail(root.right) # if root.right is None: # left_tail = self.flatten_tail(root.left) # root.left, root.right = None, root.left # return left_tail # left_tail = self.flatten_tail(root.left) # right_tail = self.flatten_tail(root.right) # root.left, root.right, left_tail.right = None, root.left, root.right # return right_tail VERSION II (from girikuncoro’s post) # class Solution(object): # def __init__(self): self.prev = None # def flatten(self, root): # \"\"\" # :type root: TreeNode # :rtype: None Do not return anything, modify root in-place instead. # \"\"\" # if root is None: # return # self.flatten(root.right) # self.flatten(root.left) # # 要点1-1: 先右子树再左子树，这样会把右子树通过prev移花接木到左子树尾部 root.right = self.prev # root.left = None # self.prev = root ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:25:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"298. Binary Tree Longest Consecutive Sequence (medium) 简述：在二叉树中找连续值路径（路径这里指从父节点向下） 思路：分治，维护全局变量 联系：出自110 # class Solution(object): # def longestConsecutive(self, root): # \"\"\" # :type root: TreeNode # :rtype: int # \"\"\" # self.res = 0 # self.longest_from_root(root) # return self.res # def longest_from_root(self, root): # if root is None: # return 0 # if root.left is None and root.right is None: # self.res = max(self.res, 1) # return 1 # 要点1-1: 无论当前节点与左右子节点是否差1，都要执行搜索 left_longest = self.longest_from_root(root.left) right_longest = self.longest_from_root(root.right) # curr = 1 # if root.left and root.val + 1 == root.left.val: # curr = max(curr, left_longest + 1) # if root.right and root.val + 1 == root.right.val: # curr = max(curr, right_longest + 1) # self.res = max(self.res, curr) # return curr ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:26:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"285. Inorder Successor in BST (medium) 简述：BST中找所给节点的下一个按序节点，即比所给节点大的最小节点 思路：分治 联系：出自100 # class Solution(object): # def inorderSuccessor(self, root, p): # \"\"\" # :type root: TreeNode # :type p: TreeNode # :rtype: TreeNode # \"\"\" # if root is None: # return None # if p.val \u003e= root.val: # return self.inorderSuccessor(root.right, p) # left_res = self.inorderSuccessor(root.left, p) # if left_res is None: # return root # return left_res ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:27:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"671. Second Minimum Node In a Binary Tree (easy) 简述：二叉树满足：每个节点有0或2个子节点，当2个子节点时，root.val = min(root.left.val, root.right.val)，求树中第二小的节点值 思路：分治，注意比较时的初始化 联系：出自100 # class Solution(object): # def findSecondMinimumValue(self, root): # \"\"\" # :type root: TreeNode # :rtype: int # \"\"\" # if root is None: # return -1 # if root.left is None and root.right is None: # return -1 # left_res = self.findSecondMinimumValue(root.left) # right_res = self.findSecondMinimumValue(root.right) # 要点1-1: 初始化比较值，题目要求无第二最小值，返回-1 if left_res == -1: left_res = sys.maxsize if right_res == -1: right_res = sys.maxsize # if root.val == root.left.val == root.right.val: res = min(left_res, right_res) return res if res != sys.maxsize else -1 # else: # if root.val == root.left.val: # return min(left_res, root.right.val) # else: # return min(right_res, root.left.val) ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:28:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"模板 # def binarySearch(nums, target): # if len(nums) == 0: # return -1 # start, end = 0, len(nums) - 1 while start + 1 \u003c end: # 要点3-1 mid = (start + end) // 2 # 要点3-2: python动态数据类型 # if nums[start] \u003c target: start = mid # 要点3-3: mid不+-1 # else: # end = mid # if nums[start] == target: # return start # if nums[end] == target: # return end # return -1 找位置 ","date":"2020-07-07","objectID":"/leetcode-binary-search/:0:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"34. Find First and Last Position of Element in Sorted Array (medium) 简述：已排序数组，求目标值第一次和最后一次出现的位置 思路：拆解为两个子函数，findFirst()和findLast() 联系：基础模板题 # class Solution(object): # def searchRange(self, nums, target): # \"\"\" # :type nums: List[int] # :type target: int # :rtype: List[int] # \"\"\" # first, last = self.findFirst(nums, target), self.findLast(nums, target) # return [first, last] # def findFirst(self, nums, target): # if len(nums) == 0: # return -1 # left, right = 0, len(nums) - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 if nums[mid] \u003c target: # 要点2-1 # left = mid # else: # right = mid # if nums[left] == target: # return left # if nums[right] == target: # return right # return -1 # def findLast(self, nums, target): # if len(nums) == 0: # return -1 # left, right = 0, len(nums) - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 if nums[mid] \u003e target: # 要点2-2 # right = mid # else: # left = mid # if nums[right] == target: # return right # if nums[left] == target: # return left # return -1 ","date":"2020-07-07","objectID":"/leetcode-binary-search/:1:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"35. Search Insert Position (easy) 简述：已排序数组，求插入位置保证插入后依然排序 思路：类似findFirst() 联系：出自34 # class Solution(object): # def searchInsert(self, nums, target): # \"\"\" # :type nums: List[int] # :type target: int # :rtype: int # \"\"\" # # 要点1-1: 注意输入边界情况 if target \u003c nums[0]: return 0 if target \u003e nums[-1]: return len(nums) # left, right = 0, len(nums) - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 # if nums[mid] \u003c target: # left = mid # else: # right = mid # if nums[left] \u003e= target: # return left # return right ","date":"2020-07-07","objectID":"/leetcode-binary-search/:2:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"744. Find Smallest Letter Greater Than Target (easy) 简述：已排序的数组，求大于目标的最前位置 思路：类似findFirst() 联系：出自34 # class Solution(object): # def nextGreatestLetter(self, letters, target): # \"\"\" # :type letters: List[str] # :type target: str # :rtype: str # \"\"\" # left, right = 0, len(letters) - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 # if letters[mid] \u003c= target: # left = mid # else: # right = mid # if letters[left] \u003e target: # return letters[left] # if letters[right] \u003e target: # return letters[right] # return letters[0] ","date":"2020-07-07","objectID":"/leetcode-binary-search/:3:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"702. Search in a Sorted Array of Unknown Size (medium) 简述：已排序数组，但不知size，求目标值位置 思路：扩右边直到包含目标值，再二分 联系：出自34 # class Solution(object): # def search(self, reader, target): # \"\"\" # :type reader: ArrayReader # :type target: int # :rtype: int # \"\"\" # # 要点1-1: 倍增右边界 right = 1 while reader.get(right) \u003c target: right *= 2 left = right // 2 # while left + 1 \u003c right: # mid = (left + right) // 2 # if reader.get(mid) == target: # return mid # if reader.get(mid) \u003c target: # left = mid # else: # right = mid # if reader.get(left) == target: # return left # if reader.get(right) == target: # return right # return -1 ","date":"2020-07-07","objectID":"/leetcode-binary-search/:4:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"74. Search a 2D Matrix (medium) 简述：已排序的2D数组(每行排序，一行最后元素小于下行最前元素)，求目标值是否存在 思路：只是1D数组layout变化，模板不变 联系：出自34 # class Solution(object): # def searchMatrix(self, matrix, target): # \"\"\" # :type matrix: List[List[int]] # :type target: int # :rtype: bool # \"\"\" # if not matrix or not matrix[0]: # return False # M, N = len(matrix), len(matrix[0]) # left, right = 0, M * N - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 # row, col = mid // N, mid % N # if matrix[row][col] == target: # return True # if matrix[row][col] \u003c target: # left = mid # else: # right = mid # return matrix[left//N][left%N] == target or matrix[right//N][right%N] == target ","date":"2020-07-07","objectID":"/leetcode-binary-search/:5:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"240. Search a 2D Matrix II (medium) 简述：已排序的2D数组(每行排序，每列排序)，求目标值是否存在 思路：斜对角线一个个坐标走，不是二分题 联系：出自74，不是二分 # class Solution(object): # def searchMatrix(self, matrix, target): # \"\"\" # :type matrix: List[List[int]] # :type target: int # :rtype: bool # \"\"\" # if not matrix or not matrix[0]: # return False # M, N = len(matrix), len(matrix[0]) # x, y = M - 1, 0 # while True: # if not (0 \u003c= x \u003c M and 0 \u003c= y \u003c N): # return False # if matrix[x][y] == target: # return True # # 要点1-1: 不是二分，走坐标 if matrix[x][y] \u003e target: x -= 1 else: y += 1 # return False ","date":"2020-07-07","objectID":"/leetcode-binary-search/:6:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"658. Find K Closest Elements (medium) 简述：已排序数组，求k个最邻近目标的元素们 思路：先找到最邻近目标的元素，再往两边扩展 联系：出自34 # class Solution(object): # def findClosestElements(self, arr, k, x): # \"\"\" # :type arr: List[int] # :type k: int # :type x: int # :rtype: List[int] # \"\"\" # left, right = 0, len(arr) - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 # if arr[mid] \u003c x: # left = mid # else: # right = mid # # 要点1-1: 最后的范围左右开区间(left, right) return self.expand(arr, left, right, k, x) # def expand(self, arr, left, right, k, x): # cnt = 0 # while cnt \u003c k: # if right \u003e= len(arr) or abs(arr[left] - x) \u003c= abs(arr[right] - x): # left -= 1 # else: # right += 1 # cnt += 1 return arr[left + 1 : left + 1 + k] 非单调 ","date":"2020-07-07","objectID":"/leetcode-binary-search/:7:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"153. Find Minimum in Rotated Sorted Array (medium) 简述：rotate过的排序数组(无重复元素)，求最小值 思路：pivot出现在前半段，经过顺序为 中\u003c右\u003c左，pivot出现在后半段，经过顺序为 右\u003c左\u003c中 联系：左右关系无法判断, 应判断中右关系 # class Solution(object): # def findMin(self, nums): # \"\"\" # :type nums: List[int] # :rtype: int # \"\"\" # left, right = 0, len(nums) - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 if nums[mid] \u003e nums[right]: # left = mid # else: # right = mid # return min(nums[left], nums[right]) ","date":"2020-07-07","objectID":"/leetcode-binary-search/:8:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"33. Search in Rotated Sorted Array (medium) 简述：rotate过的排序数组(无重复元素)，求目标值位置 思路：先找pivot，再传统二分 联系：出自153 # class Solution(object): # def search(self, nums, target): # \"\"\" # :type nums: List[int] # :type target: int # :rtype: int # \"\"\" # if len(nums) == 0: # return -1 # pivot = self.findPivot(nums) # L = len(nums) # left, right = 0, L - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 # # 要点1-1: 访问排序数组时转化坐标 if nums[(mid + pivot) % L] \u003e target: # right = mid # else: # left = mid # if nums[(left + pivot) % L] == target: # return (left + pivot) % L # if nums[(right + pivot) % L] == target: # return (right + pivot) % L # return -1 def findPivot(self, nums): # left, right = 0, len(nums) - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 # if nums[mid] \u003e nums[right]: # left = mid # else: # right = mid # if nums[left] \u003c nums[right]: # return left # else: # return right ","date":"2020-07-07","objectID":"/leetcode-binary-search/:9:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"154. Find Minimum in Rotated Sorted Array II (hard) 简述：rotate过的排序数组(有重复元素)，求最小元素 思路：11111011 (最坏情况linear查找) 联系：出自33 # class Solution(object): # def findMin(self, nums): # \"\"\" # :type nums: List[int] # :rtype: int # \"\"\" # left, right = 0, len(nums) - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 # if nums[right] \u003e nums[mid]: # right = mid # elif nums[right] \u003c nums[mid]: # left = mid else: # 要点1-1: 如何把线性查找与二分查找合并 right = right - 1 # return min(nums[left], nums[right]) ","date":"2020-07-07","objectID":"/leetcode-binary-search/:10:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"852. Peak Index in a Mountain Array (easy) 简述：山形数组，求山峰位置 思路：思考山峰若在前半段发生什么(A[mid-1] \u003e A[mid] \u003e A[mid+1])，若在后半段发生什么(A[mid-1] \u003c A[mid] \u003c A[mid+1]) 联系：思考方式出自153，都是在想目标出现前后半段的性质差别，二分保证充要 # class Solution(object): # def peakIndexInMountainArray(self, A): # \"\"\" # :type A: List[int] # :rtype: int # \"\"\" # left, right = 0, len(A) - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 # if A[mid] \u003e A[mid+1] and A[mid] \u003e A[mid-1]: # return mid # if A[mid] \u003e A[mid+1] and A[mid] \u003c A[mid-1]: # right = mid # else: # left = mid # if A[left] \u003e A[right]: # return left # else: # return right ","date":"2020-07-07","objectID":"/leetcode-binary-search/:11:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"162. Find Peak Element (medium) 简述：重峦叠嶂数组(相邻不等)，求任意一个山峰位置 思路：类似852，但并不充要 # class Solution(object): # def findPeakElement(self, nums): # \"\"\" # :type nums: List[int] # :rtype: int # \"\"\" # left, right = 0, len(nums) - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 # if nums[mid] \u003e nums[mid - 1] and nums[mid] \u003e nums[mid + 1]: # return mid # if nums[mid] \u003e nums[mid - 1] and nums[mid] \u003c nums[mid + 1]: # left = mid # else: # right = mid # if nums[left] \u003e nums[right]: # return left # else: # return right 找状态 ","date":"2020-07-07","objectID":"/leetcode-binary-search/:12:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"278. First Bad Version (easy) 简述：OOOOXXX, 求第一个失败版本idx 思路：目标出现前后半段导致mid状态差别 联系： # # The isBadVersion API is already defined for you. # # @param version, an integer # # @return a bool # # def isBadVersion(version): # class Solution(object): # def firstBadVersion(self, n): # \"\"\" # :type n: int # :rtype: int # \"\"\" # left, right = 1, n # while left + 1 \u003c right: # mid = (left + right) // 2 # if isBadVersion(mid): # right = mid # else: # left = mid # if isBadVersion(left): # return left # return right ","date":"2020-07-07","objectID":"/leetcode-binary-search/:13:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"374. Guess Number Higher or Lower (easy) 简述：1-n猜数字，api回答高低，求目标数字 思路：从目标开始后面都会猜高 联系：出自278 # # The guess API is already defined for you. # # @param num, your guess # # @return -1 if my number is lower, 1 if my number is higher, otherwise return 0 # # def guess(num): # class Solution(object): # def guessNumber(self, n): # \"\"\" # :type n: int # :rtype: int # \"\"\" # left, right = 1, n # while left + 1 \u003c right: # mid = (left + right) // 2 # api_res = guess(mid) # if api_res == 0: # return mid # if api_res == 1: # left = mid # else: # right = mid # return left if guess(left) == 0 else right ","date":"2020-07-07","objectID":"/leetcode-binary-search/:14:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"69. Sqrt(x) (easy) 简述：求根号x，取整 思路：从正确答案后，平方大于x 联系：出自278 # class Solution(object): # def mySqrt(self, x): # \"\"\" # :type x: int # :rtype: int # \"\"\" # left, right = 1, x # while left + 1 \u003c right: # mid = (left + right) // 2 # if mid * mid == x: # return mid # if mid * mid \u003e x: # right = mid # else: # left = mid # return right if right * right \u003c= x else left ","date":"2020-07-07","objectID":"/leetcode-binary-search/:15:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"302. Smallest Rectangle Enclosing Black Pixels (hard) 简述：二值化图片，黑色像素相连，给一个黑色像素坐标，求包围黑色区域的最小矩形面积 思路：从黑色坐标向上下左右找边界，一旦超过边界将再无黑色行列 联系：出自278 # class Solution(object): # def minArea(self, image, x, y): # \"\"\" # :type image: List[List[str]] # :type x: int # :type y: int # :rtype: int # \"\"\" # m, n = len(image), len(image[0]) # def row_has_black(row): # for j in range(n): # if image[row][j] == '1': # return True # return False # def col_has_black(col): # for i in range(m): # if image[i][col] == '1': # return True # return False def find_upper(): # left, right = 0, x # while left + 1 \u003c right: # mid = (left + right) // 2 # if row_has_black(mid): # right = mid # else: # left = mid # if row_has_black(left): # return left # return right def find_lower(): # left, right = x, m - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 # if row_has_black(mid): # left = mid # else: # right = mid # if row_has_black(right): # return right # return left def find_left(): # left, right = 0, y # while left + 1 \u003c right: # mid = (left + right) // 2 # if col_has_black(mid): # right = mid # else: # left = mid # if col_has_black(left): # return left # return right def find_right(): # left, right = y, n - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 # if col_has_black(mid): # left = mid # else: # right = mid # if col_has_black(right): # return right # return left # upper, lower, left, right = find_upper(), find_lower(), find_left(), find_right() return (lower - upper + 1) * (right - left + 1) 二分答案 ","date":"2020-07-07","objectID":"/leetcode-binary-search/:16:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"274. H-Index (medium) 简述：引用数组，求hIndex–h篇每篇至少h引用，其余每篇不超过h引用 思路：二分答案，答案经过一次状态改变 联系： # class Solution(object): # def hIndex(self, citations): # \"\"\" # :type citations: List[int] # :rtype: int # \"\"\" # if not citations: # return 0 # left, right = 0, len(citations) # while left + 1 \u003c right: # h = (left + right) // 2 cnt = sum([x \u003e= h for x in citations]) # if cnt == h: # return h # if cnt \u003e h: # left = h # else: # right = h # cnt = sum([x \u003e= right for x in citations]) # if cnt \u003e= right: # return right # return left ","date":"2020-07-07","objectID":"/leetcode-binary-search/:17:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"275. H-Index II (hard) 简述：引用数组(已排序)，求hIndex–h篇每篇至少h引用，其余每篇不超过h引用 思路：不是二分答案，注意结尾情况 联系：出自274，但不属于二分答案 # class Solution(object): # def hIndex(self, citations): # \"\"\" # :type citations: List[int] # :rtype: int # \"\"\" # if not citations: # return 0 # N = len(citations) # left, right = 0, N - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 # if N - mid \u003e= citations[mid]: # left = mid # else: # right = mid # 要点1-1: 结尾情况很难想全 if N - right \u003e= citations[right]: return citations[right] if N - right \u003e= citations[left]: return N - right if N - left \u003e= citations[left]: return citations[left] return N - left ","date":"2020-07-07","objectID":"/leetcode-binary-search/:18:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"Coursera specializations offered by UM Course I Time Value of Money ","date":"2020-07-06","objectID":"/coursera-umich-fffsdm/:0:0","tags":null,"title":"Foundational Finance for Strategic Decision Making","uri":"/coursera-umich-fffsdm/"},{"categories":null,"content":"Simple Future Value (FV) PV = Present Value (unit: $) FV = Present Value (unit: $) n = # of Periods (#) r = Interest Rate (%, not $) \u003e 0 (assumption) Insight: A dollar today is worth more than a dollar tomorrow. You cannot compare money across time. Example: Power of Compounding! Peter Minuit bought the Manhattan Island from Native Americans for $24 in 1626. Suppose that Native Americans could have earned 6% on their investments all these years. How much would they have today (year 2020)? $224,244,683,837.58 Some Important Formulae Future Value of a Single Cash Flow Invested for n Periods $$F = P(1+r)^n$$ Present Value of a Single Cash Flow Received n Periods from Now $$P = F\\frac{1}{(1+r)^n}$$ Future Value of a Stream of Cash Flows as of n Periods from Now $$F = C_1(1+r)^{n-1} + C_2(1+r)^{n-2} + \\cdots + C_{n-1}(1+r) + C_n$$ Present Value of a Stream of Cash Flows $$P = \\frac{C_1}{1+r} + \\frac{C_2}{(1+r)^2} + \\cdots + \\frac{C_n}{(1+r)^n}$$ ","date":"2020-07-06","objectID":"/coursera-umich-fffsdm/:1:0","tags":null,"title":"Foundational Finance for Strategic Decision Making","uri":"/coursera-umich-fffsdm/"},{"categories":null,"content":"Hugo: 一个静态网页生成器，将markdown格式的博文编译为HTML，CSS，JavaScript Github Pages: 静态网页托管服务，将hugo转化后的博客公开给读者访问 reference: Mogeko博客《使用 Hugo + GitHub Pages 搭建个人博客》 ","date":"2020-07-03","objectID":"/hugo-blog-site/:0:0","tags":null,"title":"使用 Hugo + Github Pages 搭建个人博客","uri":"/hugo-blog-site/"},{"categories":null,"content":"Step 1 - 创建Github Pages对应的repo repo name: [username].github.io reference: Github Pages official page ","date":"2020-07-03","objectID":"/hugo-blog-site/:1:0","tags":null,"title":"使用 Hugo + Github Pages 搭建个人博客","uri":"/hugo-blog-site/"},{"categories":null,"content":"Step 2 - 安装Hugo (Mac系统) brew install hugo reference: Hugo official quickstart ","date":"2020-07-03","objectID":"/hugo-blog-site/:2:0","tags":null,"title":"使用 Hugo + Github Pages 搭建个人博客","uri":"/hugo-blog-site/"},{"categories":null,"content":"Step 3 - 使用Hugo创建本地博客文件夹 hugo new site myBlog cd myBlog 创建myBlog文件夹来存放博客站点。其中： content存放markdown博文 themes存放皮肤主题 config.toml配置站点 ","date":"2020-07-03","objectID":"/hugo-blog-site/:3:0","tags":null,"title":"使用 Hugo + Github Pages 搭建个人博客","uri":"/hugo-blog-site/"},{"categories":null,"content":"Step 4 - 安装皮肤主题 此博客使用mogege主题，原repo 安装主题至themes下 git clone https://github.com/Mogeko/mogege.git themes/mogege ","date":"2020-07-03","objectID":"/hugo-blog-site/:4:0","tags":null,"title":"使用 Hugo + Github Pages 搭建个人博客","uri":"/hugo-blog-site/"},{"categories":null,"content":"Step 5 - 创建页面 hugo new about.md hugo new posts/my-first-post.md 在content下自动生成页面，meta data包括： title: 页面标题 date: 创建时间 draft: 是否为草稿。建立server时，草稿需要加上--buildDrafts参数才能在public正确显示 description: 描述 (optional) tags:: 标签，用于文章分类 (optional) ","date":"2020-07-03","objectID":"/hugo-blog-site/:5:0","tags":null,"title":"使用 Hugo + Github Pages 搭建个人博客","uri":"/hugo-blog-site/"},{"categories":null,"content":"Step 6 - 配置网站 修改配置文件config.toml baseURL = \"https://xuwenzhe.github.io\" # \u003chead\u003e 里面的 baseurl 信息，填你的博客地址 title = \"Wenzhe's Blog\" # 浏览器的标题 languageCode = \"zh-cn\" # 语言 hasCJKLanguage = true # 开启可以让「字数统计」统计汉字 theme = \"mogege\" # 主题 (需要自己下载) paginate = 11 # 每页的文章数 enableEmoji = true # 支持 Emoji enableRobotsTXT = true # 支持 robots.txt googleAnalytics = \"\" # Google 统计 id preserveTaxonomyNames = true [blackfriday] hrefTargetBlank = true nofollowLinks = true noreferrerLinks = true [Permalinks] posts = \"/:year/:filename/\" [menu] [[menu.main]] name = \"Blog\" url = \"/posts/\" weight = 1 [[menu.main]] name = \"Categories\" url = \"/categories/\" weight = 2 [[menu.main]] name = \"Tags\" url = \"/tags/\" weight = 3 [[menu.main]] name = \"About\" url = \"/about/\" weight = 4 [params] since = 2020 author = \"Wenzhe\" # Author's name avatar = \"/images/me/avatar.png\" # Author's avatar subtitle = \"Just for Fun\" # Subtitle cdn_url = \"\" # Base CDN URL home_mode = \"\" # post or other enableGitalk = true # gitalk 评论系统 google_verification = \"\" description = \"\" # (Meta) 描述 keywords = \"\" # site keywords beian = \"\" baiduAnalytics = \"\" license= '本文采用\u003ca rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003e知识共享署名-非商业性使用 4.0 国际许可协议\u003c/a\u003e进行许可' [params.social] GitHub = \"https://github.com/xuwenzhe\" Twitter = \"xxoo\" Email = \"xxoo\" Instagram = \"xxoo\" Wechat = \"/images/me/wechat.png\" # Wechat QRcode image Facebook = \"xxoo\" Telegram = \"xxoo\" Dribbble = \"xxoo\" Medium = \"xxoo\" [params.gitalk] # Github: https://github.com/gitalk/gitalk clientID = \"\" # Your client ID clientSecret = \"\" # Your client secret repo = \"\" # The repo to store comments owner = \"\" # Your GitHub ID admin= \"\" # Required. Github repository owner and collaborators. (Users who having write access to this repository) id= \"location.pathname\" # The unique id of the page. labels= \"gitalk\" # Github issue labels. If you used to use Gitment, you can change it perPage= 15 # Pagination size, with maximum 100. pagerDirection= \"last\" # Comment sorting direction, available values are 'last' and 'first'. createIssueManually= false # If it is 'false', it is auto to make a Github issue when the administrators login. distractionFreeMode= false # Enable hot key (cmd|ctrl + enter) submit comment. ","date":"2020-07-03","objectID":"/hugo-blog-site/:6:0","tags":null,"title":"使用 Hugo + Github Pages 搭建个人博客","uri":"/hugo-blog-site/"},{"categories":null,"content":"Step 7 - 本地预览 hugo server --buildDrafts -w --buildDrafts: 生成draft博文 -w: 监控修改，自动更新修改过的站点 此时，在http://localhost:1313已经可以访问到博客啦 ","date":"2020-07-03","objectID":"/hugo-blog-site/:7:0","tags":null,"title":"使用 Hugo + Github Pages 搭建个人博客","uri":"/hugo-blog-site/"},{"categories":null,"content":"Step 8 - 编译发布 在myBlog文件夹中编译 hugo 此时，编译后的静态文件会存放在public文件夹 cd public # 进入public文件夹 git init # 建立本地git仓库 git remote add origin https://github.com/[username]/[username].github.io.git # 关联 git add . # add git commit -m \"[commit message]\" # commit git push -u origin master # push 之后发布新博文可以在public直接执行后三条命令add,commit,push即可。 记得draft改为false ","date":"2020-07-03","objectID":"/hugo-blog-site/:8:0","tags":null,"title":"使用 Hugo + Github Pages 搭建个人博客","uri":"/hugo-blog-site/"},{"categories":null,"content":"this is wenzhe’s about ","date":"2020-07-02","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"}]