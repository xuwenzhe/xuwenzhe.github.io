[{"categories":null,"content":"1. 基本概念理解 ","date":"2021-04-16","objectID":"/java-shk-7/:1:0","tags":["Java"],"title":"Java零基础教程（七.多线程）","uri":"/java-shk-7/"},{"categories":null,"content":"1.1 程序 vs 进程 vs 线程 程序（program）是为完成特定任务，用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。 进程（process）是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程：有它自身的产生，存在和消亡的过程。 - 生命周期 如：运行中的QQ，运行中的MP3播放器 程序是静态的，进程是动态的 进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域。 再比如一个运行中的杀毒软件（进程），其中清理文件，查杀木马的运行分别对应一个线程。 线程（thread），进程可进一步细化为线程，是一个程序内部的一条执行路径。 若一个进程同一时间并行执行多个线程，就是支持多线程的 线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)，线程切换的开销小。 一个进程中的多个线程共享相同的内存单元/内存地址空间，他们从同一堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便，高效。但多个线程操作共享的系统资源可能就会带来安全的隐患。 ","date":"2021-04-16","objectID":"/java-shk-7/:1:1","tags":["Java"],"title":"Java零基础教程（七.多线程）","uri":"/java-shk-7/"},{"categories":null,"content":"1.2 单核CPU vs. 多核CPU 单核CPU，其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。例如：虽然有多车道，但是收费站只有一个工作人员在收费，只有收了费才能通过，那么CPU就好比收费人员。如果有某个人不想交钱，那么收费人员可以把他“挂起”（晾着他，等他想通了，准备好了钱，再去收费）。但是因为CPU时间单元特别短，因此感觉不出来。 如果是多核的话，才能更好的发挥多线程的效率。（现在的服务器都是多核的） 一个Java应用程序java.exe，其实至少有三个线程：main()主线程，gc()垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程。 ","date":"2021-04-16","objectID":"/java-shk-7/:1:2","tags":["Java"],"title":"Java零基础教程（七.多线程）","uri":"/java-shk-7/"},{"categories":null,"content":"1.3 并行与并发 并行：多个CPU同时执行多个任务。比如：多个人同时做不同的事。 并发：一个CPU（采用时间片）同时执行多个任务。比如：秒杀，多个人做同一件事。（Quicksilver changes F1 tires?） ","date":"2021-04-16","objectID":"/java-shk-7/:1:3","tags":["Java"],"title":"Java零基础教程（七.多线程）","uri":"/java-shk-7/"},{"categories":null,"content":"1.4 多线程的优点 背景：以单核CPU为例，只使用单核线程先后完成多个任务（调用多个方法），肯定比用多个线程来完成用的时间更短，为何仍需多线程呢？ 多线程程序的优点： 提高应用程序的响应。对图形化界面更有意义，可增强用户体验。 提高计算机系统CPU的利用率 改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改。 何时需要多线程 程序需要同时执行两个或多个任务 程序需要实现一些需要等待的任务时，如用户输入，文件读写操作，网络操作，搜索等。 需要一些后台运行的程序时。 ","date":"2021-04-16","objectID":"/java-shk-7/:1:4","tags":["Java"],"title":"Java零基础教程（七.多线程）","uri":"/java-shk-7/"},{"categories":null,"content":"2. 线程的创建和使用 ","date":"2021-04-16","objectID":"/java-shk-7/:2:0","tags":["Java"],"title":"Java零基础教程（七.多线程）","uri":"/java-shk-7/"},{"categories":null,"content":"2.1 多线程的创建方式一：继承Thread类 创建一个继承于Thread类的子类 重写Thread类的run() -\u003e 将此线程执行的操作声明在run()中 创建Thread类的子类的对象 通过此对象调用start() package com.atguigu.java; /* 例子：遍历100以内的所有偶数 */ // 1. 创建一个继承于Thread类的子类 class MyThread extends Thread { // 2. 重写Thread类的run() @Override public void run() { for (int i = 0; i \u003c 10; i++) { if (i % 2 == 0) { System.out.println(Thread.currentThread().getName() + \":\" + i); } } } } public class ThreadTest { public static void main(String[] args) { // 3. 创建Thread类的子类的对象 MyThread t1 = new MyThread(); // 4. 通过此对象调用start(): 1）启动当前线程 2）调用当前线程的run() t1.start(); // 问题一：我们不能通过直接调用run()的方式启动线程。 // t1.run(); // 问题二：再启动一个线程，遍历。不可以还让已经start()的线程去执行。会报IllegalThreadStateException // t1.start(); // 我们需要重新创建一个线程的对象 MyThread t2 = new MyThread(); t2.start(); // 如下操作仍然是在main线程中执行的。 System.out.println(Thread.currentThread().getName()); } } 匿名子类的方式 package com.atguigu.exer; public class ThreadDemo { public static void main(String[] args) { // 创建Thread类的匿名子类的方式 new Thread(){ @Override public void run() { for (int i = 0; i \u003c 10; i++) { if (i % 2 == 0) { System.out.println(Thread.currentThread().getName() + \":\" + i); } } } }.start(); new Thread(){ @Override public void run() { for (int i = 0; i \u003c 10; i++) { if (i % 2 == 1) { System.out.println(Thread.currentThread().getName() + \":\" + i); } } } }.start(); } } ","date":"2021-04-16","objectID":"/java-shk-7/:2:1","tags":["Java"],"title":"Java零基础教程（七.多线程）","uri":"/java-shk-7/"},{"categories":null,"content":"2.2 Thread类中常用的方法 测试Thread中常用方法 start()：启动当前线程；调用当前线程的run() run()：通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中 currentThread()：静态方法，返回执行当前代码的线程 getName()：获取当前线程的名字 setName()：设置当前线程的名字 yield()：释放当前CPU的执行权 join()：在线程a中调用线程b的join(),此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才结束阻塞状态。 stop()：已过时。当执行此方法时，强制结束此线程 sleep(long millitime)：让当前线程\"睡眠\"指定的毫秒。在指定的毫秒时间内，当前的线程是阻塞状态。 isAlive()：判断当前线程是否存活 线程的优先级 MAX_PRIORITY: 10; MIN_PRIORITY: 1; NORM_PRIORITY: 5 如何获取和设置当前线程的优先级： getPriority(): 获取当前线程的优先级 setPriority(int p): 设置线程的优先级 说明： 高优先级的线程抢占低优先级线程CPU的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下被执行。并不意味着只有当高优先级的线程执行完以后，低优先级的线程才执行。 package com.atguigu.java; public class ThreadMethodTest { public static void main(String[] args) { HelloThread h1 = new HelloThread(\"Thread h1\"); // h1.setName(\"线程一\"); // 设置分线程的优先级 // h1.setPriority(Thread.MAX_PRIORITY); h1.start(); // 给主线程命名 Thread.currentThread().setName(\"主线程\"); // Thread.currentThread().setPriority(Thread.MIN_PRIORITY); for (int i = 0; i \u003c 10; i++) { if (i % 2 == 1) { System.out.println(Thread.currentThread().getName() + \": \" + Thread.currentThread().getPriority() + \": \"+ i); } if (i == 5) { try { h1.join(); } catch (InterruptedException e) { e.printStackTrace(); } } } System.out.println(h1.isAlive()); } } class HelloThread extends Thread { public HelloThread(String name) { super(name); } @Override public void run() { for (int i = 0; i \u003c 10; i++) { if (i % 2 == 0) { try { sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \": \" + Thread.currentThread().getPriority() + \": \"+ i); } // if (i % 20 == 0) { // yield(); // } } } } 例子：用此方式（继承Thread）处理共享数据 package com.atguigu.java; /* 例子： 创建三个窗口卖票，总票数为100张，使用继承Thread类的方式 存在线程安全问题，待解决... */ class Window extends Thread { private static int ticket = 100; @Override public void run() { while (true) { if (ticket \u003e 0) { System.out.println(getName() + \"卖票， 票号为：\" + ticket); ticket--; } else { break; } } } } public class WindowTest { public static void main(String[] args) { Window t1 = new Window(); Window t2 = new Window(); Window t3 = new Window(); t1.setName(\"窗口1\"); t2.setName(\"窗口2\"); t3.setName(\"窗口3\"); t1.start(); t2.start(); t3.start(); } } ","date":"2021-04-16","objectID":"/java-shk-7/:2:2","tags":["Java"],"title":"Java零基础教程（七.多线程）","uri":"/java-shk-7/"},{"categories":null,"content":"2.3 多线程的创建方式二：实现Runnable 创建多线程的方式二：实现Runnable接口 创建一个实现Runnable接口的类 实现类去实现Runnable中的抽象方法：run() 创建实现类的对象 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象 通过Thread类的对象调用start() 比较创建线程的两种方式： 开发中，优先选择实现Runnable接口的方式, 原因： 实现的方式没有类的单继承的局限性 实现的方式更适合来处理多个线程有共享数据的情况 联系： public class Thread implements Runnable 相同点：两种方式都需要重写run()，将线程要执行的逻辑声明在run()中。 package com.atguigu.java; // 1. 创建一个实现Runnable接口的类 class MThread implements Runnable { // 2. 实现类去实现Runnable中的抽象方法：run() @Override public void run() { for (int i = 0; i \u003c 10; i++) { if (i % 2 == 0) { System.out.println(Thread.currentThread().getName() + \": \" + i); } } } } public class ThreadTest1 { public static void main(String[] args) { // 3. 创建实现类的对象 MThread mThread = new MThread(); // 4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象 Thread t1 = new Thread(mThread); t1.setName(\"线程1\"); // 5. 通过Thread类的对象调用start(): 1)启动线程 2)调用当前线程的run() -\u003e 调用了Runnable类型的target t1.start(); // 再启动一个线程 Thread t2 = new Thread(mThread); t2.setName(\"线程2\"); t2.start(); } } 两种方式的对比 package com.atguigu.java; /* 例子： 创建三个窗口卖票，总票数为100张，使用实现Runnable接口的方式 */ class Window1 implements Runnable { // 不需要static：因为堆空间中只创建了一个对象，多个线程共享同一个对象 private int ticket = 100; @Override public void run() { while (true) { if (ticket \u003e 0) { System.out.println(Thread.currentThread().getName() + \"卖票，票号为：\" + ticket); ticket--; } else { break; } } } } public class WindowTest1 { public static void main(String[] args) { Window1 w = new Window1(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName(\"窗口1\"); t2.setName(\"窗口2\"); t3.setName(\"窗口3\"); t1.start(); t2.start(); t3.start(); } } ","date":"2021-04-16","objectID":"/java-shk-7/:2:3","tags":["Java"],"title":"Java零基础教程（七.多线程）","uri":"/java-shk-7/"},{"categories":null,"content":"3. 线程的生命周期 区分“阻塞”状态与“就绪”状态（yield）：阻塞是指CPU想执行也执行不了的状态。 ","date":"2021-04-16","objectID":"/java-shk-7/:3:0","tags":["Java"],"title":"Java零基础教程（七.多线程）","uri":"/java-shk-7/"},{"categories":null,"content":"4. 线程的同步 ","date":"2021-04-16","objectID":"/java-shk-7/:4:0","tags":["Java"],"title":"Java零基础教程（七.多线程）","uri":"/java-shk-7/"},{"categories":null,"content":"4.1 Java的同步机制 例子：创建三个窗口卖票，总票数100张，使用实现Runnable接口的方式 问题：卖票过程中，出现了重票和错票 -\u003e 出现了线程的安全问题 问题出现的原因：当某个线程操作车票的过程中，尚未操作完成时，其他线程参与进来，也操作车票。 如何解决：当一个线程在操作ticket的时候，其他线程不能参与进来。直到线程a操作完ticket时，其他线程才可以开始操作ticket。这种情况即使线程a出现了阻塞，也不能被改变。 在Java中，我们通过同步机制，来解决线程的安全问题。 方式一：同步代码块 synchronized(同步监视器) { // 需要被同步的代码 } 说明： 操作共享数据的代码，即为需要被同步的代码 – 不能包含代码多了，也不能包含代码少了 共享数据：多个线程共同操作的变量。比如：ticket就是共享数据。 同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。锁的要求：多个线程必须要共用同一把锁。 补充：在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器 方式二：同步方法 如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。 同步的方式，解决了线程的安全问题。– 好处 操作同步代码时，只能有一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低。 – 坏处 对于两种线程创建方式（继承Thread类，实现Runnable接口），各有两种解决线程安全的方案，即同步代码块和同步方法。四种情况组合如下： 同步代码块，Runnable package com.atguigu.java; /* */ class Window1 implements Runnable { private int ticket = 100; Object obj = new Object(); @Override public void run() { // Object obj = new Object(); // 线程还是不安全，这里没有共用一把锁 while (true) { synchronized (this) {// 此时的this：唯一的Window1的对象 // synchronized (obj) {// 正确 if (ticket \u003e 0) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \"卖票，票号：\" + ticket); ticket--; } else { break; } } } } } public class WindowTest1 { public static void main(String[] args) { Window1 w = new Window1(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName(\"窗口1\"); t2.setName(\"窗口2\"); t3.setName(\"窗口3\"); t1.start(); t2.start(); t3.start(); } } 同步代码块，继承Thread package com.atguigu.java; /* 使用同步代码块解决继承Thread类的方式的线程安全问题 例子：创建三个窗口卖票，总票数100张，使用继承Thread类的方式 说明：在继承Thread类创建多线程的方式中，慎用this充当同步监视器，考虑使用当前类充当同步监视器。 */ class Window2 extends Thread { private static int ticket = 100; // 注意static锁 private static Object obj = new Object(); @Override public void run() { while (true) { // synchronized (obj) { // synchronized (this) {// 错误，this代表着t1,t2,t3三个对象 synchronized (Window2.class) {// Class clazz = Window2.class, Window2.class只会加载一次 if (ticket \u003e 0) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(getName() + \"卖票，票号：\" + ticket); ticket--; } else { break; } } } } } public class WindowTest2 { public static void main(String[] args) { Window2 t1 = new Window2(); Window2 t2 = new Window2(); Window2 t3 = new Window2(); t1.setName(\"窗口1\"); t2.setName(\"窗口2\"); t3.setName(\"窗口3\"); t1.start(); t2.start(); t3.start(); } } 同步方法，实现Runnable package com.atguigu.java; /* 使用同步方法解决实现Runnable接口的线程安全问题 关于同步方法的总结： 1。 同步方法仍然涉及到同步监视器，只是不需要我们显式地声明。 2。 非静态的同步方法，同步监视器是：this 3。 静态的同步方法，同步监视器是：当前类本身 */ class Window3 implements Runnable { private int ticket = 100; @Override public void run() { while (true) { show(); } } private synchronized void show() { // 同步监视器：this if (ticket \u003e 0) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \"卖票，票号：\" + ticket); ticket--; } } } public class WindowTest3 { public static void main(String[] args) { Window3 w = new Window3(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName(\"窗口1\"); t2.setName(\"窗口2\"); t3.setName(\"窗口3\"); t1.start(); t2.start(); t3.start(); } } 同步方法，继承Thread package com.atguigu.java; class Window4 extends Thread { private static int ticket = 100; @Override public void run() { while (true) { show(); } } private static synchronized void show() { // 正确，static共享锁，同步监视器：Windows4.class // private synchronized void show() { // 错误，同步监视器：t1,t2,t3 if (ticket \u003e 0) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \"卖票，票号：\" + ticket); ticket--; } } } public class WindowTest4 { public static void main(String[] args) { Window4 t1 = new Window4(); Window4 t2 = new Window4(); Window4 t3 = new Window4(); t1.setName(\"窗口1\"); t2.setName(\"窗口2\"); t3.setName(\"窗口3\"); t1.start(); t2.start(); t3.start(); } } ","date":"2021-04-16","objectID":"/java-shk-7/:4:1","tags":["Java"],"title":"Java零基础教程（七.多线程）","uri":"/java-shk-7/"},{"categories":null,"content":"4.2 懒汉式同步机制回顾 package com.atguigu.java1; /* 使用同步机制将单例模式中的懒汉式改写为线程安全的 */ public class BankTest { } class Bank { private Bank(){} private static Bank instance = null; public static Bank getInstance() { // 方式一：效率稍差 // synchronized (Bank.class) { // if (instance == null) { // instance = new Bank(); // return instance; // } // } // 方式二：效率更高 if (instance == null) { synchronized (Bank.class) { if (instance == null) { instance = new Bank(); } } } return instance; } } ","date":"2021-04-16","objectID":"/java-shk-7/:4:2","tags":["Java"],"title":"Java零基础教程（七.多线程）","uri":"/java-shk-7/"},{"categories":null,"content":"4.3 死锁问题 不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁。（例子：两人吃饭，一人拿一根筷子） 演示线程的死锁问题 死锁的理解：不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁。 说明： 出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续 我们使用同步时，要避免出现死锁。 解决方法： 专门的算法，原则 尽量减少同步资源的定义 尽量避免嵌套同步 package com.atguigu.java1; public class ThreadTest { public static void main(String[] args) { StringBuffer s1 = new StringBuffer(); StringBuffer s2 = new StringBuffer(); new Thread(){ @Override public void run() { synchronized (s1) { s1.append(\"a\"); s2.append(\"1\"); try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (s2) { s1.append(\"b\"); s2.append(\"2\"); System.out.println(s1); System.out.println(s2); } } } }.start(); new Thread(new Runnable() { @Override public void run() { synchronized (s2) { s1.append(\"c\"); s2.append(\"3\"); try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (s1) { s1.append(\"d\"); s2.append(\"4\"); System.out.println(s1); System.out.println(s2); } } } }).start(); } } ","date":"2021-04-16","objectID":"/java-shk-7/:4:3","tags":["Java"],"title":"Java零基础教程（七.多线程）","uri":"/java-shk-7/"},{"categories":null,"content":"4.4 第三种同步机制（JDK5.0新增）- Lock 解决线程安全问题的方式三：Lock锁 — JDK5.0新增 面试题：synchronized 与 Lock的异同？ 同：二者都可以解决线程安全问题 不同：synchronized机制在执行完相应的同步代码以后，自动地释放同步监视器 Lock需要手动地启动同步lock(),同时结束同步也需要手动地实现unlock() 优先使用顺序：Lock -\u003e 同步代码块（已经进入了方法体，分配了相应资源） -\u003e 同步方法（在方法体之外） 面试题：如何解决线程安全问题？有几种方式？synchronized， Lock package com.atguigu.java1; import java.util.concurrent.locks.ReentrantLock; class Window implements Runnable { private int ticket = 100; // 1. 实例化ReentrantLock private ReentrantLock lock = new ReentrantLock(); @Override public void run() { while (true) { try { // 2. 调用锁定方法lock()方法 lock.lock(); if (ticket \u003e 0) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \"售票，票号：\" + ticket); ticket--; } else { break; } } catch (Exception e) { e.printStackTrace(); } finally { // 3. 调用解锁方法：unlock() lock.unlock(); } } } } public class LockTest { public static void main(String[] args) { Window w = new Window(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.start(); t2.start(); t3.start(); } } 一道练习 package com.atguigu.exer; class Account { private double balance; public Account(double balance) { this.balance = balance; } public synchronized void deposit(double amt) { if (amt \u003e 0) { balance += amt; try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \"存钱成功，余额：\" + balance); } } } class Customer extends Thread { private Account acct; @Override public void run() { for (int i = 0; i \u003c 3; i++) { acct.deposit(1000); } } public Customer(Account acct) { this.acct = acct; } } public class AccountTest { public static void main(String[] args) { Account acct = new Account(0); Customer c1 = new Customer(acct); Customer c2 = new Customer(acct); c1.setName(\"c1\"); c2.setName(\"c2\"); c1.start(); c2.start(); } } ","date":"2021-04-16","objectID":"/java-shk-7/:4:4","tags":["Java"],"title":"Java零基础教程（七.多线程）","uri":"/java-shk-7/"},{"categories":null,"content":"5. 线程的通信 线程通信的例子：使用两个线程打印1-100。线程1，线程2交替打印 涉及到的三个方法： wait()：一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器（锁） notify()：一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的线程 notifyAll()：一旦执行此方法，就会唤醒所有被wait的线程。 说明： wait(), notify(), notifyAll()三个方法必须使用在同步代码块或同步方法中。 wait(), notify(), notifyAll()三个方法的调用者必须是同步代码块或同步方法中的同步监视器。否则，会出现IllegalMonitorStateException异常 wait(), notify(), notifyAll()三个方法是定义在java.lang.Object类中 面试题：sleep()和wait()的异同？ 相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态 不同点 两个方法声明的位置不同：Thread类中声明sleep(), Object类中声明wait() 调用的要求不同：sleep()可以在任何需要的场景下调用。wait()必须使用在同步代码块或同步方法中 关于是否释放同步监视器（锁）：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。 package com.atguigu.java2; class Number implements Runnable { private int number = 1; private Object obj = new Object(); @Override public void run() { while (true) { synchronized (obj) { obj.notify(); if (number \u003c 100) { System.out.println(Thread.currentThread().getName() + \" : \" + number); number++; try { // 使得调用如下wait()方法的线程进入阻塞状态 obj.wait();// 会释放锁。作为对比，sleep不会释放锁 } catch (InterruptedException e) { e.printStackTrace(); } } else { break; } } } } } public class CommunicationTest { public static void main(String[] args) { Number number = new Number(); Thread t1 = new Thread(number); Thread t2 = new Thread(number); t1.setName(\"线程1\"); t2.setName(\"线程2\"); t1.start(); t2.start(); } } 看一道综合的例题：生产者/消费者问题 package com.atguigu.java2; /* 线程通信的应用：经典例题：生产者/消费者问题 生产者（Productor）将产品交给店员（Clerk），而消费者（Customer）从店员处取走产品，店员一次只能持有固定数量的产品（比如：20）， 如果生产者试图生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品了再通知生产者继续生产；如果店中没有产品了，店员会告诉 消费者等一下，如果店中有产品了再通知消费者来取走产品。 分析： 1. 是否有多线程问题？是，生产者线程，消费者线程 2. 是否有共享数据？是，店员（或产品） 3. 如何解决线程的安全问题？同步机制，有三种方法 4. 是否涉及到线程通信？是 */ class Clerk { private int productCount = 0; // 生产产品 public synchronized void produceProduct() { if (productCount \u003c 20) { productCount++; System.out.println(Thread.currentThread().getName() + \"开始生产第\" + productCount + \"个产品\"); notify(); } else { try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } // 消费产品 public synchronized void consumeProduct() { if (productCount \u003e 0) { System.out.println(Thread.currentThread().getName() + \"开始消费第\" + productCount + \"个产品\"); productCount--; notify(); } else { try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } } class Producer extends Thread { private Clerk clerk; public Producer(Clerk clerk) { this.clerk = clerk; } @Override public void run() { System.out.println(Thread.currentThread().getName() + \"开始生产产品...\"); while (true) { try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } clerk.produceProduct(); } } } class Consumer extends Thread { private Clerk clerk; public Consumer(Clerk clerk) { this.clerk = clerk; } @Override public void run() { System.out.println(Thread.currentThread().getName() + \"开始消费产品...\"); while (true) { try { Thread.sleep(20); } catch (InterruptedException e) { e.printStackTrace(); } clerk.consumeProduct(); } } } public class ProductTest { public static void main(String[] args) { Clerk clerk = new Clerk(); Producer p1 = new Producer(clerk); p1.setName(\"生产者1\"); Consumer c1 = new Consumer(clerk); c1.setName(\"消费者1\"); Consumer c2 = new Consumer(clerk); c2.setName(\"消费者2\"); p1.start(); c1.start(); c2.start(); } } ","date":"2021-04-16","objectID":"/java-shk-7/:5:0","tags":["Java"],"title":"Java零基础教程（七.多线程）","uri":"/java-shk-7/"},{"categories":null,"content":"6. JDK5.0新增线程创建方式 ","date":"2021-04-16","objectID":"/java-shk-7/:6:0","tags":["Java"],"title":"Java零基础教程（七.多线程）","uri":"/java-shk-7/"},{"categories":null,"content":"6.1 多线程的创建方式三：实现Callable接口（JDK5.0新增） 如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建线程方式强大？ call()可以有返回值的。 call()可以抛出异常，被外面的操作捕获，获取异常的信息 Callable是支持范型的 使用步骤： 创建一个实现Callable的实现类 实现call方法，将此线程需要执行的操作声明在call()中 创建Callable接口实现类的对象 将此Callable接口实现类的对象作为参数传递到FutureTask构造器中，创建FutureTask的对象 将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()。 (optional) 获取Callable中call方法的返回值 package com.atguigu.java2; import java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.FutureTask; class NumThread implements Callable { @Override public Object call() throws Exception { int sum = 0; for (int i = 1; i \u003c 100; i++) { if (i % 2 == 0) { System.out.println(i); sum += i; } } return sum; } } public class ThreadNew { public static void main(String[] args) { NumThread numThread = new NumThread(); FutureTask futureTask = new FutureTask(numThread); new Thread(futureTask).start(); try { // get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值 Object sum = futureTask.get(); System.out.println(\"总和为：\" + sum); } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } } } ","date":"2021-04-16","objectID":"/java-shk-7/:6:1","tags":["Java"],"title":"Java零基础教程（七.多线程）","uri":"/java-shk-7/"},{"categories":null,"content":"6.2 多线程的创建方式四：线程池 线程池 背景：经常创建和销毁使用量特别大的资源，比如并发情况下的线程，对性能影响很大。 思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁，实现重复利用。类似生活中的公共交通工具。 好处： 提高响应速度（减少了创建新线程的时间） 降低资源消耗（重复利用线程池中线程，不需要每次都创建） 便于线程管理 corePoolSize：核心池的大小 maximumPoolSize：最大线程数 keepAliveTime：线程没有任务时最多保持多长时间后会终止 开发中，一般都使用线程池的方式创建和管理线程 面试题：创建多线程有几种方式？四种！ package com.atguigu.java2; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; class NumberThread implements Runnable { @Override public void run() { for (int i = 0; i \u003c 100; i++) { if (i % 2 == 0) { System.out.println(Thread.currentThread().getName()+ \" : \" + i); } } } } class NumberThread1 implements Runnable { @Override public void run() { for (int i = 0; i \u003c 100; i++) { if (i % 2 != 0) { System.out.println(Thread.currentThread().getName() + \" : \" + i); } } } } public class ThreadPool { public static void main(String[] args) { // 1. 提供指定线程数量的线程池 // 2. 执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象 ExecutorService service = Executors.newFixedThreadPool(10); // 设置线程池的属性 System.out.println(service.getClass()); // ThreadPoolExecutor // ThreadPoolExecutor service1 = (ThreadPoolExecutor) service;// 向下转型 // service1.setCorePoolSize(15);// 线程池的管理 service.execute(new NumberThread());//适用于Runnable service.execute(new NumberThread1()); // service.submit(Callable callable);//适用于Callable // 3. 关闭线程池 service.shutdown(); } } ","date":"2021-04-16","objectID":"/java-shk-7/:6:2","tags":["Java"],"title":"Java零基础教程（七.多线程）","uri":"/java-shk-7/"},{"categories":null,"content":"1. static关键字 ","date":"2021-04-10","objectID":"/java-shk-6/:1:0","tags":["Java"],"title":"Java零基础教程（六.面向对象-重要补充）","uri":"/java-shk-6/"},{"categories":null,"content":"1.1 static关键字的使用 static: 静态 static可以用来修饰：属性，方法，代码块，内部类 使用static修饰属性: 静态变量（是属性，不是局部变量）或者叫类变量 属性，按是否使用static修饰，有分为静态属性 vs 非静态属性（实例变量） 实例变量：我们创建类类的多个对象，每个对象都独立的拥有一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值的修改。 静态变量：我们创建类类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的。 static修饰属性的其他说明： 静态变量随着类的加载而加载。可以通过“类.静态变量”的方式进行调用 静态变量的加载要早于对象的创建。 由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中。 调用 类变量 实例变量 类 yes no 对象 yes yes 静态属性举例： System.out; Math.PI; 使用static修饰方法: 静态方法 随着类的加载而加载，可以通过“类.静态方法”的方式进行调用 调用 静态方法 非静态方法 类 yes no 对象 yes yes 静态方法中，只能调用静态的方法或属性; 非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性 static注意点： 在静态的方法内，不能使用this关键字，super关键字 关于静态属性和静态方法的使用，大家都可以从生命周期的角度来理解 开发中，如何确定一个属性是否要声明为static的？ 属性是可以被多个对象所共享的，不会随着对象的不同而不同的。 类中的常量也常常声明为static，比如PI 开发中，如何确定一个方法是否要声明为static的？ 操作静态属性的方法，通常设置为static的 工具类中的方法，习惯上声明为static的。比如：Math，Arrays，Collections package com.atguigu.java1; public class StaticTest { public static void main(String[] args) { Chinese c1 = new Chinese(); c1.name = \"姚明\"; c1.age = 40; Chinese c2 = new Chinese(); c2.name = \"马龙\"; c2.age = 30; c1.nation = \"CHN\"; System.out.println(c2.nation); // 编译不通过 // Chinese.name = \"张继科\"; Chinese.show(); } } class Chinese { String name; int age; static String nation; public void eat() { System.out.println(\"Chinese eat\"); } public static void show() { System.out.println(\"I am Chinese\"); // 不能调用非静态结构 // eat(); // name = \"Tom\"; // 可以调用静态结构 System.out.println(nation); } } 再来看一个应用static的例子 package com.atguigu.java1; public class CircleTest { public static void main(String[] args) { Circle c1 = new Circle(); Circle c2 = new Circle(); System.out.println(\"c1 ID: \" + c1.getId()); System.out.println(\"c2 ID: \" + c2.getId()); System.out.println(\"total number of circles: \" + Circle.getTotal()); } } class Circle { private double radius; private int id; private static int total = 0; // 记录创建圆的个数 private static int init = 1001; // static声明的属性被所有对象所共享 public Circle() { id = init++; total++; } public Circle(double radius) { this(); this.radius = radius; } public double getRadius() { return radius; } public static int getTotal() { return total; } public void setRadius(double radius) { this.radius = radius; } public int getId() { return id; } public void setId(int id) { this.id = id; } public double findArea() { return 3.14 * radius * radius; } } ","date":"2021-04-10","objectID":"/java-shk-6/:1:1","tags":["Java"],"title":"Java零基础教程（六.面向对象-重要补充）","uri":"/java-shk-6/"},{"categories":null,"content":"1.2 static应用 - 单例模式（Singleton） 单例设计模式 所谓类的单例设计模式，就是采用一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例。 如何实现？饿汉式 vs 懒汉式 区分 饿汉式 和 懒汉式 饿汉式： 坏处：对象加载时间过长 好处：饿汉式是线程安全的 懒汉式： 好处：延迟对象的创建。 目前的写法坏处：线程不安全。 -\u003e 到多线程内容时，再修改 package com.atguigu.java2; public class SingletonTest1 { public static void main(String[] args) { // 饿汉式 Bank bank1 = Bank.getInstance(); Bank bank2 = Bank.getInstance(); System.out.println(bank1 == bank2); // 懒汉式 Order order1 = Order.getInstance(); Order order2 = Order.getInstance(); System.out.println(order1 == order2); } } class Bank { // 1. 私有化类的构造器 private Bank() { } // 2. 内部创建类的对象 // 4. 要求此对象也必须声明为静态的 private static Bank instance = new Bank(); // 3. 提供公共的静态的方法，返回类的对象 public static Bank getInstance() { return instance; } } class Order { // 1. 私有化构造器 private Order() { } // 2. 声明当前类对象，没有初始化 // 4. 此对象也必须声明为static的 private static Order instance = null; // 3. 声明public，static的返回当前类对象的方法 public static Order getInstance() { if (instance == null) { instance = new Order(); } return instance; } } ","date":"2021-04-10","objectID":"/java-shk-6/:1:2","tags":["Java"],"title":"Java零基础教程（六.面向对象-重要补充）","uri":"/java-shk-6/"},{"categories":null,"content":"2. main方法的回顾 main()方法的使用说明： main()方法作为程序的入口 main()方法也是一个普通的静态方法 main()方法可以作为我们与控制台交互的方式。（之前Scanner） package com.atguigu.java2; public class MainTest { public static void main(String[] args) { Main.main(new String[100]); for (int i = 0; i \u003c args.length; i++) { System.out.println(\"*****\" + args[i]);// run configuration int num = Integer.parseInt(args[i]); System.out.println(\"####\" + num); } } } class Main { public static void main(String[] args) { args = new String[100]; for (int i = 0; i \u003c args.length; i++) { args[i] = \"args_\" + i; System.out.println(args[i]); } } } ","date":"2021-04-10","objectID":"/java-shk-6/:2:0","tags":["Java"],"title":"Java零基础教程（六.面向对象-重要补充）","uri":"/java-shk-6/"},{"categories":null,"content":"3. 代码块 类的成员之四：代码块（或初始化块） 代码块的作用：用来初始化类和对象 代码块如果有修饰的话，只能使用static。 分类：静态代码块 vs 非静态代码块 静态代码块 内部可以有输出语句 随着类的加载而执行, 而且只执行一次 作用：初始化类的属性 如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行 静态代码块的执行要优先于非静态代码块的执行 静态代码块内只能调用静态的属性，静态的方法，不能调用非静态的结构 非静态代码块 内部可以有输出语句 随着对象的创建而执行 每创建一个对象，就执行一次非静态代码块 作用：可以在创建对象时，对对象的属性等进行初始化 如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行 非静态代码块内可以调用静态的属性，静态的方法，或非静态的属性，非静态的方法。 对属性可以赋值的位置： 1）默认初始化 2）显式初始化 3）构构造器中初始化 4）有了对象以后，可以通过“对象.属性”或“对象.方法”的方式赋值 5）在代码块中赋值 执行的顺序：1）- 2）/ 5）- 3）- 4） package com.atguigu.java3; public class BlockTest { public static void main(String[] args) { String desc = Person.desc; Person p1 = new Person(); Person p2 = new Person(); } } class Person { String name; int age; static String desc; public Person() { } public Person(String name, int age) { this.name = name; this.age = age; } // static的代码块 static { System.out.println(\"static block\"); desc = \"I love coding\"; } // 非static的代码块 { System.out.println(\"block\"); } public void eat() { System.out.println(\"person eat\"); } @Override public String toString() { return \"Person [name=\" + name + \", age=\" + age + \"]\"; } } 代码块是要早于构造器执行的 package com.atguigu.java3; public class LeafTest { public static void main(String[] args) { new Leaf(); // output: // Root的静态代码块 // Mid的静态代码块 // Leaf的静态代码块 // Root的普通代码块 // Root的无参构造器 // Mid的普通代码块 // Mid的带参构造器 // Leaf的普通代码块 // Leaf的无参构造器 } } class Root { static { System.out.println(\"Root的静态代码块\"); } { System.out.println(\"Root的普通代码块\"); } public Root() { System.out.println(\"Root的无参构造器\"); } } class Mid extends Root { static { System.out.println(\"Mid的静态代码块\"); } { System.out.println(\"Mid的普通代码块\"); } public Mid() { System.out.println(\"Mid的无参构造器\"); } public Mid(String msg) { System.out.println(\"Mid的带参构造器\"); } } class Leaf extends Mid { static { System.out.println(\"Leaf的静态代码块\"); } { System.out.println(\"Leaf的普通代码块\"); } public Leaf() { super(\"message\"); System.out.println(\"Leaf的无参构造器\"); } } 再看一个例子 package com.atguigu.java3; class Father { static { System.out.println(\"1\"); } { System.out.println(\"2\"); } public Father() { System.out.println(\"3\"); } } public class Son extends Father { static { System.out.println(\"4\"); } { System.out.println(\"5\"); } public Son() { System.out.println(\"6\"); } public static void main(String[] args) { System.out.println(\"7\"); new Son(); System.out.println(\"*****\"); new Son(); // output: 1 - 4 - 7 - 2 - 3 - 5 - 6 // output: ***** // output: 2 - 3 - 5 - 6 } } ","date":"2021-04-10","objectID":"/java-shk-6/:3:0","tags":["Java"],"title":"Java零基础教程（六.面向对象-重要补充）","uri":"/java-shk-6/"},{"categories":null,"content":"4. final关键字 final: final可以用来修饰的结构： 类，方法，变量 final用来修饰一个类: 此类不能被其他类所继承，即不能有子类了，比如：String类，System类，StringBuffer类。 final用来修饰一个方法：表明此方法不可以被重写，比如：Object类中getClass()。 final用来修饰变量：此时的“变量”就称为是一个常量 final修饰属性：可以考虑赋值的位置有：显式初始化，代码块中初始化, 构造器中初始化，（默认，方法位置都不赋值） final修饰局部变量：尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。 static final: static修饰属性，方法，代码块，内部类。final修饰属性，方法，类。其用来修饰属性表示全局常量。 自己用final通常就用来修饰属性，别人用来修饰方法和类时，能看懂。 package com.atguigu.java3; public class FinalTest { final int width = 10; final int LEFT; final int RIGHT; // final int DOWN; { LEFT = 1; } public FinalTest() { RIGHT = 2; } public FinalTest(int n) { RIGHT = n; } // public void setDown(int down) { // this.DOWN = down; // } public void doWidth() { // width = 20; } public void show() { final int NUM = 10;// 常量 // NUM += 20; } public void show(final int num) { // num = 20; // 编译错误 } public static void main(String[] args) { } } final class FinalA { } //class B extends FinalA{ // //} class AA { public final void show() { } } class BB extends AA { // public final void show() { // // } } 看一道题 package com.atguigu.java3; public class FinalExerciseTest { public static void main(String[] args) { Other o = new Other(); new FinalExerciseTest().addOne(o); } public void addOne(final Other o) { // o = new Other(); // 错误，o是final，不能指向新目标 o.i++;// 正确，o指向对象的i是变量，可以变化 System.out.println(o.i);// 1 } } class Other { public int i; } ","date":"2021-04-10","objectID":"/java-shk-6/:4:0","tags":["Java"],"title":"Java零基础教程（六.面向对象-重要补充）","uri":"/java-shk-6/"},{"categories":null,"content":"5. 抽象类 ","date":"2021-04-10","objectID":"/java-shk-6/:5:0","tags":["Java"],"title":"Java零基础教程（六.面向对象-重要补充）","uri":"/java-shk-6/"},{"categories":null,"content":"5.1 abstract关键字的使用 abstract：抽象的 abstract可以用来修饰的结构：类，方法 abstract修饰类：抽象类 此类不能实例化 抽象类中一定有构造器，便于子类实例化时调用（涉及：子类对象实例化的全过程） 开发中，都会提供抽象类的子类，让子类对象实例化，完成相应操作 abstract修饰方法：抽象方法 抽象方法只有方法的声明，没有方法体 包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法。 若子类重写了父类中所有的抽象方法后，此子类方可实例化 若子类没有重写父类中的所有的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰 package com.atguigu.java; public class AbstractTest { public static void main(String[] args) { // 一旦Person类抽象了，就不可实例化 // Person p1 = new Person(); // p1.eat(); } } abstract class Person { String name; int age; public Person() { } public Person(String name, int age) { this.name = name; this.age = age; } // 不是抽象方法 // public void eat() { // } // 抽象方法 public abstract void eat(); public void walk() { System.out.println(\"person walk\"); } } class Student extends Person { public Student(String name, int age) { super(name, age); } public void eat() { System.out.println(\"student eat\"); } } abstract使用上的注意点： abstract不能用来修饰：属性，构造器等结构 abstract不能用来修饰私有方法（private方法子类不能看作重写），静态方法（子父类都为static不能看作重写），final的方法，final的类 package com.atguigu.java; public class AbstractTest1 { } ","date":"2021-04-10","objectID":"/java-shk-6/:5:1","tags":["Java"],"title":"Java零基础教程（六.面向对象-重要补充）","uri":"/java-shk-6/"},{"categories":null,"content":"5.2 匿名子类 package com.atguigu.java; /* * 抽象类的匿名子类 */ public class PersonTest { public static void main(String[] args) { method(new B()); // 匿名对象 // 创建了一个匿名子类的对象 A a = new A() { @Override public void method1() { System.out.println(\"11111\"); } @Override public void method2() { System.out.println(\"22222\"); }}; method(a); System.out.println(\"==============\"); // 匿名子类的匿名对象 method(new A() { @Override public void method1() { System.out.println(\"333\"); } @Override public void method2() { System.out.println(\"444\"); }}); } public static void method(A a) { a.method1(); a.method2(); } } abstract class A { public abstract void method1(); public abstract void method2(); } class B extends A { @Override public void method1() { System.out.println(\"b method1\"); } @Override public void method2() { System.out.println(\"b method2\"); } } ","date":"2021-04-10","objectID":"/java-shk-6/:5:2","tags":["Java"],"title":"Java零基础教程（六.面向对象-重要补充）","uri":"/java-shk-6/"},{"categories":null,"content":"5.3 abstract应用 - 模板方法设计模式 package com.atguigu.java; /* * 抽象类的应用：模板方法的设计模式 */ public class TemplateTest { public static void main(String[] args) { Template t = new SubTemplate(); t.spendTime(); } } abstract class Template { public void spendTime() { long start = System.currentTimeMillis(); code(); long end = System.currentTimeMillis(); System.out.println(\"elapsed time: \"+ (end - start)); } public abstract void code(); } class SubTemplate extends Template { @Override public void code() { for (int i = 2; i \u003c= 1000; i++) { boolean isFlag = true; for (int j = 2; j \u003c= Math.sqrt(i); j++) { if (i % j == 0) { isFlag = false; break; } } if (isFlag) { System.out.println(i); } } } } 再来看一个模板方法设计模式的例子 package com.atguigu.java; // 抽象类的应用：模板方法的设计模式 public class TemplateMethodTest { public static void main(String[] args) { BankTemplateMethod m1 = new DrawMoney(); BankTemplateMethod m2 = new DrawMoney(); m1.process(); m2.process(); } } abstract class BankTemplateMethod { public void takeNumber() { System.out.println(\"take number\"); } public abstract void transact(); // 办理具体业务，钩子方法 public void evaluate() { System.out.println(\"give us a feedback! thanks\"); } public final void process() { takeNumber(); transact(); // 像个钩子，具体执行时，挂哪个子类，就执行哪个子类的实现代码 evaluate(); } } class DrawMoney extends BankTemplateMethod { @Override public void transact() { System.out.println(\"I want to draw my money out of my account\"); } } class ManageMoney extends BankTemplateMethod { @Override public void transact() { System.out.println(\"I want a private client to help me manage my money\"); } } ","date":"2021-04-10","objectID":"/java-shk-6/:5:3","tags":["Java"],"title":"Java零基础教程（六.面向对象-重要补充）","uri":"/java-shk-6/"},{"categories":null,"content":"6. 接口 一方面，有时必须从几个类中派生出一个子类，继承它们所有的属性和方法。但是，Java不支持多重继承。有了借口，就可以得到多重继承的效果。 另一方面，有时必须从几个类中抽取出一些共同的行为特征，而它们之间又没有“is-a”的关系，仅仅是具有相同的行为特征而已。例如：鼠标，键盘，打印机，扫描仪，摄像头，充电器，手机，移动硬盘等都支持USB连接。 接口就是规范，定义的是一组规则，体现了现实世界中“如果你是/要…则必须能”的思想。继承是一个“是不是”的关系，而接口实现则是“能不能”的关系。 接口的本质是契约，标准，规范，就像我们的法律一样。制订好后大家都要遵守。 ","date":"2021-04-10","objectID":"/java-shk-6/:6:0","tags":["Java"],"title":"Java零基础教程（六.面向对象-重要补充）","uri":"/java-shk-6/"},{"categories":null,"content":"6.1 接口的使用 接口使用interface来定义 Java中，接口和类是并列的两个结构 如何定义接口：定义接口中的成员 JDK7及以前：只能定义全局常量和抽象方法 全局常量：public static final的…但是书写时，可以省略不写 抽象方法：public abstract的 JDK8: 除了定义全局常量和抽象方法之外，还可以定义静态方法，默认方法（略） 接口中不能构造构造器的！意味着接口不可以实例化 Java开发中，接口通过让类去实现（implements）的方式来使用. 如果实现类覆盖了接口中的所有抽象方法，则此实现类就可以实例化 如果实现类没有覆盖接口中所有的抽象方法，则此实现类仍为一个抽象类。 Java类可以实现多个接口 -\u003e 弥补了Java单继承性的局限性 格式： class AA extends BB implements CC, DD, EE 接口与接口之间可以继承，而且可以多继承 接口的具体使用，体现多态性 接口，实际上可以看作是一种规范。 面试题：抽象类与接口有哪些异同？ package com.atguigu.java1; public class InterfaceTest { public static void main(String[] args) { Plane p = new Plane(); p.fly(); p.stop(); } } interface Attackable { void attack(); } interface Flyable { // 全局常量 public static final int MAX_SPEED = 7900;// 第一宇宙速度 int MIN_SPEED = 1; // 省略了public static final // 抽象方法 public abstract void fly(); void stop(); // 省略了public abstract } class Plane implements Flyable { @Override public void fly() { System.out.println(\"plane fly\"); } @Override public void stop() { System.out.println(\"plane stop\"); } } abstract class Kite implements Flyable { @Override public void fly() { System.out.println(\"kite fly\"); } } class Bullet implements Flyable, Attackable, CC { @Override public void attack() { // TODO Auto-generated method stub } @Override public void fly() { // TODO Auto-generated method stub } @Override public void stop() { // TODO Auto-generated method stub } @Override public void method1() { // TODO Auto-generated method stub } @Override public void method2() { // TODO Auto-generated method stub } } // ********************** interface AA { void method1(); } interface BB { void method2(); } interface CC extends AA, BB { } USB例子 接口的使用 接口使用上也满足多态性 接口，实际上就是定义了一种规范 开发中， 体会面向接口编程！ package com.atguigu.java1; public class USBTest { public static void main(String[] args) { Computer c = new Computer(); // 1. 创建了接口的非匿名实现类的非匿名对象 Printer p = new Printer(); c.transferData(p); // 2. 创建了接口的非匿名实现类的匿名对象 c.transferData(new Printer()); // 3. 创建了接口的匿名实现类的非匿名对象 USB phone = new USB() { @Override public void start() { System.out.println(\"phone start\"); } @Override public void stop() { System.out.println(\"phone stop\"); } }; c.transferData(phone); // 4. 创建了接口匿名实现类的匿名对象 c.transferData(new USB() { @Override public void start() { System.out.println(\"mp3 start\"); } @Override public void stop() { System.out.println(\"mp3 stop\"); } }); } } class Computer { public void transferData(USB usb) { usb.start(); System.out.println(\"transfering data...\"); usb.stop(); } } interface USB { // 定义了长，宽，最大最小的传输速度等 void start(); void stop(); } class Flash implements USB { @Override public void start() { System.out.println(\"flash start\"); } @Override public void stop() { System.out.println(\"flash stop\"); } } class Printer implements USB { @Override public void start() { System.out.println(\"printer start\"); } @Override public void stop() { System.out.println(\"printer stop\"); } } ","date":"2021-04-10","objectID":"/java-shk-6/:6:1","tags":["Java"],"title":"Java零基础教程（六.面向对象-重要补充）","uri":"/java-shk-6/"},{"categories":null,"content":"6.2 interface应用 - 代理模式 package com.atguigu.java1; /* * 接口的应用：代理模式 */ public class NetworkTest { public static void main(String[] args) { Server s = new Server(); ProxyServer proxyServer = new ProxyServer(s); proxyServer.browse(); } } interface Network { public void browse(); } // 被代理类 class Server implements Network { @Override public void browse() { System.out.println(\"真实的服务器访问网络\"); } } // 代理类 class ProxyServer implements Network { private Network work; public ProxyServer(Network work) { this.work = work; } public void check() { System.out.println(\"联网之前的检查工作\"); } @Override public void browse() { check(); work.browse(); } } 再来看一个代理模式的例子：明星与经纪人 package com.atguigu.java1; /* * 代理模式另外一个例子 */ public class StaticProxyTest { public static void main(String[] args) { Proxy s = new Proxy(new RealStar()); s.confer(); s.signContract(); s.bootTicket(); s.sing(); s.collectMoeny(); // output // 经纪人面谈 // 经纪人签合同 // 经纪人订票 // sing... sing... sing... // 经纪人收钱 } } interface Star { void confer(); // 面谈 void signContract(); // 签合同 void bootTicket(); // 订票 void sing(); // 唱歌 void collectMoeny(); // 收钱 } // 被代理类 class RealStar implements Star { @Override public void confer() { } @Override public void signContract() { } @Override public void bootTicket() { } @Override public void sing() { System.out.println(\"sing... sing... sing...\"); } @Override public void collectMoeny() { } } // 代理类，经纪人 class Proxy implements Star { private Star real; public Proxy(Star real) { this.real = real; } @Override public void confer() { System.out.println(\"经纪人面谈\"); } @Override public void signContract() { System.out.println(\"经纪人签合同\"); } @Override public void bootTicket() { System.out.println(\"经纪人订票\"); } @Override public void sing() { real.sing(); } @Override public void collectMoeny() { System.out.println(\"经纪人收钱\"); }} 一道考题 package com.atguigu.java1; public class C extends B implements A { public static void main(String[] args) { new C().pX(); } public void pX() { System.out.println(super.x); // 1 System.out.println(A.x);// 0 } } interface A { int x = 0; } class B { int x = 1; } ","date":"2021-04-10","objectID":"/java-shk-6/:6:2","tags":["Java"],"title":"Java零基础教程（六.面向对象-重要补充）","uri":"/java-shk-6/"},{"categories":null,"content":"6.3 Java8中interface新特性 package com.atguigu.java8; public class SubClassTest { public static void main(String[] args) { SubClass s = new SubClass(); // 知识点1: 接口中定义的静态方法，只能通过接口来调用 // s.method1();// 编译报错 CompareA.method1(); // 知识点2: 通过实现类的对象，可以调用接口中的默认方法。 // 如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法 s.method2(); // 知识点3： 如果子类（或实现类）继承的父类和实现的接口中声明类同名同参数的方法 // 那么子类在没有重写此方法的情况下，默认调用的是父类中的同名同参数的方法。-\u003e 类优先原则 // 知识点4: 如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法， // 那么在实现类没有重写此方法的情况下，报错。 -\u003e 接口冲突 // 这就需要我们必须在实现类中重写此方法。 s.method3(); } } class SubClass extends SuperClass implements CompareA, CompareB { public void method2() { System.out.println(\"SubClass - method2\"); } // 知识点5:如何在子类（或实现类)的方法中调用父类，接口中被重写的方法 public void myMethod() { method3();// 调用自己定义的重写的方法 super.method3();// 调用的是父类中声明的 // 调用接口中默认的方法 CompareA.super.method3(); CompareB.super.method3(); } } class SuperClass { public void method3() { System.out.println(\"SuperClass - method3\"); } } /* * JDK8: 除了定义全局常量和抽象方法之外，还可以定义静态方法，默认方法 */ interface CompareA { // 静态方法 public static void method1() { System.out.println(\"CompareA - method1\"); } // 默认方法 public default void method2() { System.out.println(\"CompareA - method2\"); } // public可以省略 default void method3() { System.out.println(\"CompareA - method3\"); } } interface CompareB { default void method3() { System.out.println(\"CompareB - method3\"); } } ","date":"2021-04-10","objectID":"/java-shk-6/:6:3","tags":["Java"],"title":"Java零基础教程（六.面向对象-重要补充）","uri":"/java-shk-6/"},{"categories":null,"content":"6.4 接口冲突的解决方式 package com.atguigu.java8; public class Man extends Father implements Filial, Spoony { public void help() { System.out.println(\"接口冲突，该救谁呢\"); Filial.super.help(); Spoony.super.help(); super.help(); } public static void main(String[] args) { Man m = new Man(); m.help(); } } class Father { public void help() { System.out.println(\"儿子，救我媳妇！\"); } } interface Filial { default void help() {// 孝顺的 System.out.println(\"救妈妈\"); } } interface Spoony {// 痴情的 default void help() { System.out.println(\"救媳妇\"); } } ","date":"2021-04-10","objectID":"/java-shk-6/:6:4","tags":["Java"],"title":"Java零基础教程（六.面向对象-重要补充）","uri":"/java-shk-6/"},{"categories":null,"content":"6.5 抽象类和接口有哪些共同点和区别？ 相同点：不能实例化，都可以被继承 不同点： 抽象类：有构造器。单继承。 接口：不能声明构造器。多继承。 ","date":"2021-04-10","objectID":"/java-shk-6/:6:5","tags":["Java"],"title":"Java零基础教程（六.面向对象-重要补充）","uri":"/java-shk-6/"},{"categories":null,"content":"7. 内部类 类的内部成员之五：内部类（例子：人与大脑） Java中允许将一个类A声明在另一个类B中，则类A就是内部类，类B称为外部类。 内部类的分类：成员内部类（静态，非静态） vs 局部内部类（方法内，代码块内，构造器内） 成员内部类： 一方面，作为外部类的成员： 调用外部类的结构 可以被static修饰 可以被4种不同的权限修饰 另一方面，作为一个类出现： 类内可以定义属性，方法，构造器等 可以被final修饰，表示此类不能被继承。言外之意，不使用final，就可以被继承 可以被abstract修饰 关注如下的3个问题 如何实例化成员内部类的对象 如何在成员内部类中区分调用外部类的结构 开发中，局部内部类等使用 package com.atguigu.java2; public class InnerClassTest { public static void main(String[] args) { // 创建Dog实例（静态的成员内部类） Person.Dog dog = new Person.Dog(); dog.show(); // 创建Bird实例（非静态的成员内部类） // Person.Bird bird = new Person.Bird(); Person p = new Person(); Person.Bird bird = p.new Bird(); bird.sing(); System.out.println(\"===============\"); bird.display(\"黄鹂\"); } } class Person { String name = \"小明\"; int age; public void eat() { System.out.println(\"person eat\"); } // 静态成员内部类 static class Dog { String name; int age; public void show() { System.out.println(\"卡拉是条狗\"); // eat();// 编译报错，调用非静态 } } // 非静态成员内部类 class Bird { String name = \"杜鹃\"; public void sing() { System.out.println(\"我是一只小小鸟\"); eat(); Person.this.eat();// 调用外部类的非静态属性 } public void display(String name) { System.out.println(name); // 方法的形参 System.out.println(this.name); // 内部类的属性 System.out.println(Person.this.name); // 外部类的属性 } } public void method() { class AA { } } { class BB { } } public Person() { class CC { } } } 开发中使用内部类的情况 package com.atguigu.java2; public class InnerClassTest1 { // 开发中很少见 public void method() { class AA { } } // 开发中用内部类的情况： // 返回一个实现了Comparable接口的类的对象 public Comparable getComparable() { // 创建一个实现了Comparable接口的类: 局部内部类 // 方式一： 标准的方式 // class MyComparable implements Comparable { // // @Override // public int compareTo(Object o) { // // TODO Auto-generated method stub // return 0; // } // // } // // return new MyComparable(); // 方式二：匿名 return new Comparable() { @Override public int compareTo(Object o) { // TODO Auto-generated method stub return 0; } }; } } ","date":"2021-04-10","objectID":"/java-shk-6/:7:0","tags":["Java"],"title":"Java零基础教程（六.面向对象-重要补充）","uri":"/java-shk-6/"},{"categories":null,"content":"8. 异常处理 ","date":"2021-04-10","objectID":"/java-shk-6/:8:0","tags":["Java"],"title":"Java零基础教程（六.面向对象-重要补充）","uri":"/java-shk-6/"},{"categories":null,"content":"8.1 异常体系结构与常见异常 Java虚拟机无法解决的严重问题。如：JVM系统内部错误，资源耗尽等严重情况。比如：StackOverflowError， OOM。一般不编写针对性的代码进行处理。 package com.atguigu.java; public class ErrorTest { public static void main(String[] args) { // 1. 栈溢出：java.lang.StackOverflowError // main(args); // 2. 堆溢出：java.lang.OutOfMemoryError // Integer[] arr = new Integer[1024*1024*1024]; } } 异常的体系结构 java.lang.Throwable | --- java.lang.Error:一般不编写针对性的代码进行处理 | --- java.lang.Exception: 可以进行异常的处理 | --- 编译时异常（checked） | --- IOException | --- FileNotFoundException | --- ClassNotFoundException | --- 异常时异常（unchecked） | --- NullPointerException | --- ArrayIndexOutofBoundsException | --- ClassCastException | --- NumberFormatException | --- InputMismatchException | --- ArithmeticException 面试题：常见的异常都有哪些？举例说明 package com.atguigu.java; import java.io.File; import java.io.FileInputStream; import java.util.Date; import java.util.Scanner; import org.junit.Test; public class ExceptionTest { // **************** 以下是编译时异常 ********************** @Test public void test7() { File file = new File(\"hello.txt\"); FileInputStream fis = new FileInputStream(file); int data = fis.read(); while (data != -1) { System.out.println((char)data); data = fis.read(); } fis.close(); } // **************** 以下是运行时异常 ********************** // ArithmeticException @Test public void test6() { int a = 10; int b = 0; System.out.println(a / b); } // InputMismatchException @Test public void test5(){ Scanner scanner = new Scanner(System.in); int score = scanner.nextInt(); scanner.close(); } // NumberFormatException @Test public void test4() { String str = \"abc\"; int num = Integer.parseInt(str); } // ClassCastException @Test public void test3() { Object obj = new Date(); String str = (String)obj; System.out.println(str); } //ArrayIndexOutofBoundsException @Test public void test2() { // 举例1 // int[] arr = new int[10]; // System.out.println(arr[10]); // 举例2 String str = \"abc\"; System.out.println(str.charAt(3)); } // NullPointerException @Test public void test1() { // 举例1 // int[] arr = null; // System.out.println(arr[3]); // 举例2 String str = \"abc\"; str = null; System.out.println(str.charAt(0)); } } ","date":"2021-04-10","objectID":"/java-shk-6/:8:1","tags":["Java"],"title":"Java零基础教程（六.面向对象-重要补充）","uri":"/java-shk-6/"},{"categories":null,"content":"8.2 异常处理机制一: try-catch-finally 一·异常的处理：抓抛模型(转院比喻) 过程一：“抛”：程序在正常执行的过程中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象，并将此对象抛出。一旦抛出对象以后，其后的代码就不再执行。 关于异常对象的产生： 系统自动生成的异常对象 手动地生成一个异常对象，并抛出（throw）不同于throws 过程二：“抓”：可以理解为异常的处理方式： 1）try-catch-finally 2) throws 二·try-catch-finally的使用 try { // 可能出现异常的代码 } catch(异常类型1 变量名1) { // 处理异常的方式1 } catch(异常类型2 变量名2) { // 处理异常的方式2 } catch(异常类型3 变量名3) { // 处理异常的方式3 } ... finanlly { //一定会执行的代码 } 说明： finally是可选的. 使用try将可能出现异常代码包装起来，在执行过程中，一旦出现异常，就会出现一个对应异常类的对象， 根据此对象的类型，去catch中进行匹配。 一旦try中的异常对象匹配到某一个catch时，就进入catch中进行异常的处理。一旦处理完成，就跳出当前的 try-catch结构（在没有写finally的情况）。继续执行其后的代码 catch中的异常类型如果没有子父类关系，则谁声明在上，谁声明在下无所谓。 catch中的异常类型如果满足子父类关系，则要求子类一定声明在父类的上面，否则，编译报错 常用的异常对象处理的方式： 1）String getMessage() 2) printStackTrace() 在try结构中声明的变量，在出了try结构以后，就不能再被调用 try-catch-finally结构可以嵌套 体会1：使用try-catch-finally处理编译时异常，使得程序在编译时就不再报错，但是运行时仍可能报错。相当于我们使用try-catch-finally将一个编译时可能出现的异常，延迟到运行时出现。 体会2: 开发中，由于运行时异常比较常见，所以我们通常就不针对运行时异常编写try-catch-finally了。针对于编译时异常，我们说一定要考虑异常的处理。 package com.atguigu.java; import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.IOException; import org.junit.Test; public class ExceptionTest1 { @Test public void test2() { try { File file = new File(\"hello.txt\"); FileInputStream fis = new FileInputStream(file); int data = fis.read(); while (data != -1) { System.out.println((char)data); data = fis.read(); } fis.close(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } @Test public void test1() { String str = \"123\"; str = \"abc\"; try { int num = Integer.parseInt(str); System.out.println(\"hello --- 1\"); } catch (NumberFormatException e) { // System.out.println(\"出现数值转换异常了，不要着急\"); // String getMessage() System.out.println(e.getMessage()); // printStackTrace(); e.printStackTrace(); } catch (NullPointerException e) { System.out.println(\"出现空指针异常了，不要着急\"); } catch (Exception e) { System.out.println(\"出现异常了，不要着急\"); } System.out.println(\"hello --- 2\"); } } finally具体使用 try-catch-finally中finally的使用： finally是可选的 finally中声明的是一定会被执行的代码。即使catch中又出现异常了，try中有return语句，catch中有return语句等情况。 像数据库连接，输入输出流，网络编程Socket等资源，JVM是不能自动回收的，我们需要自己手动地进行资源的释放。此时的资源释放，就需要声明在finally中。 package com.atguigu.java; import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.IOException; import org.junit.Test; public class FinallyTest { @Test public void test2() { FileInputStream fis = null; try { File file = new File(\"hello.txt\"); fis = new FileInputStream(file); int data = fis.read(); while (data != -1) { System.out.println((char)data); data = fis.read(); } } catch (FileNotFoundException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } finally { try { if (fis != null) fis.close(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } @Test public void testMethod() { int num = method(); System.out.println(num); // output: // 我一定会被执行 // 3 } public int method() { try { int[] arr = new int[10]; System.out.println(arr[10]); return 1; } catch (ArrayIndexOutOfBoundsException e) { e.printStackTrace(); return 2; } finally { System.out.println(\"我一定会被执行\"); return 3; } } @Test public void test1() { try { int a = 10; int b = 0; System.out.println(a / b); } catch (ArithmeticException e) { // e.printStackTrace(); int[] arr = new int[10]; System.out.println(arr[10]); } catch (Exception e) { e.printStackTrace(); } // System.out.println(\"执行\"); finally { System.out.println(\"执行了finally\"); } } } ","date":"2021-04-10","objectID":"/java-shk-6/:8:2","tags":["Java"],"title":"Java零基础教程（六.面向对象-重要补充）","uri":"/java-shk-6/"},{"categories":null,"content":"8.3 异常处理机制二: throws 异常处理的方式二：throws + 异常类型 throws + 异常类型写在方法的声明处。指明此方法执行时，可能会抛出的异常类型。一旦当方法体执行时，出现异常，仍会在异常代码出生成一个异常类的对象，此对象满足throws后异常类型时，就会被抛出。异常代码后续的代码，就不再执行。 体会：try-catch-finally: 真正的将异常给处理掉了。throws的方式只是将异常抛给了方法的调用者。并没有真正将异常处理掉。(将病人转到上级医院) 开发中如何选择使用try-catch-finally 还是使用throws？ 如果父类中被重写的方法没有throws方式处理异常，则子类重写的方法也不能使用throws，意味着：如果子类重写的方法中有异常，必须使用try-catch-finally方式处理。 执行的方法a中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。我们建议这几个方法使用throws的方式进行处理。而执行的方法a可以考虑使用try-catch-finally进行处理。 package com.atguigu.java; import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.IOException; public class ExceptionTest2 { public static void main(String[] args) { try { method2(); } catch (IOException e) { e.printStackTrace(); } } public static void method3() { try { method2(); } catch (IOException e) { e.printStackTrace(); } } public static void method2() throws IOException { method1(); } public static void method1() throws FileNotFoundException, IOException { File file = new File(\"hello.txt\"); FileInputStream fis = new FileInputStream(file); int data = fis.read(); while (data != -1) { System.out.println((char)data); data = fis.read(); } fis.close(); } } package com.atguigu.java1; import java.io.FileNotFoundException; import java.io.IOException; /* * 子类重写的规则之一： * 子类重写的方法抛出的异常类型 */ public class OverrideTest { public static void main(String[] args) { OverrideTest test = new OverrideTest(); test.display(new SuperClass()); } public void display(SuperClass s) { try { s.method(); } catch (IOException e) { e.printStackTrace(); } } } class SuperClass { public void method() throws IOException { } } class SubClass extends SuperClass { public void method() throws FileNotFoundException { } } ","date":"2021-04-10","objectID":"/java-shk-6/:8:3","tags":["Java"],"title":"Java零基础教程（六.面向对象-重要补充）","uri":"/java-shk-6/"},{"categories":null,"content":"8.4 手动抛出异常: throw 关于异常对象的产生： 系统自动生成的异常对象 手动地生成一个异常对象，并抛出（throw）不同于throws package com.atguigu.java2; public class StudentTest { public static void main(String[] args) { try { Student s = new Student(); s.regist(1001); System.out.println(s); } catch (Exception e) { e.printStackTrace(); System.out.println(e.getMessage()); } } } class Student { private int id; public void regist(int id) throws Exception { if (id \u003e 0) { this.id = id; } else { // System.out.println(\"您输入的数据非法！\"); // 手动抛出异常对象,一般为Exception或RuntimeException // throw new RuntimeException(\"您输入的数据非法！\"); throw new Exception(\"您输入的数据非法！\"); } } } ","date":"2021-04-10","objectID":"/java-shk-6/:8:4","tags":["Java"],"title":"Java零基础教程（六.面向对象-重要补充）","uri":"/java-shk-6/"},{"categories":null,"content":"8.5 用户自定义异常类 如何自定义异常类？ 继承于现有结构的：RuntimeException, Exception 提供serialVersionUID 提供重载的构造器 package com.atguigu.java2; public class MyException extends RuntimeException { static final long serialVersionUID = -7034897190745766939L; public MyException() { } public MyException(String msg) { super(msg); } } 一道实践题 package com.atguigu.exer; /* * 编写应用程序EcmDef.java，接受命令行的两个参数，要求不能输入负数，计算两数相除。 * 对数据类型不一致（NumberFormatException），缺少命令行参数（ArrayIndexOutOfBoundsException）， * 除0（ArithmeticException）及输入负数（EcDef自定义的异常）进行异常处理。 * * 提示： * 1）在主类（EcmDef）中定义异常方法（ecm）完成两数相除功能， * 2）在main()方法中使用异常处理语句进行异常处理。 * 3）在程序中，自定义对应输入负数的异常类（EcDef）。 * 4）运行时接受参数java EcmDef 20 10 // args[0]=\"20\", args[1]=\"10\" * 5）Integer类的static方法parseInt(String s)将s转换为对应的int值。 */ public class EcmDef { public static void main(String[] args) { try { int i = Integer.parseInt(args[0]); int j = Integer.parseInt(args[1]); System.out.println(ecm(i, j)); } catch (NumberFormatException e) { System.out.println(\"数据类型不一致\"); } catch (ArrayIndexOutOfBoundsException e) { System.out.println(\"缺少命令行参数\"); } catch (ArithmeticException e) { System.out.println(\"除0\"); } catch (EcDef e) { System.out.println(e.getMessage()); } } public static int ecm(int i, int j) throws EcDef { if (i \u003c 0 || j \u003c 0) { throw new EcDef(\"分子或分母为负数了\"); } return i / j; } } class EcDef extends RuntimeException { static final long serialVersionUID = -7034897190745766939L; public EcDef() { } public EcDef(String msg) { super(msg); } } ","date":"2021-04-10","objectID":"/java-shk-6/:8:5","tags":["Java"],"title":"Java零基础教程（六.面向对象-重要补充）","uri":"/java-shk-6/"},{"categories":null,"content":"1. 多态性使用和理解 面向对象特征之三：多态性 理解多态性：可以理解为一个事物的多种形态。 何为多态性：对象的多态性，父类的引用指向子类的对象（或子类的对象赋给父类的引用） 多态的使用：虚拟方法调用 有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。 总结：编译看左边，运行看右边。 便于站在高处(more generalized)指挥，而不局限于实施细节 多态性的使用前提：1）类的继承关系 2）方法的重写 对象的多态性，只适用于方法，不适用于属性。子类不会覆盖父类的同名属性，而是内存都有，编译和运行都看左边。 虚拟方法调用：（Virtual Method Invocation） 子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚拟方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法确定的。 package com.atguigu.java4; public class PersonTest { public static void main(String[] args) { Person p1 = new Person(); p1.eat(); Man man = new Man(); man.eat(); man.earnMoney(); // ************************** // 对象的多态性：父类的引用指向子类的对象 Person p2 = new Man(); //Person p3 = new Woman(); // 多态的使用：当调用子父类同名同参数方法时，实际执行的是子类重写父类的方法 --- 虚拟方法调用 p2.eat(); p2.walk(); // wrong // p2.earnMoney() } } 多态性使用例子 package com.atguigu.java4; import java.sql.Connection; // 多态性使用 // 举例一 public class AnimalTest { public static void main(String[] args) { AnimalTest test = new AnimalTest(); test.func(new Dog()); test.func(new Cat()); } public void func(Animal animal) { animal.eat(); animal.shout(); } } class Animal { public void eat() { System.out.println(\"animal eat\"); } public void shout() { System.out.println(\"animal shout\"); } } class Dog extends Animal { public void eat() { System.out.println(\"dog eat\"); } public void shout() { System.out.println(\"dog shout\"); } } class Cat extends Animal { public void eat() { System.out.println(\"cat eat\"); } public void shout() { System.out.println(\"cat shout\"); } } // 举例二 class Order { public void method(Object obj) { } } // 举例三 class Driver { public void doData(Connection conn) { // conn = new MySqlConnection(); new // 规范的步骤去操作数据 // conn.method1(); // conn.method2(); // conn.method3(); } } 面试： Q：多态性是编译时行为还是运行时行为？ A：运行时行为 方法的重载与重写 二者的定义细节：略 从编译和运行的角度看： 重载，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。他们的调用地址在编译期就绑定了。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。所以：对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”； 而对于多态，只有等到方法调用的那一刻，届时运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”。 引用一句Bruce Eckel的话： \u003e “不要犯傻，如果它不是晚绑定，它就不是多态。” - Bruce Eckel package com.atguigu.java5; import java.util.Random; public class InterviewTest { public static void main(String[] args) { int key = new Random().nextInt(3); System.out.println(key); Animal animal = getInstance(key); animal.eat(); } public static Animal getInstance(int key) { switch (key) { case 0: return new Cat(); case 1: return new Dog(); default: return new Sheep(); } } } class Animal { protected void eat() { System.out.println(\"animal eat\"); } } class Cat extends Animal { protected void eat() { System.out.println(\"cat eat\"); } } class Dog extends Animal { protected void eat() { System.out.println(\"dog eat\"); } } class Sheep extends Animal { protected void eat() { System.out.println(\"sheep eat\"); } } 再来看一个例子 练习： 若子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里的同名方法，系统将不可能把父类里的方法转移到子类中。编译看左边，运行看右边 对于实例变量不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量：编译运行都看左边 package com.atguigu.java; public class FieldMethodTest { public static void main(String[] args) { Sub s = new Sub(); System.out.println(s.count);// 20 s.display(); //20 Base b = s;//多态性 // == 对于引用数据类型来讲，比较的是两个引用数据类型变量的地址值是否相同 System.out.println(b == s);// true System.out.println(b.count);//10 b.display(); //20 } } class Base { int count = 10; public void display() { System.out.println(this.count); } } class Sub extends Base { int count = 20; public void display() { System.out.println(this.count); } } ","date":"2021-04-06","objectID":"/java-shk-5/:1:0","tags":["Java"],"title":"Java零基础教程（五.面向对象-多态Polymorphism）","uri":"/java-shk-5/"},{"categories":null,"content":"2. 向下转型与instanceof关键字 ","date":"2021-04-06","objectID":"/java-shk-5/:2:0","tags":["Java"],"title":"Java零基础教程（五.面向对象-多态Polymorphism）","uri":"/java-shk-5/"},{"categories":null,"content":"2.1 向下转型 有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。 如何才能调用子类特有的属性和方法？使用强制类型转换符，向下转型 较高级的基本数据类型（double） ｜ ^ 强制类型转化 | ｜ 自动类型提升 v ｜ 较低级的基本数据类型（int） 父类（Person） ｜ ^ 向下转型 | ｜ 向上转型：多态 v ｜ 子类（Student） ","date":"2021-04-06","objectID":"/java-shk-5/:2:1","tags":["Java"],"title":"Java零基础教程（五.面向对象-多态Polymorphism）","uri":"/java-shk-5/"},{"categories":null,"content":"2.2 instanceof关键字使用 a instanceof A：判断对象a是否是类A的实例。如果是返回true，如果不是返回false。 使用情景：为了避免在向下转型时出现ClassCastException的异常，我们在向下转型之前，先进行instanceof的判断，一旦返回true，就进行向下转型。如果返回false，不进行向下转型。 如果a instanceof A返回true，则a instanceof B也返回true。其中类B是类A的父类。 package com.atguigu.java; public class PersonTest { public static void main(String[] args) { Person p1 = new Person(); p1.eat(); Man man = new Man(); man.eat(); man.earnMoney(); // ************************** // 对象的多态性：父类的引用指向子类的对象 Person p2 = new Man(); //Person p3 = new Woman(); // 多态的使用：当调用子父类同名同参数方法时，实际执行的是子类重写父类的方法 --- 虚拟方法调用 p2.eat(); p2.walk(); // wrong // p2.earnMoney() // ************************** // 不能调用子类所特有的方法，属性：编译时，p2是Person类型。 System.out.println(\"************************\"); Man m1 = (Man)p2; m1.earnMoney(); // 使用强转时，可能出现ClassCastException的异常 // Woman w1 = (Woman)p2; // w1.goShopping(); // 使用instanceof判断 if (p2 instanceof Woman) { Woman w1 = (Woman)p2; w1.goShopping(); } if (p2 instanceof Man) { m1 = (Man)p2; m1.earnMoney(); } // 练习： // 问题一： 编译时通过，运行时不通过 // 举例一： // Person p3 = new Woman(); // Man m3 = (Man)p3; // 举例二： // Person p4 = new Person(); // Man m4 = (Man)p4; // 问题二：编译通过，运行时也通过 Object obj = new Woman(); Person p = (Person)obj; // 问题三：编译不过 // Man m5 = new Woman(); } } ","date":"2021-04-06","objectID":"/java-shk-5/:2:2","tags":["Java"],"title":"Java零基础教程（五.面向对象-多态Polymorphism）","uri":"/java-shk-5/"},{"categories":null,"content":"3. Object类与equals(),toString()方法 ","date":"2021-04-06","objectID":"/java-shk-5/:3:0","tags":["Java"],"title":"Java零基础教程（五.面向对象-多态Polymorphism）","uri":"/java-shk-5/"},{"categories":null,"content":"3.1 Object类 java.lang.Object类 Object类是所有Java类的根父类 如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类 Object类中的功能(属性，方法)就具有通用性。 属性：无 方法：equals(), toString(), getClass(), hashCode(), clone(), finalize(), wait(), notify(), notifyAll() Object类只声明了一个空参构造器 面试题 final, finally, finalize的区别？ package com.atguigu.java1; public class ObjectTest { public static void main(String[] args) { Order order = new Order(); System.out.println(order.getClass().getSuperclass()); } } class Order { } ","date":"2021-04-06","objectID":"/java-shk-5/:3:1","tags":["Java"],"title":"Java零基础教程（五.面向对象-多态Polymorphism）","uri":"/java-shk-5/"},{"categories":null,"content":"3.2 equals()使用 面试题：==和equals()区别 一·回顾==的使用 运算符 可以使用在基本数据类型变量和引用数据类型变量中 如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等。（不一定类型要相同） 如果比较的是引用数据类型变量：比较两个对象的地址值是否相同，即两个引用是否指向同一个对象实体 补充：==符号使用时，必须保证符号左右两边的变量类型一致，否则编译报错。 二·equals()方法的使用： 是一个方法，而非运算符 只能适用于引用数据类型 Object类中equals()的定义： public boolean equals(Object obj) { return (this == obj); } 说明：Object类中定义的equals()和==的作用是相同的：比较两个对象地址值是否相同，即是否都指向同一个对象实体 像String, Date, File, 包装类等都重写了Object类中的equals()方法，重写以后，比较的不是两个引用地址是否相同，而是比较两个对象的“实体内容”是否相同。 通常情况下，我们自定义的类如果使用equals()的话，也通常是比较两个对象的“实体内容”是否相同。那么，我们就需要对Object类中的equals()进行重写，重写的原则：比较两个对象的实体内容是否相同。 package com.atguigu.java1; public class EqualsTest { public static void main(String[] args) { int i = 10; int j = 10; double d = 10.0; System.out.println(i == j);// true System.out.println(i == d);// true char c = 10; System.out.println(i == c);// true char c1 = 'A'; char c2 = 65; System.out.println(c1 == c2);// true String str1 = new String(\"atguigu\"); String str2 = new String(\"atguigu\"); System.out.println(str1 == str2);// false System.out.println(str1.equals(str2));// true } } ","date":"2021-04-06","objectID":"/java-shk-5/:3:2","tags":["Java"],"title":"Java零基础教程（五.面向对象-多态Polymorphism）","uri":"/java-shk-5/"},{"categories":null,"content":"3.3 toString()使用 Object类中toString()的使用 当我们输出一个对象的引用时，实际上就是调用当前对象的toString() Object类中toString()的定义 public String toString() { return getClass().getName() + \"@\" + Integer.toHexString(hashCode()); } 像String, Date, File, 包装类等都重写了Object类中的toString()方法。使得在调用对象的toString()时，返回“实体内容”信息 自定义类也可以重写toString()方法，当调用此方法时，返回对象的“实体内容”。 ","date":"2021-04-06","objectID":"/java-shk-5/:3:3","tags":["Java"],"title":"Java零基础教程（五.面向对象-多态Polymorphism）","uri":"/java-shk-5/"},{"categories":null,"content":"4. 包装类，基本数据类型，String三者间的转换 包装类的使用 Java提供了8种基本数据类型对应的包装类，使得基本数据类型的变量具有类的特征 掌握的：基本数据类型，包装类，String三者间的相互转换 基本数据类型 -\u003e 包装类：调用包装类的构造器, 基本数据类型无法利用多态 包装类 -\u003e 基本数据类型：调用包装类的xxxValue，包装类不能加减乘除 JDK 5.0新特性：自动装箱与自动拆箱 * 基本数据类型，包装类 -\u003e String类型: String.valueOf() * String类型 -\u003e 基本数据类型，包装类: 调用包装类的parseXxx() package com.atguigu.java2; public class WrapperTest { public static void main(String[] args) { int num1 = 10; Integer in1 = new Integer(num1); System.out.println(in1.toString()); Integer in2 = new Integer(\"123\"); System.out.println(in2.toString()); Float f1 = new Float(12.3f); Float f2 = new Float(\"12.3\"); System.out.println(f1); System.out.println(f2); Boolean b1 = new Boolean(true); Boolean b2 = new Boolean(\"true\"); Boolean b3 = new Boolean(\"TrUe\"); System.out.println(b3); // true int i1 = in1.intValue(); float f3 = f1.floatValue(); System.out.println(i1); System.out.println(f3); //自动装箱 int num2 = 10; Integer in3 = num2;// 自动装箱 System.out.println(in3); int num3 = in3;// 自动拆箱 // 基本数据类型，包装类 -\u003e String类型：调用String重载的valueOf(Xxx xxx) int n1 = 10; // 方式1: 连接运算 String str1 = n1 + \"\"; // 方式2: 调用String的valueOf String s1 = String.valueOf(n1); // \"10\" String s2 = String.valueOf(new Double(12.4)); // \"12.4\" System.out.println(s1 + ',' + s2); int x = Integer.parseInt(\"123\"); boolean b = Boolean.parseBoolean(\"true\"); System.out.println(x); System.out.println(b); } } 一道考题 package com.atguigu.java2; public class InterviewTest { public static void main(String[] args) { } public void test1() { Object o1 = true ? new Integer(1) : new Double(2.0); System.out.println(o1); //1.0, 编译三元标识符，自动类型提升为Double，多态toString } public void test2() { Object o2; if (true) o2 = new Integer(1); else o2 = new Double(2.0); System.out.println(o2); // 1, 不需要自动类型提升 } public void test3() { Integer i = new Integer(1); Integer j = new Integer(1); System.out.println(i == j); // false // Integer内部定义了IntegerCache结构，IntegerCache中定义了Integer[], // 保存了-128～127范围的整数。如果我们使用自动装箱的方式，给Integer赋值的范围在 // -128～127范围内时，可以直接使用数组中的元素，不用再new了。目的：提高效率 Integer m = 1; Integer n = 1; System.out.println(m == n); // true Integer x = 128; // 相当于new了一个Integer对象 Integer y = 128; // 相当于又new了一个Integer对象 System.out.println(x == y); // false } } 体会包装类的引入意义 package com.atguigu.java2; import java.util.Scanner; import java.util.Vector; public class ScoreTest { public static void main(String[] args) { // 1. 实例化Scanner，用于从键盘获取学生成绩 Scanner scan = new Scanner(System.in); // 2. 创建Vector对象 Vector v = new Vector(); // 3. 给Vector中添加元素 int maxScore = 0; while (true) { System.out.println(\"input Student's score (negative number to end)\"); int score = scan.nextInt(); if (score \u003c 0) break; // before jdk5.0 // Integer el = new Integer(score); // v.addElement(el); // 多态 // after jdk5.0 v.addElement(score); // 自动装箱 // 4. 获取成绩最大值 if (score \u003e maxScore) maxScore = score; } // 5. 遍历Vector，得到每个学生成绩，并与最大值比较，得到等级 char level; for (int i = 0; i \u003c v.size(); i++) { Object obj = v.elementAt(i); // before jdk5.0 // Integer el = (Integer)obj; // int score = el.intValue(); // after jdk5.0 int score = (int)obj; if (maxScore - score \u003c= 10) { level = 'A'; } else if (maxScore - score \u003c= 20) { level = 'B'; } else if (maxScore - score \u003c= 30) { level = 'C'; } else { level = 'D'; } System.out.println(\"student score: \" + score + \", grade: \" + level); } } } ","date":"2021-04-06","objectID":"/java-shk-5/:4:0","tags":["Java"],"title":"Java零基础教程（五.面向对象-多态Polymorphism）","uri":"/java-shk-5/"},{"categories":null,"content":"1. 继承性的使用 面向对象的特征之二：继承性 一·继承性的好处 why？ 减少了代码的冗余，提高了代码的复用性 便于功能的扩展 为之后多态性的使用，提供了前提 二·继承性的格式：class A extends B{} A: 子类，派生类，subclass B: 父类，超类，基类，superclass 体现：一旦子类A继承父类B以后，子类A中就获取了父类B中声明的所有的结构：属性，方法。 特别地，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私有的结构。 只是因为封装性的影响，使得子类不能直接调用父类的结构而已。权限修饰符解决的是调用的问题。继承性解决的是能不能获取的问题。 子类继承父类以后，还可以声明自己特有的属性或方法，实现功能的扩展。 子类和父类的关系，不同于子集和集合的关系。 extends：扩展 三·Java中关于继承性的规定 一个类可以被多个子类继承 Java中类的单继承性：一个类只能有一个父类 子父类是相对的概念。 子类直接继承的父类，称为直接父类。间接继承的父类，称为间接父类。 子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法。 四· Object类 如果我们没有显式地声明一个类的父类的话，则此类继承于java.lang.Object类 所有的java类（除java.lang.Object类之外）都直接或间接的继承于java.lang.Object类 意味着，所有的java类具有java.lang.Object类声明的功能。 package com.atguigu.java; public class ExtendsTest { public static void main(String[] args) { Person p1 = new Person(); p1.setAge(1); Student s1 = new Student(); s1.eat(); s1.sleep(); } } 实例化过程 子类对象实例化的全过程 从结果上来看：（继承性） 子类继承父类以后，就获取了父类中声明的属性或方法。创建子类的对象，在堆空间中，就会加载所有父类中声明的属性。 从过程上来看： 当我们通过子类的构造器创建子类对象时，我们一定会直接或间接地调用其父类的构造器，进而调用父类的父类的构造器，直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所有的父类的结构，所以才可以看到内存中有父类中的结构，子类对象才可以考虑进行调用。 明确：虽然创建子类对象时，调用了父类的构造器，但是自始自终就创建过一个对象，即为new的子类对象。 ","date":"2021-04-04","objectID":"/java-shk-4/:1:0","tags":["Java"],"title":"Java零基础教程（四.面向对象-继承inheritance）","uri":"/java-shk-4/"},{"categories":null,"content":"2. 在子类中重写方法 ","date":"2021-04-04","objectID":"/java-shk-4/:2:0","tags":["Java"],"title":"Java零基础教程（四.面向对象-继承inheritance）","uri":"/java-shk-4/"},{"categories":null,"content":"2.1 方法重写的规定 方法的重写(override / overwrite) 重写：子类继承父类以后，可以对父类中同名同参的方法，进行覆盖操作 应用：重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参的方法时，实际执行的是子类重写父类的方法。 面试题：区分方法的重载与重写 重写的规定： 方法的声明： 权限修饰符 返回值类型 方法名(形参列表) throws 异常类型 {方法体} 约定俗成：子类中的叫重写的方法，父类中的叫被重写的方法 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同。 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符(类比：摊煎饼覆盖) cannot reduce the visibility of the inherited method from the superclass 特殊情况：子类不能重写父类中声明为private权限的方法，可以理解为子类重新写了一个方法 太小了，覆盖不了 https://stackoverflow.com/a/39072326 返回值类型： 父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void 父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或者A类的子类 父类被重写的方法的返回值类型是基本数据类型，则子类重写的方法的返回值类型必须是相同的基本数据类型 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型。（具体放到异常处理时候讲） 子类和父类中的同名同参数的方法要么都声明为非static的（考虑重写），要么都声明为static的（不是重写） 注意下面s.walk()的调用 package com.atguigu.java1; public class PersonTest { public static void main(String[] args) { Student s = new Student(\"CS\"); s.eat();// student eat s.walk(10); // person walk, person show, student eat // https://stackoverflow.com/a/6896598 } } /* class Person { String name; int age; public Person() { super(); } public Person(String name, int age) { super(); this.name = name; this.age = age; } public void eat() { System.out.println(\"person eat\"); } public void walk(int distance) { System.out.println(\"person walk \" + distance + \"km\"); show(); eat(); } private void show() { System.out.println(\"person show\"); } public Object info() { return null; } } class Student extends Person { String major; public Student() { super(); } public Student(String major) { this.major = major; } public void study() { System.out.println(\"major is \" + major); } public void eat() { System.out.println(\"student eat\"); } public void show() { System.out.println(\"student show\"); } public String info() { return null; } } */ ","date":"2021-04-04","objectID":"/java-shk-4/:2:1","tags":["Java"],"title":"Java零基础教程（四.面向对象-继承inheritance）","uri":"/java-shk-4/"},{"categories":null,"content":"2.2 再回顾：权限修饰符 private只能自己访问, default可以跨类（同包下）, protected子类可以访问（可以跨包）, public都可以访问。 ","date":"2021-04-04","objectID":"/java-shk-4/:2:2","tags":["Java"],"title":"Java零基础教程（四.面向对象-继承inheritance）","uri":"/java-shk-4/"},{"categories":null,"content":"2.3 super关键字 super关键字的使用 super理解为：父类的 super可以用来调用: 属性，方法，构造器 super的使用 我们可以在子类的方法或构造器中。通过使用“super.属性”或“super.方法”的方式，显式地调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略“super.” 特殊情况：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式地使用“super.属性”的方式，表明调用的是父类中声明的属性。 特殊情况：当子类重写了父类中的方法以后，我们要想在子类中调用父类中声明的方法时，则必须显式地 使用“super.方法”的方式，表明调用的是父类中声明的方法。 super调用构造器 我们可以在子类的构造器中显式地使用“super(形参列表)”的方式，调用父类中声明的指定构造器 “super(形参列表)”的使用，必须声明在子类构造器的首行。 我们在类的构造器中，针对于“this(形参列表)”或“super(形参列表)”只能二选一，不能同时出现 在构造器首行，没有显式地声明“this(形参列表)”或“super(形参列表)”，则默认调用的是父类中空参构造器 在类的多个构造器中，至少有一个类的构造器中使用了“super(形参列表)”，调用父类中的构造器 package com.atguigu.java3; public class SuperTest { public static void main(String[] args) { Student s = new Student(); s.study();// student study, student eat, person eat } } /* public class Person { String name; int age; int id;// 身份证 public Person() { } public Person(String name) { this.name = name; } public Person(String name, int age) { this(name); this.age = age; } public void eat() { System.out.println(\"person eat\"); } public void walk() { System.out.println(\"person walk\"); } } package com.atguigu.java3; public class Student extends Person { String major; int id;//学号 public Student() { } public Student(String major) { this.major = major; } public void eat() { System.out.println(\"student eat\"); } public void study() { System.out.println(\"student study\"); this.eat(); super.eat(); } } */ ","date":"2021-04-04","objectID":"/java-shk-4/:2:3","tags":["Java"],"title":"Java零基础教程（四.面向对象-继承inheritance）","uri":"/java-shk-4/"},{"categories":null,"content":"1. 类和对象 ","date":"2021-04-03","objectID":"/java-shk-3/:1:0","tags":["Java"],"title":"Java零基础教程（三.面向对象-封装Encapsulation）","uri":"/java-shk-3/"},{"categories":null,"content":"1.1 面向对象的思想 一· Java面向对象学习的三条主线 Java类及类的成员：属性，方法，构造器，代码块，内部类 面向对象的三大特征：封装性，继承性，多态性，（抽象性） 其他关键字：this, super, static, final, abstract, interface, package, import等。 二·“人把大象装进冰箱” 面向对象：强调的是功能行为，以函数为最小单位，考虑怎么做。 把冰箱门打开 抬起大象，塞进冰箱 把冰箱门关闭 面向对象：强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。 人 { 打开(冰箱) { 冰箱.开开(); } 抬起(大象) { 大象.进入(冰箱); } 关闭(冰箱) { 冰箱.闭合(); } } 冰箱 { 开开(){} 闭合(){} } 大象 { 进入(冰箱){} } 程序员从面向过程的执行者转化成了面向对象的指挥者。 三·面向对象的两个要素 类：对一类事物的描述，是抽象的，概念上的定义 对象：是实际存在的该类事物的每个个体，因而也称为实例（instance） 面向对象程序设计的重点是类的设计 设计类，就是设计类的成员 ","date":"2021-04-03","objectID":"/java-shk-3/:1:1","tags":["Java"],"title":"Java零基础教程（三.面向对象-封装Encapsulation）","uri":"/java-shk-3/"},{"categories":null,"content":"1.2 类的属性和方法 一·设计类，其实就是设计类的成员 属性 = 成员变量 = field 方法 = 成员方法 = 函数 = method 创建类的对象 = 类的实例化 二·类和对象的使用（面向对象思想落地） 创建类，设计类的成员 创建类的对象 通过“对象.属性”或“对象.方法”调用对象的结构 三·如果创建了一个类的多个对象，则每个对象都独立的拥有一套类的属性（非static） 意味着：如果我们修改一个对象的属性a，则不影响另外一个对象属性a的值。 package com.atguigu.java; // 测试类 public class PersonTest { public static void main(String[] args) { // TODO Auto-generated method stub // 2. 创建Person类的对象 Person p1 = new Person(); // Scanner scanner = new Scanner(System.in); // 调用对象的结构：属性，方法 // 调用属性： “对象.属性” p1.name = \"Tom\"; p1.isMale = true; System.out.println(p1.name); // 调用方法：“对象.方法” p1.eat(); p1.sleep(); p1.talk(\"Chinese\"); // ******************************** Person p2 = new Person(); System.out.println(p2.name);// null System.out.println(p2.isMale);// false // ******************************** // 将p1变量保存的对象地址值赋给p3，导致p1和p3指向了堆空间的同一个对象实体 Person p3 = p1; System.out.println(p3.name);//Tom p3.age = 10; System.out.println(p1.age);//10 } } // 1. 创建类 class Person { // 属性 String name; int age; boolean isMale; // 方法 public void eat() { System.out.println(\"人可以吃饭\"); } public void sleep() { System.out.println(\"人可以睡觉\"); } public void talk(String language) { System.out.println(\"人可以说话，使用的是： \" + language); } } ","date":"2021-04-03","objectID":"/java-shk-3/:1:2","tags":["Java"],"title":"Java零基础教程（三.面向对象-封装Encapsulation）","uri":"/java-shk-3/"},{"categories":null,"content":"1.3 属性 vs. 局部变量 类中属性的使用 属性 vs 局部变量 相同点： 定义变量的格式：数据类型 变量名 = 变量值 先声明，后使用 变量都有其对应的作用域 不同点： 在类中声明位置的不同 属性：直接定义在类的一对{} 局部变量：声明在方法内，方法形参，代码块内，构造器形参，构造器内部的变量 关于权限修饰符的不同 属性：可以在声明属性时，指明其权限，使用权限修饰符。常用的权限修饰符：private, public, 缺省, protected —\u003e 封装性。（目前，大家声明属性时，都是用缺省就可以了。） 局部变量：不可以使用权限修饰符。 默认初始化的情况： 属性：类的属性，根据其类型，都有默认初始化值。 整型(byte, short, int, long) 0 浮点型(float, double) 0.0 字符型(char), 0 或 '\\u0000' boolean: false 引用数据类型(类，数组，接口) null 局部变量：没有默认初始化值。意味着，我们在调用局部变量之前，一定要显式赋值。特别地：形参在调用时，我们再赋值即可。 在内存中家在的位置不同： 属性：加载到堆空间中（非static） 局部变量：加载到栈空间 package com.atguigu.java; public class UserTest { public static void main(String[] args) { // TODO Auto-generated method stub User u1 = new User(); System.out.println(u1.name); System.out.println(u1.age); System.out.println(u1.isMale); } } class User { // 属性 String name; public int age; boolean isMale; public void talk(String language) {// language: 形参，也是局部变量 System.out.println(\"我们使用\" + language + \"进行交流\"); } public void eat() { String food = \"烙饼\";// 局部变量，不赋值会报错 System.out.println(\"北方人喜欢吃: \" + food); } } ","date":"2021-04-03","objectID":"/java-shk-3/:1:3","tags":["Java"],"title":"Java零基础教程（三.面向对象-封装Encapsulation）","uri":"/java-shk-3/"},{"categories":null,"content":"1.4 类方法的声明和使用 类中方法的声明和使用 方法：描述类应该具有的功能 比如：Math类: sqrt() random()；Scanner类: nextXxx()；Arrays类: sort(), binarySearch(), toString(), equals() 举例： public void eat(){} public void sleep(int hour){} public String getName(){} public String getNation(String nation){} 方法的声明： 权限修饰符 返回值类型 方法名(形参列表) { 方法体 } static, final, abstract 来修饰的方法，后面再讲 说明： 关于权限修饰符：默认方法的权限修饰符先都使用public Java规定的4种权限修饰符：private, public, 缺省, protected —\u003e 封装性细说 返回值类型：有返回值 vs 没有返回值 如果方法有返回值，则必须在方法声明时，指定返回值的类型。同时方法中，需要使用return关键字类返回指定类型的变量或常量：“return 数据”。 如果方法没有返回值，则方法声明时，使用void来表示。通常，没有返回值的方法中，就不需要return。 但是如果使用的话，只能return;表示结束此方法的意思。 我们定义方法该不该有返回值？题目要求,凭经验：具体问题具体分析 方法名：属于标识符，遵循标识符的规则和规范，“见名知意” 形参列表： 方法可以声明0个，1个，或多个形参。 格式：数据类型1 形参1, 数据类型2 形参2, ... 我们定义方法时，该不该定义形参？题目要求,凭经验：具体问题具体分析 方法体：方法功能的体现 return关键字的使用： 使用范围：使用在方法体中 作用： 结束方法 针对于有返回值类型的方法，使用return 数据方法返回所要的数据。 注意点：return关键字后面不可以声明执行语句。 方法的使用中，可以调用当前类的属性或方法 特殊的：方法A中有调用了方法A：递归方法。 方法中不可以定义方法 class Customer { String name; int age; boolean isMale; public void eat() { System.out.println(\"客户吃饭\"); } public void sleep(int hour) { System.out.println(\"休息了\" + hour + \"个小时\"); } public String getName() { return name; } public String getNation(String nation) { String info = \"我的国籍是：\" + nation; return info; } } ","date":"2021-04-03","objectID":"/java-shk-3/:1:4","tags":["Java"],"title":"Java零基础教程（三.面向对象-封装Encapsulation）","uri":"/java-shk-3/"},{"categories":null,"content":"1.5 匿名对象 匿名对象的使用 理解： 我们创建的对象，没有显式地赋给一个变量名，即为匿名对象。 特征：匿名对象只能调用一次。 使用：如下 package com.atguigu.java; public class InstanceTest { public static void main(String[] args) { new Phone().price = 1999; new Phone().showPrice(); PhoneFactory pf = new PhoneFactory(); // 匿名对象的使用 pf.show(new Phone()); } } class PhoneFactory { public void show(Phone phone) { phone.showPrice(); } } class Phone { double price; public void showPrice() { System.out.println(\"价格为：\" + price); } } ","date":"2021-04-03","objectID":"/java-shk-3/:1:5","tags":["Java"],"title":"Java零基础教程（三.面向对象-封装Encapsulation）","uri":"/java-shk-3/"},{"categories":null,"content":"1.6 方法的重载 方法的重载（overload）loading… 定义：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。 “两同一不同”：同一个类，相同方法名；参数列表不同（参数个数不同或参数类型不同） 举例: Arrays类中重载的sort() / binarySearch() 判断是否是重载? 跟方法的权限修饰符，返回值类型，形参变量名，方法体没有关系。 在通过对象调用方法时，如何确定某一个指定的方法：方法名 -\u003e 参数列表 package com.atguigu.java1; public class OverLoadTest { // 如下的4个方法构成了重载 public void getSum(int i, int j) { System.out.println(\"1\"); } public void getSum(double d1, double d2) { System.out.println(\"2\"); } public void getSum(String s, int i) { System.out.println(\"3\"); } public void getSum(int i, String s) { System.out.println(\"4\"); } // 下面的都不算重载 // public int getSum(int i, int j) { // // } // public void getSum(int m, int n) { // // } // private void getSum(int i, int j) { // // } } ","date":"2021-04-03","objectID":"/java-shk-3/:1:6","tags":["Java"],"title":"Java零基础教程（三.面向对象-封装Encapsulation）","uri":"/java-shk-3/"},{"categories":null,"content":"1.7 可变个数形参 可变个数形参的方法 jdk 5.0 新增的内容 具体使用： 可变个数形参的格式： 数据类型 ... 变量名 当调用可变个数形参的方法时，传入参数的个数可以是0，1，2… 可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载 可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。换句话说，二者不能共存 可变个数形参在方法的形参中，必须声明在末尾 可变个数形参在方法的形参中，最多只能声明一个可变形参。 package com.atguigu.java1; public class MethodArgsTest { public static void main(String[] args) { MethodArgsTest test = new MethodArgsTest(); test.show(12);//1 test.show(\"hello\");//2 test.show(\"hello\", \"world\");//3 test.show();//3 } public void show(int i) { System.out.println(\"1\"); } public void show(String s) { System.out.println(\"2\"); } public void show(String ... strs) { System.out.println(\"3\"); } // public void show(String[] strs) { // // } } ","date":"2021-04-03","objectID":"/java-shk-3/:1:7","tags":["Java"],"title":"Java零基础教程（三.面向对象-封装Encapsulation）","uri":"/java-shk-3/"},{"categories":null,"content":"1.8 方法的值传递机制 方法的形参的值传递机制：值传递 形参：方法定义时，声明的小括号内的参数 实参：方法调用时，实际传递给形参的数据 值传递机制： 如果参数是基本数据类型，此时赋值的是变量所保存的数据值。 如果参数是引用数据类型，此时赋值的是变量所保存的数据的地址值。 package com.atguigu.java1; public class ValueTransferTest1 { public static void main(String[] args) { int m = 10; int n = 20; // 交换两个变量的值 int tmp = m; m = n; n = tmp; System.out.println(\"m = \" + m + \", n = \" + n); ValueTransferTest1 test = new ValueTransferTest1(); m = 10; n = 20; test.swap(m, n); System.out.println(\"m = \" + m + \", n = \" + n); System.out.println(\"**************************\"); Data data = new Data(); data.m = 10; data.n = 20; test.swap(data); System.out.println(\"m = \" + data.m + \", n = \" + data.n); } public void swap(int m, int n) { int tmp = m; m = n; n = tmp; } public void swap(Data data) { int tmp = data.m; data.m = data.n; data.n = tmp; } } class Data { int m; int n; } ","date":"2021-04-03","objectID":"/java-shk-3/:1:8","tags":["Java"],"title":"Java零基础教程（三.面向对象-封装Encapsulation）","uri":"/java-shk-3/"},{"categories":null,"content":"2. 面向对象特征之一：封装与隐藏 为什么需要封装？封装的作用和含义？ 我要用洗衣机，只需要按一下开关和洗涤模式就可以了。有必要了解洗衣机内部的结构吗？有必要碰电动机吗？ 我要开车，… 我们程序设计追求“高内聚，低耦合”。 高内聚：类的内部数据操作细节自己完成，不允许外部干涉； 低耦合：仅对外暴露少量的方法用于使用。 面向对象的特征一：封装与隐藏 一·问题的引入 当我们创建一个类的对象以后，我们可以通过“对象.属性”的方式，对对象的属性进行赋值。这里赋值操作要受到属性的数据类型和存储范围的制约。除此之外，没有其他制约条件。但是，在实际问题中，我们往往需要给属性赋值加入额外的限制条件。这个条件就不能在属性声明时体现，我们只能通过方法进行限制条件的添加。（比如：set）同时，我们需要避免用户再使用“对象.属性”的方式对属性进行赋值。则需要将属性声明为私有的（private） ---\u003e 此时，针对于属性就体现了封装性。 二·封装性的体现： 我们将类的属性私有化（private），同时，提供公共的（public）方法来获取（getXxx）和设置（setXxx）此属性的值 拓展：封装性的体现：1）如上 2） 不对外暴露的私有的方法 3） 单例模式 三·封装性的体现，需要权限修饰符来配合。 Java规定的4种权限：（从小到大）private, 缺省, protected, public 四种权限可以用来修饰类及类的内部结构：属性，方法，构造器，内部类 具体地， 四种权限都可以用来修饰类的内部结构：属性，方法，构造器，内部类 修饰类的话，只能使用：缺省，public 总结封装性：Java提供了4种权限修饰符来修饰类及类的内部结构，体现类及类的内部结构在被调用时的可见性大小 package com.atguigu.java; public class AnimalTest { public static void main(String[] args) { Animal a = new Animal(); a.name = \"大黄\"; a.age = 1; // a.legs = 4; a.show(); a.setLegs(4); a.show(); } } class Animal { String name; int age; private int legs; public void eat() { System.out.println(\"动物进食\"); } public void show() { System.out.println(\"name = \" + name + \", age = \" + age + \", legs = \" + legs); } public void setLegs(int l) { if (l \u003e= 0 \u0026\u0026 l % 2 == 0) { legs = l; } else { legs = 0; // 抛出异常 } legs = l; } public int getLegs() { return legs; } } 修饰符 类内部 同一个包 不同包的子类 同一个工程 private yes （缺省） yes yes protected yes yes yes public yes yes yes yes ","date":"2021-04-03","objectID":"/java-shk-3/:2:0","tags":["Java"],"title":"Java零基础教程（三.面向对象-封装Encapsulation）","uri":"/java-shk-3/"},{"categories":null,"content":"3. 构造器 ","date":"2021-04-03","objectID":"/java-shk-3/:3:0","tags":["Java"],"title":"Java零基础教程（三.面向对象-封装Encapsulation）","uri":"/java-shk-3/"},{"categories":null,"content":"3.1 构造器的使用 类的结构之三：构造器（或构造方法，constructor）的使用 一·构造器的作用： 创建对象 初始化对象的的信息 二·说明： 如果没有显式的定义类的构造器的话，则系统默认提供一个空参的构造器。 定义构造器的格式：权限修饰符 类名(形参列表){} 一个类中定义的多个构造器，彼此构成重载 一旦我们显式的定义了类的一个构造器之后，系统就不再提供默认的空参构造器。 一个类中，至少会有一个构造器。 package com.atguigu.java1; public class PersonTest { public static void main(String[] args) { // 创建类的对象: new + 构造器 Person p = new Person(); p.eat(); Person p1 = new Person(\"Tom\"); System.out.println(p1.name); } } class Person { // 属性 String name; int age; // 构造器 public Person() { System.out.println(\"constructing object\"); } public Person(String n) { name = n; } // 方法 public void eat() { System.out.println(\"人吃饭\"); } } ","date":"2021-04-03","objectID":"/java-shk-3/:3:1","tags":["Java"],"title":"Java零基础教程（三.面向对象-封装Encapsulation）","uri":"/java-shk-3/"},{"categories":null,"content":"3.2 属性赋值的先后顺序 总结：属性赋值的先后顺序 默认初始化值 显式初始化 构造器中赋值 通过“对象.方法” 或 “对象.属性”的方式赋值 以上操作的先后顺序：1 - 2 - 3 - 4 package com.atguigu.java1; public class UserTest { } class User { String name; int age = 1; public User() { } public User(int a) { age = a; } } ","date":"2021-04-03","objectID":"/java-shk-3/:3:2","tags":["Java"],"title":"Java零基础教程（三.面向对象-封装Encapsulation）","uri":"/java-shk-3/"},{"categories":null,"content":"3.3 JavaBean JavaBean 是一种Java语言写成的可重用组建。 所谓JavaBean，是指符合如下标准的Java类： 类是公共的 有一个无参的公共构造器 有属性，且有对应的get，set方法 package com.atguigu.java1; public class Customer { private int id; private String name; public Customer() { } public void setId(int i) { id = i; } public int getId() { return id; } public void setName(String n) { name = n; } public String getName() { return name; } } ","date":"2021-04-03","objectID":"/java-shk-3/:3:3","tags":["Java"],"title":"Java零基础教程（三.面向对象-封装Encapsulation）","uri":"/java-shk-3/"},{"categories":null,"content":"4 关键字 ","date":"2021-04-03","objectID":"/java-shk-3/:4:0","tags":["Java"],"title":"Java零基础教程（三.面向对象-封装Encapsulation）","uri":"/java-shk-3/"},{"categories":null,"content":"4.1 this关键字 this 关键字的使用 this可以用来修饰,调用：属性，方法，构造器 this修饰属性和方法： this理解为当前对象 或 当前正在创建的对象 在类的方法中，我们可以使用this.属性或this.方法的方式，调用当前对象的属性和方法。但是通常情况下，我们都选择省略this.。特殊情况下，如果方法的形参和类的属性同名时，我们必须显式地使用this.变量的方式，表明此变量是属性，而非形参。 在类的构造器中，我们可以使用this.属性或this.方法的方式，调用当前正在创建的对象属性和方法。但是通常情况下，我们都选择省略this.。特殊情况下，如果构造器的形参和类的属性同名时，我们必须显式地使用this.变量的方式，表明此变量是属性，而非形参。 this调用构造器 我们在类的构造器中，可以显式的使用this(形参列表)方式，调用本类中指定的其他构造器。 构造器中不能通过this(形参列表)方式调用自己。 如果一个类中有n个构造器，则最多有n-1构造器中使用了“this(形参列表)” 规定：this(形参列表)必须声明在当前构造器的首行 构造器内部，最多只能声明一个this(形参列表)，用来调用其他的构造器 package com.atguigu.java2; public class PersonTest { public static void main(String[] args) { Person p1 = new Person(); p1.setAge(1); System.out.println(p1.getAge()); } } class Person { private String name; private int age; public Person() { this.eat(); String info = \"Person初始化时，需要考虑如下的1，2，3，4，... (共40行代码)\"; System.out.println(info); } public Person(int age) { this(); this.age = age; } public Person(String name) { this(); this.name = name; } public Person(String name, int age) { this(age); this.name = name; // this.age = age; } public void setName(String name) { this.name = name; } public String getName() { return name; } public void setAge(int age) { this.age = age; } public int getAge() { return age; } public void eat() { System.out.println(\"人吃饭\"); this.study(); } public void study() { System.out.println(\"人学习\"); } } ","date":"2021-04-03","objectID":"/java-shk-3/:4:1","tags":["Java"],"title":"Java零基础教程（三.面向对象-封装Encapsulation）","uri":"/java-shk-3/"},{"categories":null,"content":"4.2 package和import关键字 一·package关键字的作用（类似班级的概念） 为了更好地实现项目中类的管理，提供包的概念。 使用package声明类或接口所属的包，声明在源文件的首行 包，属于标识符，遵循标识符的命名规则，规范(xxxyyyzzz)，“见名知意” 每“.”一次，就代表一层文件目录 补充 * 同一个包下，不能命名同名的接口，类。 * 不同的包下，可以命名同名的接口，类。 二·import关键字的使用 在源文件中显式的使用import结构导入指定包下的类，接口。 声明在包的声明和类的声明之间 如果需要导入多个结构，则并列写出即可 可以使用“xxx.*”的方式，表示可以导入xxx包下的所有结构。 如果使用的类或接口是java.lang包下定义的，则可以省略import结构 如果使用的类或接口是本包下定义的，则可以省略import接口。 如果在源文件中，使用了不同包下的同名类，则必须至少有一个类需要以全类名的方式显式 使用“xxx.*”方式表明可以调用xxx包下的所有结构。但是如果使用的是xxx子包下的结构，则仍需要显式import import static: 导入指定类或接口[中]的静态结构：属性或方法。 package com.atguigu.java2; import java.util.Date; import static java.lang.System.*; public class PackageImportTest { public static void main(String[] args) { Date date = new Date(); // 全类名 java.sql.Date date1 = new java.sql.Date(0); out.println(\"hello\"); } } ","date":"2021-04-03","objectID":"/java-shk-3/:4:2","tags":["Java"],"title":"Java零基础教程（三.面向对象-封装Encapsulation）","uri":"/java-shk-3/"},{"categories":null,"content":"1. 关键字 数据类型：class, interface, enum, byte, short, int, long, float, double, char, boolean, void 数值：true, false, null 流程控制：if, else, switch, case, default, while, do, for, break, continue, return 访问权限：private, protected, public 类，函数，变量的修饰符：abstract, final, static, synchronized 类与类关系：extends, implements 实例的创建，引用，判断：new, this, super, instanceof 异常处理：try, catch, finally, throw, throws 包：package, import 其他：native, strictfp, transient, volatile, assert ","date":"2021-03-10","objectID":"/java-shk-2/:1:0","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"2. 标识符 标识符（aka变量方法类名）的命名规范： 包：都小写 xxxyyy 类,接口：XxxYyy 变量方法：xxxYyy 常量：XXX_YYY_ZZZ ","date":"2021-03-10","objectID":"/java-shk-2/:2:0","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"3. 变量 ","date":"2021-03-10","objectID":"/java-shk-2/:3:0","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"3.1 数据类型 包含变量类型，变量名，和存储的值。变量都定义在其作用域内，在作用域内，它是有效的，除了作用域就失效了。 基本数据类型：整数类型byte（-128～127）, short（两字节-2^15～2^15-1）, int(四字节，-21亿～21亿), long（八字节，必须以小写或大写L结尾）； 浮点类型float（四字节，必须以f或F结尾，精确到7位有效数字，范围-3.403e38～3.403e38）, double（八字节，精度为float两倍，范围-1.798e308～1.798e308）;字符型char（两字节），布尔型boolean; 引用数据类型：类（例如String类），接口，数组 ASCII字符集：8bit表示 Unicode字符集：将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，使用Unicode没有乱码的问题。char c = \\u0043(字母C)。 UTF-8: 互联网上使用最广的一种Unicode的实现方式，采用变长编码方式，使用1～6个字节表示一个符号。 ","date":"2021-03-10","objectID":"/java-shk-2/:3:1","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"3.2 基本数据类型之间的转换 自动类型提升 当容量小的数据类型的变量与容量大的数据类型的变量做运算时，结果自动提升为容量大的数据类型。 所表示数据范围（容量）排序：byte， char， short \u003c int \u003c long \u003c float \u003c double,注意这里是范围大小，而不是所占空间大小（float四字节小于long的八字节）。 特别的，当byte，char，short之间做运算时，结果为int型。 // Example short s1 = 10; byte b1 = 10; char c1 = 'a'; // char c = c1 + s1; // 编译报错 // char c = c1 + b1; // 编译报错 // short s = b1 + s1; // 编译报错 // short s = b1 + b1; // 编译报错 long l = 123213; // 成功，自动类型提升 // long l1 = 12313213123232; // 编译报错 long l1 = 12313213123232L; // 成功 //float f = 12.3; // 编译报错，double往float转了 // 整形常量默认为int型，浮点型常量默认为double型 强制类型转换 是自动类型提升的逆操作，将范围大的值向范围小的变量转换 // Example double d = 12.3; // int i = d; // 编译报错 int i = (int)d; // 成功，但截断损失精度 int i2 = 128; byte b = (byte)i2; // 成功，但是b = -128 (二进制最高位的原因) ","date":"2021-03-10","objectID":"/java-shk-2/:3:2","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"3.3 String数据类型 String类型变量的使用： String属于引用数据类型 声明String类型变量时，使用一对“” String可以和8种基本数据类型做运算，且运算只能是连接运算“+” 运算的结果仍然是String类型。 String s1 = \"Hello World!\"; // 练习：判断+是相加还是连接 char c = 'a'; int num = 10; String str = \"hello\"; System.out.println(c + num + str); // 107hello System.out.println(c + str + num); // ahello10 System.out.println(c + (num + str)); // a10hello System.out.println((c + num) + str); // 107hello System.out.println(str + num + c); // hello10a System.out.println(\"* *\"); // * * System.out.println('*' + '\\t' + '*'); // 93, 因为是char之间的数值运算 System.out.println('*' + \"\\t\" + '*'); // * * System.out.println('*' + '\\t' + \"*\"); // 51*, 第一个相加执行的是数值运算 System.out.println('*' + ('\\t' + \"*\")); // * * ","date":"2021-03-10","objectID":"/java-shk-2/:3:3","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"3.4 进制转换 整数的四种常见进制：二进制（0b或0B），十进制，八进制（以数字0开头表示），十六进制（0x或0X） 三码： 原码：直接将一个数值换成二进制数，最高位是符号位。 负数的反码：是对原码按位取反，只是最高位（符号位）确定为1。 负数的补码：其反码加1。 正数的原码，反码，补码相同。负数的补码是其反码+1。 00001110: 十进制14 10001110: -14的原码，第一位是符号位 11110001: -14的反码，除第一位外按位取反 11110010: -14的补码，计算机底层以补码形式存储数据。 求10111011储存的是什么数？ 去补10111010 取反11000101 所以储存的是-(64+4+1) = -69 特别地，10000000储存的是-128 ","date":"2021-03-10","objectID":"/java-shk-2/:3:4","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"4. 运算符 ","date":"2021-03-10","objectID":"/java-shk-2/:4:0","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"4.1 算数运算符 加减乘除（/）取模（%），前自增，后自增，前自减，后自减，字符串连接（+） int num1 = 12; int num2 = 5; System.out.println(num1 / num2); // 2 System.out.println(num1 / num2 * num2); // 10 double res = num1 / num2; System.out.println(res); // 2.0 System.out.println(num1 / (num2 + 0.0)); // 2.4 System.out.println(12 % 5); // 2 System.out.println(-12 % 5); // -2 System.out.println(12 % -5); // 2 System.out.println(-12 % -5); // -2 // 取模的符号与被模数（12/-12）相同 int a1 = 10; int b1 = ++a1; int a2 = 10; int b2 = a2++; //执行后，a1是11，b1是11，a2是11，b2是10 //注意点 short s1 = 10; // s1 = s1 + 1; // 编译失败，int值放入short变量 s1++; //编译通过，自增不改变本身变量数据类型 byte b1 = 127; b1++; System.out.println(b1); // -128 ","date":"2021-03-10","objectID":"/java-shk-2/:4:1","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"4.2 赋值运算符 =， +=， -=， *=， /=， %= // option 1 int i1 = 10; int j1 = 10; // option 2 int i2, j2; i2 = j2 = 10; // option 3 int i3 = 10; j3 = 20; short s1 = 10; // s1 = s1 + 2; // 编译失败 s1 += 2; System.out.println(s1); // 12 // 所以开发中希望变量+2 // option1: num = num + 2; // option2 (推荐): num += 2; // 所以开发中希望变量+1 // option1: num = num + 1; // option2: num += 1; // option3 (推荐): num++; int n = 10; n += (n++) + (++n); System.out.println(n); // n = n + (n++) + (++n) = 10 + 10 + 12 = 32 ","date":"2021-03-10","objectID":"/java-shk-2/:4:2","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"4.3 比较运算符 ==, !=, \u003c, \u003e, \u003c=, \u003e=, instanceof ","date":"2021-03-10","objectID":"/java-shk-2/:4:3","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"4.4 逻辑运算符 \u0026, \u0026\u0026, |, ||, !（非）, ^（异或） ","date":"2021-03-10","objectID":"/java-shk-2/:4:4","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"4.5 位运算符 \u003c\u003c, \u003e\u003e, \u003e\u003e\u003e, \u0026, |, ^（异或运算）, ~（取反） 区分逻辑\u0026和位运算\u0026：逻辑\u0026计算的是boolean型，位运算\u0026计算的是数值。 总结 位运算符操作的都是整形的数据 在一定范围内，每向左移一位，相当于 *2 在一定范围内，每向右移一位，相当于 /2 // 交换两个变量的值 // option1: 推荐 int tmp = num1; num1 = num2; num2 = num1; // option2: 可能超出存储范围 num1 = num1 + num2; num2 = num1 - num2; num1 = num1 - num2; // option3: trick num1 = num1 ^ num2; num2 = num1 ^ num2; num1 = num1 ^ num2; ","date":"2021-03-10","objectID":"/java-shk-2/:4:5","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"4.6 三元运算符 (condition) ? caseTrue : caseFalse; ","date":"2021-03-10","objectID":"/java-shk-2/:4:6","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"5. 流程控制 import java.util.Scanner; class IfTest { public static void main(String[] args) { Scanner scan = new Scanner(System.in); System.out.println(\"Input exam score: (0-100)\"); int score = scan.nextInt(); if (score == 100) { System.out.println(\"win a BMW\"); } else if (score \u003e 80) { System.out.println(\"win a iPhone\"); } else if (score \u003e= 60) { System.out.println(\"win a iPad\"); } else { System.out.println(\"no prize\"); } } } 总结： 如果多个条件表达式之间互斥，哪个判断在上面在下面，无所谓。 如果多个条件表达式之间有交集，需要考虑清楚谁在上。 如果多个条件表达式之间有包含，通常情况下，范围小的在上面，否则范围小的可能没机会执行。 int number = 2; switch (number) { case 0: System.out.println(\"zero\"); break; case 1: System.out.println(\"one\"); break; case 2: System.out.println(\"two\"); break; default: System.out.println(\"other\"); break; } 总结： 根据switch的表达式中的值，依次匹配各个case的常量。一旦匹配成功，则进入相应的case结构中，调用其执行语句。当调用完执行语句以后，则依然继续向下执行其他case结构中的执行语句，直到遇到break关键字或此switch-case结构末尾结束为止。 break可以使用在switch-case结构中，表示一旦执行到此关键字，就跳出switch-case结构。 switch结构中的表达式，只能是如下的6种数据结构之一：byte，short，char，int，枚举类型（JDK5.0新增），String类型（JDK7.0新增）。 case之后只能声明常量，不能声明范围。 break关键字是可选的。 default类似于if-else结构中的else。default结构是可选的。 如果switch-case结构中的多个case执行语句相同，则可以考虑合并。 凡是可以使用switch-case结构的地方，都可以转换为if-else。反之不成立。 我们写分支结构时，当发现既可以使用switch-case，（同时，switch中表达式的取值情况不太多），又可以使用if-else时，我们优先选择使用switch-case。原因：switch-case执行效率稍高。 for (①；②；④) { ③; } // 1-2-3-4-2-3-4-...-2 ①; while (②) { ③; ④; } // 1-2-3-4-2-3-4-...-2 do { ③; ④; } while (②); // 1-3-4-2-3-4-...-2 class PrimeNumberTest { public static void main(String[] args) { boolean isFlag = true; int count = 0; // 获取当前时间距离1970-01-01 00:00:00 的毫秒数 long start = System.currentTimeMillis(); for (int i = 2; i \u003c= 100000; i++) { for (int j = 2; j \u003c= Math.sqrt(i); j++) { if (i % j == 0) { isFlag = false; break; } } if (isFlag == true) { count++; } isFlag = true; } long end = System.currentTimeMillis(); System.out.println(\"prime number count: \" + count); System.out.println(\"elapsed time: \" + (end - start)); } } 使用范围 不同 相同 break switch-case，循环结构中 结束当前循环 关键字后面不能声明执行语句 continue 循环结构中 结束当次循环 关键字后面不能声明执行语句 label: for (int i = 2; i \u003c 100000; i++) { for (int j = 2; j \u003c Math.sqrt(i); j++) { if (i % j == 0) { // break; 默认跳出包裹此关键字的最近一层循环。 // continue; // break label; //结束指定标识的一层循环结构 // continue label; //结束指定标识的一层循环结构的当次循环 continue label; } count++; } } 循环语句的四个组成部分 初始化部分 循环条件部分 循环体部分 迭代部分 总结： 写while循环千万小心不要丢了迭代条件。一旦丢了，就可能导致死循环。 我们写程序，要避免出现死循环。 for循环和while循环是可以互相转化的。区别：for循环和while循环的初始化条件部分的作用范围不同。 do-while循环至少会执行一次循环体。 ","date":"2021-03-10","objectID":"/java-shk-2/:5:0","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"6. 数组 ","date":"2021-03-10","objectID":"/java-shk-2/:6:0","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"6.1 Array的概念与基础使用 数组的理解： 数组（Array），是多个相同数据类型按照一定顺序排列的集合，并使用一个名字命名， 并通过编号的方式对这些数据进行统一管理。 数据相关的概念：数组名，元素，下标（索引），数组的长度（元素的个数） 数据的特点： 数组是有序排列的。 数组属于引用数据类型的变量，引用数据类型有数组，类，接口。String是一个类。数组的元素，既可以是基本数据类型，也可以是引用数据类型。 创建数组对象会在内存中开辟一整块连续的空间。 数组的长度一旦确定，就不能修改。 数组的分类： 按照维数：一维数组，二维数组。。。 按照元素类型：基本数据类型元素的数组，引用数据类型元素的数组 一维数组的使用 一维数组的声明和初始化 如何调用数组的指定位置的元素 如何获取数组的长度 如何遍历数组 数组元素的默认初始化值 数组的内存解析 package com.atguigu.java; import java.util.Iterator; public class ArrayTest { public static void main(String[] args) { // 1. 一维数组的声明和初始化 int num; // 声明 num = 10; // 初始化 int id = 1001; //声明 + 初始化 int[] ids; //声明 // 1.1 静态初始化：数组的初始化和数组元素的赋值操作同时进行 ids = new int[]{1001, 1002, 1003, 1004}; // 1.2 动态初始化：数组的初始化和数组元素的赋值操作分开进行 String[] names = new String[5]; // 也是正确的写法（类型推断） int[] arr4 = {1,2,3,4,5}; // 错误的写法： // int[] arr1 = new int[]; // int[5] arr2 = new int[5]; // int[] arr3 = new int[3]{1,2,3}; // 总结：数组一旦初始化完成，其长度就确定了。 // 2. 如何调用数组的指定位置的元素：通过角标的方式调用。 // 数组的角标（或索引）从0开始，到数组的长度-1结束。 names[0] = \"aaa\"; names[1] = \"bbb\"; names[2] = \"ccc\"; names[3] = \"ddd\"; names[4] = \"eee\"; // 3. 如何获取数组的长度。 // 属性：length System.out.println(names.length); // 5 // 4. 如何遍历数组 for (int i = 0; i \u003c names.length; i++) { System.out.println(names[i]); } } } package com.atguigu.java; public class ArrayTest1 { public static void main(String[] args) { // 5. 数组元素的默认初始化值 // \u003e 数组元素是整型：0 // \u003e 数组元素是浮点型：0.0 // \u003e 数组元素是char型：ASCII0的char或'\\u0000'(null) // \u003e 数组元素是boolean型：false // \u003e 数组元素是引用数据类型：null，String时也是null，而不是空字符串 // int[] arr = new int[4]; for (int i = 0; i \u003c arr.length; i++) { System.out.println(arr[i]); } System.out.println(\"************\"); float[] arr1 = new float[4]; for (int i = 0; i \u003c arr1.length; i++) { System.out.println(arr1[i]); } System.out.println(\"************\"); char[] arr2 = new char[4]; for (int i = 0; i \u003c arr2.length; i++) { System.out.println(\"----\" + arr2[i] + \"====\"); } System.out.println(\"************\"); boolean[] arr3 = new boolean[4]; for (int i = 0; i \u003c arr3.length; i++) { System.out.println(\"----\" + arr3[i] + \"====\"); } } } package com.atguigu.java; public class ArrayTest2 { public static void main(String[] args) { // 1. 二维数组的声明和初始化 // 静态初始化 int[] arr = new int[]{1,2,3}; // 一维数组 // 动态初始化1 String[][] arr2 = new String[3][2]; // 动态初始化2 String[][] arr3 = new String[3][]; // 错误的情况 // String[][] arr4 = new String[][4]; // String[4][3] arr5 = new String[][]; } } 内存解析： 栈（stack）：局部变量 堆（heap）：new出来的结构，对象，数组 方法区：常量池，静态域 ","date":"2021-03-10","objectID":"/java-shk-2/:6:1","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"6.2 Arrays工具类的使用 package com.atguigu.java; import java.util.Arrays; // java.util.Arrays: 操作数组的工具类，包含了用来操作数组的方法 public class ArraysTest { public static void main(String[] args) { // 1. 判断两个数组是否相等。 int[] arr1 = new int[]{1,2,3,4}; int[] arr2 = new int[]{1,3,2,4}; boolean isEquals = Arrays.equals(arr1, arr2); System.out.println(isEquals); // 2. 输出数组信息 System.out.println(Arrays.toString(arr1)); // 3. 将指定值填充到数组之中 Arrays.fill(arr1, 10); System.out.println(Arrays.toString(arr1)); // 4. 对数组排序 Arrays.sort(arr2); System.out.println(Arrays.toString(arr2)); // 5. 二分查找 int[] arr3 = new int[] {-98, -34, 2, 34, 54, 66, 79, 105, 210, 333}; int index = Arrays.binarySearch(arr3, 211); System.out.println(index); } } ","date":"2021-03-10","objectID":"/java-shk-2/:6:2","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"1. 硬件介绍 ","date":"2020-11-18","objectID":"/java-shk/:1:0","tags":["Java"],"title":"Java零基础教程（一.概论）","uri":"/java-shk/"},{"categories":null,"content":"1.1 CPU（中央处理器） 冯诺伊曼体系结构：冯诺伊曼被人们称为“计算机之父”。计算机由输入设备，输出设备，存储器，运算器，控制器构成。现代计算机中的CPU负责其中的运算与控制功能。 赫兹：现代计算机的计算速度以千兆赫（GHz）来表述。英文进制：KHz，MHz，GHz Intel i7-6700HQ：“6”第六代，HQ标压版本，U低压版本 摩尔定律：每一美元所能买到的电脑性能，每隔18-24个月翻一倍以上。 ","date":"2020-11-18","objectID":"/java-shk/:1:1","tags":["Java"],"title":"Java零基础教程（一.概论）","uri":"/java-shk/"},{"categories":null,"content":"1.2 存储 硬盘 硬盘存储的数据断电不丢失（持久化设备）。在windows系统中，A/B盘的位置是预留给软驱的（软驱已经淘汰）。 内存 Read-Access Memory，内存存储数据速度比硬盘快10倍以上，其部分解决了CPU运算过快，而硬盘数据存取太慢的问题。断电会导致数据丢失 bit：二进制表示0/1 byte：8 bits，内存中每个byte拥有唯一的地址。 进制：1KB = 1024B, 1MB = 1024KB, 1GB = 1024MB, 1T = 1024GB, 1PB = 1024TB, EB,ZB,YB,以此类推。 ROM：手机的“硬盘”，例如16GB，128GB。但是经常被大众（误）叫做手机内存。 ","date":"2020-11-18","objectID":"/java-shk/:1:2","tags":["Java"],"title":"Java零基础教程（一.概论）","uri":"/java-shk/"},{"categories":null,"content":"1.3 输入输出 输入设备： 鼠标键盘； 输出设备： 显示器打印机 1920x1080：像素矩阵 2K屏幕：比如2244x1080（2244\u003e2000） 屏幕尺寸：屏幕对角线长度 像素密度：sqrt(长度像素数^2 + 宽度像素数^2) / 屏幕尺寸 ","date":"2020-11-18","objectID":"/java-shk/:1:3","tags":["Java"],"title":"Java零基础教程（一.概论）","uri":"/java-shk/"},{"categories":null,"content":"1.4 通信设备 ","date":"2020-11-18","objectID":"/java-shk/:1:4","tags":["Java"],"title":"Java零基础教程（一.概论）","uri":"/java-shk/"},{"categories":null,"content":"2. 计算机发展史 图灵：计算机之父，人工智能之父 冯诺伊曼：计算机之父，博弈论之父 www（万维网）：简称web。www可以让Web客户端（如浏览器）访问浏览Web服务器上的页面。是一个由许多互相连接的超文本组成的系统，通过互联网访问。在这个系统中，每个有用的事物，称为一样资源，并且由一个全局统一资源标识符（URI）标识；这些资源通过超文本传输协议HTTP（Hypertext Transfer Protocol）传送给用户，用户通过点击链接来获得资源。 万维网vs因特网vs互联网：他们是包含关系。万维网是无数个网络站点和网页集合。因特网除了万维网，还包括电子邮件等。 BS架构，CS架构：browser server（例如百度搜索）； client server（例如QQ） ","date":"2020-11-18","objectID":"/java-shk/:2:0","tags":["Java"],"title":"Java零基础教程（一.概论）","uri":"/java-shk/"},{"categories":null,"content":"3. Java语言概述 ","date":"2020-11-18","objectID":"/java-shk/:3:0","tags":["Java"],"title":"Java零基础教程（一.概论）","uri":"/java-shk/"},{"categories":null,"content":"3.1 编程语言 机器语言 -\u003e 汇编语言 -\u003e 高级语言（面向过程）-\u003e 高级语言（面向对象） 执行效率越来越低，但开发效率越来越高。 TIOBE语言热度排行榜 ","date":"2020-11-18","objectID":"/java-shk/:3:1","tags":["Java"],"title":"Java零基础教程（一.概论）","uri":"/java-shk/"},{"categories":null,"content":"3.2 Java语言的历史 Java由SUN（Stanford University Network）于1995年推出的编程语言。 1991 - Green项目，最初命名Oak（橡树） 1994 - 开发组意识到Oak适合互联网（可以在Web浏览器中运行，使得用户可以使用图形界面进行交互） 1996 - 发布JDK1.0 2004 - 发布JDK1.5，因为具有里程碑特性，更名为JDK5.0 2005 - J2SE改名为JavaSE，J2EE改名为JavaEE，J2ME改名为JavaME 2009 - Oracle收购SUN 2014 - 发布JDK8.0，是继JDK5.0以来变化最大的版本，也是业界常用的版本。 其他常用于后台开发的语言：Java，PhP，Python，Go，NodeJS JavaSE：桌面应用（例如QQ） JavaEE：企业互联网后台开发 JavaME：移动端开发 现在JavaSE不常开发桌面应用了，之前SE与EE是并列关系，但是这里我们把SE当作EE的基础知识。 Java应用领域： 企业级应用 Android平台应用 大数据平台开发 ","date":"2020-11-18","objectID":"/java-shk/:3:2","tags":["Java"],"title":"Java零基础教程（一.概论）","uri":"/java-shk/"},{"categories":null,"content":"3.3 Java语言特性 特性： 面向对象（封装，继承，多态） 健壮性（去掉指针，提供了内存管理机制，但Java程序也会出现内存泄漏和内存溢出的问题！） 跨平台性（Write Once, Run Anywhere）只需要安装一个Java虚拟机（JVM），JVM有不同操作系统对应的版本Win，Linux，Mac等。 ","date":"2020-11-18","objectID":"/java-shk/:3:3","tags":["Java"],"title":"Java零基础教程（一.概论）","uri":"/java-shk/"},{"categories":null,"content":"3.4 环境搭建 常见简称： JDK：（Java Development Kit） JRE：（Java Runtime Environment）运行环境 JDK = JRE + 开发工具集（例如Javac编译工具等） JRE = JVM + JavaSE标准类库 jdk-8u131: JDK8.0，“u”-update，131补丁 Steps： 安装JDK8.0（不建议安装在系统C盘下，下一步。。。下一步） 安装JRE（理论上JDK安装包里包含JRE，但是Eclipse需要识别单独的JRE） 配置环境变量（使得javac等命令可以在任意目录执行） path环境变量：Windows操作系统执行命令时，索要搜寻的路径 Administrator的用户变量适用于当前登陆用户，而系统变量则适用于所有用户。 ","date":"2020-11-18","objectID":"/java-shk/:3:4","tags":["Java"],"title":"Java零基础教程（一.概论）","uri":"/java-shk/"},{"categories":null,"content":"4. 第一个程序HelloWorld 程序执行的流程：javac编译生成.class文件，java运行.class文件。 $ javac HelloWorld.java # 生成 HelloChina.class $ java HelloChina class HelloChina { public static void main(String[] args) { System.out.println(\"Hello, World!\"); } } 总结： 一个java文件中可以声明多个class， 但只能最多有一个类声明为public，而且public只能加在与文件名相同的类前面。 程序的入口是main方法，格式是固定的。 程序行以分号结尾。 编译以后，会生成一个或多个class文件，文件名与源文件中类名相同。 单行注释//, 多行注释/**/, javadoc文档注释javadoc -d myHello -author -version ","date":"2020-11-18","objectID":"/java-shk/:4:0","tags":["Java"],"title":"Java零基础教程（一.概论）","uri":"/java-shk/"},{"categories":null,"content":"5. Eclipse使用 先创建包（例如：com.atguigu.contact）,再创建类（例如HelloWorld.java）。 运行，右键Run As 快捷键 package com.atguigu.java; import java.util.ArrayList; /* * Eclipse中的快捷键 * 1. 补全代码的声明: alt + /; ctrl + space * 2. 快速修复: ctrl + 1; cmd + 1 * 3. 批量导包: ctrl + shift + o; cmd + shift + o * 4. 单行注释: ctrl + /; cmd + / * 5. 多行注释: ctrl + shift + /; ? * 6. 取消多行注释: ctrl + shift + \\; ? * 7. 复制指定行的代码: ctrl + alt + down/up; cmd + alt + down/up * 8. 删除指定行: ctrl + d; cmd + d * 9. 上下移动行: alt + up/down; alt + up/down * 10. 切换到下一行代码空位: shift + enter; shift + enter * 11. 切换到上一行代码空位: ctrl + shift + enter; cmd + shift + enter * 12. 如何查看源码: ctrl + 选中指定结构; cmd + 选中指定结构 * 如何搜索源码: ctrl + shift + t; cmd + shift + t * 13. 退回到前一个编辑的页面: alt + left; * 14. 进入到下一个编辑的页面: alt + right; * 15. 光标选中指定的类，查看继承树结构: ctrl + t; cmd + t * 16. 复制代码: ctrl + c; cmd + c * 17. 撤销: ctrl + z; cmd + z * 18. 反撤销: ctrl + y; cmd + y * 19. 剪切: ctrl + x; cmd + x * 20. 粘贴: ctrl + v; cmd + v * 21. 保存: ctrl + s; cmd + s * 22. 全选: ctrl + a; cmd + a * 23. 格式化代码: ctrl + shift + f; cmd + shift + f * 24. 选中数行，整体往后移动: tab; tab * 25. 选中数行，整体往前移动: shift + tab; shift + tab * 26. 在当前类中，现实类结构，并支持搜索指定的方法，属性等: ctrl + o; cmd + o * 27. 批量修改指定的变量名，方法名，类名等: alt + shift + r; ? * 28. 选中的结构大小写切换，变成大写: ctrl + shift + x; cmd + shift + x * 29. 选中的结构大小写切换，变成小写: ctrl + shift + y; cmd + shift + y * 30. 调出生成getter/setter/构造器结构: alt + shift + s; ? * 31. 显式当前选择资源（工程或文件）的属性: alt + enter; cmd + enter * * * 32. 快速查找， 参照选中的word快速定位到下一个: ctrl + k; cmd + k * 33. 关闭当前窗口: ctrl + w * 34. 关闭所有窗口: ctrl + shift + w * 35. 查看指定的结构使用过的地方: ctrl + alt + g; cmd + alt + g * 36. 查找和替换: ctrl + f; cmd + f * 37. 最大化当前的view: ctrl + m * 38. 直接定位到当前行首位: home * 39. 直接定位到当前行末尾：end * * */ public class EclipseKeys { final double PROJECT_ACCCOUNT_ID = 3.14; public static void main(String[] args) { ArrayList list = new ArrayList(); int n = 1; n = 2; n = 3; } } class User { private int id; private String name; } 添加注释模版 Window -\u003e Preferences -\u003e Java -\u003e Code Style -\u003e Code Templates ","date":"2020-11-18","objectID":"/java-shk/:5:0","tags":["Java"],"title":"Java零基础教程（一.概论）","uri":"/java-shk/"},{"categories":null,"content":"IntelliJ IDEA的使用 IntelliJ模块的概念：IntelliJ的project相当于Eclipse的workspace，IntelliJ的module相当于Eclipse的project。在IntelliJ中，一个project可以是一个电商项目，其中秒杀，登陆，等都可以作为其中的模块module。 module下在自动产生的src下创建package，在package内创建java文件。 常用配置： 设置自动导包：Auto Import: 勾选Add unambiguous imports on the fly，勾选Optimize imports on the fly 方法分隔符：show method separators 自动完成代码时忽略大小写：case sensitive completion 多个tab放到多行：show tabs in single row 自动编译：勾选build project automatically, 勾选compile independent modules in parallel 快捷键： 复制行：command + d 下面添加行：shift + enter 上面添加行：alt + command + enter 删除行：command + delete 左/右选中：shift + left/right 左/右选中词：alt + shift + left/right 移动光标到行首行尾：command + left/right 移动光标到前后词：alt + left/right 快速修复：alt + enter 查询类成员：fn + command + f12 调整缩进：tab, shift + tab surround with：option + command + t 查看函数参数选项：command + p 生成构造器，get set方法：command + n psvm或main: public static void main()快捷插入 sout: System.out.println() 其他模版：postfix completion, live templates ","date":"2020-11-18","objectID":"/java-shk/:6:0","tags":["Java"],"title":"Java零基础教程（一.概论）","uri":"/java-shk/"},{"categories":null,"content":"Chapter 1: The Machine Learning Landscape 下载github库中csv数据集: import urllib.request DOWNLOAD_ROOT = \"https://raw.githubusercontent.com/ageron/handson-ml2/master/\" os.makedirs(datapath, exist_ok=True) for filename in (\"oecd_bli_2015.csv\", \"gdp_per_capita.csv\"): print(\"Downloading\", filename) url = DOWNLOAD_ROOT + \"datasets/lifesat/\" + filename urllib.request.urlretrieve(url, datapath + filename) 预处理pivot: def prepare_country_stats(oecd_bli, gdp_per_capita): # 筛选行 oecd_bli = oecd_bli[oecd_bli[\"INEQUALITY\"]==\"TOT\"] # 抽取多行数据为多列数据 oecd_bli = oecd_bli.pivot(index=\"Country\", columns=\"Indicator\", values=\"Value\") # 列重命名 gdp_per_capita.rename(columns={\"2015\": \"GDP per capita\"}, inplace=True) gdp_per_capita.set_index(\"Country\", inplace=True) # join full_country_stats = pd.merge(left=oecd_bli, right=gdp_per_capita, left_index=True, right_index=True) # 排序 full_country_stats.sort_values(by=\"GDP per capita\", inplace=True) # 剔除不需要的行 remove_indices = [0, 1, 6, 8, 33, 34, 35] keep_indices = list(set(range(36)) - set(remove_indices)) # 按整数索引行 return full_country_stats[[\"GDP per capita\", 'Life satisfaction']].iloc[keep_indices] # df.pivot()作用： # Country | INDICATOR | Value Country | Dwe....... | Housing .. | ... # ---------------------------- ===》 ---------------------------------------- # Australia| Dwe...... | 1.10 Australia| 1.10 | 20.00 | ... # Australia| Housing ..| 20.00 Austria | ... # ... ... 保存图片: # Where to save the figures PROJECT_ROOT_DIR = \".\" CHAPTER_ID = \"fundamentals\" IMAGES_PATH = os.path.join(PROJECT_ROOT_DIR, \"images\", CHAPTER_ID) os.makedirs(IMAGES_PATH, exist_ok=True) def save_fig(fig_id, tight_layout=True, fig_extension=\"png\", resolution=300): path = os.path.join(IMAGES_PATH, fig_id + \".\" + fig_extension) print(\"Saving figure\", fig_id) if tight_layout: plt.tight_layout() plt.savefig(path, format=fig_extension, dpi=resolution) 在图片上加注释: sample_data.plot(kind='scatter', x=\"GDP per capita\", y='Life satisfaction', figsize=(5,3)) plt.axis([0, 60000, 0, 10]) position_text = { \"Hungary\": (5000, 1), # 文本框左下角xy \"Korea\": (18000, 1.7), \"France\": (29000, 2.4), \"Australia\": (40000, 3.0), \"United States\": (52000, 3.8), } for country, pos_text in position_text.items(): pos_data_x, pos_data_y = sample_data.loc[country] country = \"U.S.\" if country == \"United States\" else country # xy：箭头位置， xytext：文本框位置，shrink：箭头缩短10% plt.annotate(country, xy=(pos_data_x, pos_data_y), xytext=pos_text, arrowprops=dict(facecolor='black', width=0.5, shrink=0.1, headwidth=5)) plt.plot(pos_data_x, pos_data_y, \"ro\") plt.xlabel(\"GDP per capita (USD)\") save_fig('money_happy_scatterplot') plt.show() 如果数据集中某些样本缺少一些特征（比如5%的顾客没有声明年龄），可以尝试的方法：1）忽略所有样本的年龄，2）忽略缺少年龄特征的样本，3）补缺（比如年龄的中位数）4）训练两个模型，一个包含所有特征，一个不含缺失特征。 Holdout validation: 在training set上效果好的模型，不一定在新数据上表现好，所以我们需要训练集外的数据来评判模型泛化能力。在test set上表现好的模型也只能表示其在该特定test set上表现好，还需要第三个数据集客观评判。所以，常见的处理是把数据集分为training dataset，validation dataset，和test dataset。用training dataset训练模型，确定模型参数。用validation dataset挑选一系列模型（比如确定hyperparameter）。通过validation dataset上的表现，选出最优模型再在training+validation上训练。最后通过test dataset客观评价模型的泛化能力。（思考kaggle的open和private数据集） ","date":"2020-10-25","objectID":"/handson-ml2-1/:1:0","tags":["machine learning"],"title":"《机器学习实战（第二版）》-读书笔记1","uri":"/handson-ml2-1/"},{"categories":null,"content":"数据的读入 ","date":"2020-10-19","objectID":"/kaggle-regression-eda/:1:0","tags":["kaggle","eda"],"title":"Kaggle Regression Eda","uri":"/kaggle-regression-eda/"},{"categories":null,"content":"特征的理解 ","date":"2020-10-19","objectID":"/kaggle-regression-eda/:2:0","tags":["kaggle","eda"],"title":"Kaggle Regression Eda","uri":"/kaggle-regression-eda/"},{"categories":null,"content":"特征的数据类型 df.info(verbose=True) # 查看每列缺省情况和数据类型 Pandas dtype Python type NumPy type Usage object str or mixed string_, unicode_, mixedtypes 字符串文本 int64 int int_, int8, int16, int32, int64, uint8, uint16, uint32, uint64 整数 float64 float float_, float16, float32, float64 浮点数 bool bool bool_ 真假 datetime64 NA datetime64[ns] 日期与时间 timedelta[ns] NA NA 日期时间差 category NA NA Finite list of text values ","date":"2020-10-19","objectID":"/kaggle-regression-eda/:2:1","tags":["kaggle","eda"],"title":"Kaggle Regression Eda","uri":"/kaggle-regression-eda/"},{"categories":null,"content":"特征类型 这个步骤是用来理解数据中每一列的具体含义，通过查看feature与label的关系，可以检查是否符合自己的直观感受。比如，通常情况下，房子越大，房子越新，房价越高，等等。可以通过数据类型将每个feature划归到对应的特征类型，便于后续的分析与建模。 类型1: ID 主要查看数据集是否为event level，看是否需要聚合操作将每个ID的行为总结。数据集可以是交易数据，每行数据为一笔交易，也可以是看房数据，同一套房子可能触发多个看房事件。例如，聚合每套房子的看房者数量，可以一定程度上帮助预测房子的火热程度。 类型2: Numerical 区别于类别型，数值型的特征值是可比较的，包含连续型和离散型。连续型的例子可以是价格，面积，温度, 时间。离散型的例子可以是用户打分（例如五星好评）。对于时间特征，可以做差生成时间段特征。 类型3: Categorical def specify_feature_type(df): numerical_cols = df.select_dtypes(include='number').columns.tolist() object_cols = df.select_dtypes(include='object').columns.tolist() id_features = ['Id'] label = ['SalePrice'] numerical_features = list(set(numerical_cols) - set(id_features) - set(label)) categorical_features = object_cols return id_features, numerical_features, categorical_features, label id_features, numerical_features, categorical_features, label = specify_feature_type(df) assert len(id_features) + len(numerical_features) + len(categorical_features) + len(label) == df.shape[1] ","date":"2020-10-19","objectID":"/kaggle-regression-eda/:2:2","tags":["kaggle","eda"],"title":"Kaggle Regression Eda","uri":"/kaggle-regression-eda/"},{"categories":null,"content":"特征的分布与预测能力 对于numerical feaure，可以计算feature与label的线性相关性Pearson Correlation Coefficient (PCC)，并将强相关性关系画出来。 def rank_feature_by_corr(df, method='pearson'): \"\"\"calculate Pearson correlation coefficient between feature and label, and rank the results\"\"\" feature_corr = dict() for feature in numerical_features: feature_corr[feature] = df[feature].corr(df[label[0]], method) corr_df = pd.DataFrame(feature_corr.items(), columns=['feature', 'corr']) corr_df['abs'] = np.abs(corr_df['corr']) return corr_df.sort_values('abs', ascending=False).reset_index(drop=True) def plot_feature_correlation(df, feature): fig = px.scatter(df, x=feature, y=label[0], \\ marginal_x=\"histogram\", marginal_y=\"histogram\",\\ width=600, height=450) fig.show() pcc_rank = rank_feature_by_corr(df) for i in range(2): plot_feature_correlation(df, pcc_rank.loc[i,'feature']) 而对于categorical feature, 可以画出feature列中每种类别的label分布。 import plotly.figure_factory as ff def plot_label_distribution_per_class(df, feature): hist_data = [] group_labels = [] for name, group in df.groupby(feature): hist_data.append(group[label[0]]) group_labels.append(name) # Create distplot with curve_type set to 'normal' fig = ff.create_distplot(hist_data, group_labels, show_hist=False) # Add title fig.update_layout(title_text='Curve and Rug Plot') fig.show() plot_label_distribution_per_class(df, categorical_features[0]) 也可以用heatmap将两两之间的相关性画出来。 fig = px.imshow(df.corr()) fig.show() ","date":"2020-10-19","objectID":"/kaggle-regression-eda/:2:3","tags":["kaggle","eda"],"title":"Kaggle Regression Eda","uri":"/kaggle-regression-eda/"},{"categories":null,"content":"参考 pandas数据类型 Kaggle房价预测 correlation between categorical and numerical variable ","date":"2020-10-19","objectID":"/kaggle-regression-eda/:3:0","tags":["kaggle","eda"],"title":"Kaggle Regression Eda","uri":"/kaggle-regression-eda/"},{"categories":null,"content":"Example 1. DataFrame的5种基本操作 1.筛选行，2.选取列，3.增加行列，4.分组总结，5.排序 一个简单的工资数据集： df = spark.createDataFrame([ (1, 'sales', 4200), (2, 'admin', 3100), (3, 'sales', 4000), (4, 'sales', 4000), (5, 'admin', 2700), (6, 'dev', 3400), (7, 'dev', 5200), (8, 'dev', 3700), (9, 'dev', 4400), (10, 'dev', 4400) ], schema=['id', 'dept', 'salary']) df.show() # +---+-----+------+ # | id| dept|salary| # +---+-----+------+ # | 1|sales| 4200| # | 2|admin| 3100| # | 3|sales| 4000| # | 4|sales| 4000| # | 5|admin| 2700| # | 6| dev| 3400| # | 7| dev| 5200| # | 8| dev| 3700| # | 9| dev| 4400| # | 10| dev| 4400| # +---+-----+------+ Q1: 列出dev部门工资大于4000的所有id。(filter, select, show) df.filter((F.col('dept') == 'dev') \u0026 (F.col('salary') \u003e 4000)).select(['id', 'salary']).show() # +---+------+ # | id|salary| # +---+------+ # | 6| 3400| # | 7| 5200| # | 8| 3700| # | 9| 4400| # | 10| 4400| # +---+------+ Q2: 求基础工资的10%奖金列，并补全列名dept-\u003edepartment。(withColumn, withColumnRenamed) df.withColumn('bonus', F.col('salary')*0.1).withColumnRenamed('dept', 'department').show() # +---+----------+------+-----+ # | id|department|salary|bonus| # +---+----------+------+-----+ # | 1| sales| 4200|420.0| # | 2| admin| 3100|310.0| # | 3| sales| 4000|400.0| # | 4| sales| 4000|400.0| # | 5| admin| 2700|270.0| # | 6| dev| 3400|340.0| # | 7| dev| 5200|520.0| # | 8| dev| 3700|370.0| # | 9| dev| 4400|440.0| # | 10| dev| 4400|440.0| # +---+----------+------+-----+ Q3: 求每个部门的最低工资，平均工资，最高工资。(groupby, agg, alias, sort), 并按平均工资降序排序。 df.groupby('dept').agg(F.min(F.col('salary')).alias('minimum'), \\ F.avg(F.col('salary')).alias('mean'), \\ F.max(F.col('salary')).alias('maximum'))\\ .sort('mean', ascending=False).show() # +-----+-------+------------------+-------+ # | dept|minimum| mean|maximum| # +-----+-------+------------------+-------+ # | dev| 3400| 4220.0| 5200| # |sales| 4000|4066.6666666666665| 4200| # |admin| 2700| 2900.0| 3100| # +-----+-------+------------------+-------+ ","date":"2020-09-03","objectID":"/spark-practice-101/:1:0","tags":["spark"],"title":"Spark 101: DataFrame基本使用","uri":"/spark-practice-101/"},{"categories":null,"content":"Example 2. groupby 与 window 参考：Youtube, How do spark window functions work? Q1: 求部门工资数组，和部门总工资。(groupby, agg, collect_list) df = df.groupby('dept').agg( F.expr('collect_list(salary)').alias('list_salary'), F.expr('avg(salary)').alias('average_salary'), F.expr('sum(salary)').alias('total_salary') ).show() # +-----+--------------------+------------------+------------+ # | dept| list_salary| average_salary|total_salary| # +-----+--------------------+------------------+------------+ # | dev|[3400, 5200, 3700...| 4220.0| 21100| # |sales| [4200, 4000, 4000]|4066.6666666666665| 12200| # |admin| [3100, 2700]| 2900.0| 5800| # +-----+--------------------+------------------+------------+ Q2: 在每条数据旁列出所在部门的工资情况（上问的答案）。(Window, partitionBy, over) windowSpec = Window.partitionBy('dept') df = df.withColumn('list_salary', F.collect_list(F.col('salary')).over(windowSpec))\\ .withColumn('average_salary', F.avg(F.col('salary')).over(windowSpec))\\ .withColumn('total_salary', F.sum(F.col('salary')).over(windowSpec)).show() # +---+-----+------+--------------------+------------------+------------+ # | id| dept|salary| list_salary| average_salary|total_salary| # +---+-----+------+--------------------+------------------+------------+ # | 6| dev| 3400|[3400, 5200, 3700...| 4220.0| 21100| # | 7| dev| 5200|[3400, 5200, 3700...| 4220.0| 21100| # | 8| dev| 3700|[3400, 5200, 3700...| 4220.0| 21100| # | 9| dev| 4400|[3400, 5200, 3700...| 4220.0| 21100| # | 10| dev| 4400|[3400, 5200, 3700...| 4220.0| 21100| # | 1|sales| 4200| [4200, 4000, 4000]|4066.6666666666665| 12200| # | 3|sales| 4000| [4200, 4000, 4000]|4066.6666666666665| 12200| # | 4|sales| 4000| [4200, 4000, 4000]|4066.6666666666665| 12200| # | 2|admin| 3100| [3100, 2700]| 2900.0| 5800| # | 5|admin| 2700| [3100, 2700]| 2900.0| 5800| # +---+-----+------+--------------------+------------------+------------+ Q3: 将工资在其部门顺序，在部门内扫描得到前缀和（相等的工资同时扫描）。(orderBy) windowSpec = Window.partitionBy('dept').orderBy(F.asc('salary')) df = df.withColumn('list_salary', F.collect_list(F.col('salary')).over(windowSpec))\\ .withColumn('average_salary', F.avg(F.col('salary')).over(windowSpec))\\ .withColumn('total_salary', F.sum(F.col('salary')).over(windowSpec)).show() # +---+-----+------+--------------------+------------------+------------+ # | id| dept|salary| list_salary| average_salary|total_salary| # +---+-----+------+--------------------+------------------+------------+ # | 6| dev| 3400| [3400]| 3400.0| 3400| # | 8| dev| 3700| [3400, 3700]| 3550.0| 7100| # | 9| dev| 4400|[3400, 3700, 4400...| 3975.0| 15900| # | 10| dev| 4400|[3400, 3700, 4400...| 3975.0| 15900| # | 7| dev| 5200|[3400, 3700, 4400...| 4220.0| 21100| # | 3|sales| 4000| [4000, 4000]| 4000.0| 8000| # | 4|sales| 4000| [4000, 4000]| 4000.0| 8000| # | 1|sales| 4200| [4000, 4000, 4200]|4066.6666666666665| 12200| # | 5|admin| 2700| [2700]| 2700.0| 2700| # | 2|admin| 3100| [2700, 3100]| 2900.0| 5800| # +---+-----+------+--------------------+------------------+------------+ 注：注意观察id9\u002610的重复工资，相等的工资条将导致工资前缀和的同时扫描。请看下问一个更贴切实际的前缀和实例。 Q4: Q3问题不变（相等的工资先后扫描）。(rowsBetween) windowSpec = Window.partitionBy('dept').orderBy(F.asc('salary'))\\ .rowsBetween(Window.unboundedPreceding, Window.currentRow) df = df.withColumn('list_salary', F.collect_list(F.col('salary')).over(windowSpec))\\ .withColumn('average_salary', F.avg(F.col('salary')).over(windowSpec))\\ .withColumn('total_salary', F.sum(F.col('salary')).over(windowSpec)).show() # +---+-----+------+--------------------+------------------+------------+ # | id| dept|salary| list_salary| average_salary|total_salary| # +---+-----+------+--------------------+------------------+------------+ # | 6| dev| 3400| [3400]| 3400.0| 3400| # | 8| dev| 3700| [3400, 3700]| 3550.0| 7100| # | 9| dev| 4400| [3400, 3700, 4400]|3833.3333333333335| 11500| # | 10| dev| 4400|[3400, 3700, 4400...| 3975.0| 15900| # | 7| dev| 5200|[3400, 3700, 4400...| 4220.0| 21100| # | 3|sales| 4000| [4000]| 4000.0| 4000| # | 4|sales| 4000| [4000, 4000]| 4000.0| 8000| # | ","date":"2020-09-03","objectID":"/spark-practice-101/:2:0","tags":["spark"],"title":"Spark 101: DataFrame基本使用","uri":"/spark-practice-101/"},{"categories":null,"content":"Example 3. Join与Skew Join join可以把两张表内关键字匹配的数据做笛卡尔乘积，放入结果表。 参考： Medium, 6 spark exercises to rule them all 数据集：三张表sales, products, sellers, 大约6GB，使用local模式。 Q1: 三张表各有多少记录？(parquet, count) DATASET_PATH = './DatasetToCompleteTheSixSparkExercises' products = spark.read.parquet(f'{DATASET_PATH}/products_parquet') sales = spark.read.parquet(f'{DATASET_PATH}/sales_parquet') sellers = spark.read.parquet(f'{DATASET_PATH}/sellers_parquet') sales.count(), products.count(), sellers.count() # (20000040, 75000000, 10) Q2: 有多少种商品至少被卖出过一次？(distinct) sales.select(['product_id']).distinct().count() # 993429 Q3: 订单中最常见的商品是哪个？(sort, limit) sales.groupby(['product_id']).count().sort('count', ascending=False).limit(1).show() # +----------+--------+ # |product_id| count| # +----------+--------+ # | 0|19000000| # +----------+--------+ Q4: 统计sales中product_id的分布情况 (groupby, groupby) key_stats = sales.groupby('product_id').count().withColumnRenamed('count', 'pid_count')\\ .groupby('pid_count').count().toPandas() key_stats = key_stats.sort_values('pid_count') key_stats['frequency'] = key_stats['count'] / sum(key_stats['count']) key_stats['cum_freq'] = np.cumsum(key_stats['frequency']) key_stats # 先通过groupby得到key size， 再按照小key到大key排列，最后通过groupby统计每个key size的数量 # pid_count count frequency cum_freq # 0 1 986847 0.993374 0.993374 # 2 2 6550 0.006593 0.999968 # 1 3 31 0.000031 0.999999 # 3 19000000 1 0.000001 1.000000 plt.plot(np.log10(key_stats['pid_count']), key_stats['cum_freq']) Q5: 每天各卖多少种商品？(countDistinct) sales.groupby(['date']).agg(F.countDistinct(\"product_id\").alias(\"cnt\")).sort(\"cnt\", ascending=False).show() # +----------+------+ # | date| cnt| # +----------+------+ # |2020-07-06|100765| # |2020-07-09|100501| # |2020-07-01|100337| # |2020-07-03|100017| # |2020-07-02| 99807| # |2020-07-05| 99796| # |2020-07-04| 99791| # |2020-07-07| 99756| # |2020-07-08| 99662| # |2020-07-10| 98973| # +----------+------+ Q6: 求订单盈利（数量x价格）的平均值。(join, skewed data) 由于订单中的商品集中在少数商品ID，使用product_id进行join会造成skewed data,降低并行效率。 df = sales.join(products, on='product_id') df = df.withColumn('revenue', sales['num_pieces_sold'] * products['price']) df.select(F.avg('revenue')).show() # +------------------+ # | avg(revenue)| # +------------------+ # |1246.1338560822878| # +------------------+ 可以对product常见key加盐，可以先join两表加盐的key部分，再join两表未加盐的普通key部分，最后union。这样可以把集中分布的key加盐溶解，提高集群的并行效率。 def skew_join(skew_df, other_df, on, topK, how='inner', SALT_RANGE=100): # STEP1: find topK popular keys in skew_df topKkey = skew_df.groupby(on).agg({'*': 'count'}).withColumnRenamed('count(1)', '_skew_key_cnt')\\ .sort('_skew_key_cnt', ascending=False).limit(topK) # STEP2: split skew_df, other_df into pop and unpop halves skew_df_pop = skew_df.join(F.broadcast(topKkey), on=on).drop('_skew_key_cnt') skew_df_unpop = skew_df.join(F.broadcast(topKkey), on=on, how='left_anti').drop('_skew_key_cnt') other_df_pop = other_df.join(F.broadcast(topKkey), on=on).drop('_skew_key_cnt') other_df_unpop = other_df.join(F.broadcast(topKkey), on=on, how='left_anti').drop('_skew_key_cnt') # STEP3: salt skew_df_pop, replicate other_df_pop skew_df_pop = skew_df_pop.withColumn('_skew_salt', (F.rand() * SALT_RANGE).cast(types.IntegerType())) other_df_pop = other_df_pop.withColumn('_skew_salts', F.array([F.lit(i) for i in range(SALT_RANGE+1)])) other_df_pop = other_df_pop.select('*', F.explode('_skew_salts').alias('_skew_salt')).drop('_skew_salts') # STEP4: join seperately and union res_pop = skew_df_pop.join(other_df_pop, on=on+['_skew_salt'], how=how).drop('_skew_salt') res_unpop = skew_df_unpop.join(other_df_unpop, on=on, how=how) return res_pop.union(res_unpop) df = skew_join(sales, products, on=['product_id'], topK=10) df = df.withColumn('revenue', sales['num_pieces_sold'] * products['price']) df.select(F.avg('revenue')).show() # +------------------+ # | avg(revenue)| # +------------------+ # |1246.1338560822878| # +------------------+ Q7: 对每个销售员，求一个订单对其目标的平均贡献。(broadcast) 注：比如销售员0目标250件总共拥有三笔订单，订单1卖10件，订单2卖8件，订单3卖7件。那么每张订","date":"2020-09-03","objectID":"/spark-practice-101/:3:0","tags":["spark"],"title":"Spark 101: DataFrame基本使用","uri":"/spark-practice-101/"},{"categories":null,"content":"Example 4. UDF Q1: 在sales数据中创建列，根据order_id和bill_raw_text计算每条销售数据bill的hash值，并查看是否有hash冲突。(udf) hash规则： 当order_id为奇数，计算sha256；当order_id为偶数时，迭代计算md5，迭代次数为大写A出现的次数。 import hashlib from pyspark.sql.types import StringType def fancy_hash(order_id, bill_raw_text): res = bill_raw_text.encode('utf-8') # 1) even case if int(order_id) % 2 == 0: cnt_A = bill_raw_text.count('A') for _ in range(cnt_A): res = hashlib.md5(res).hexdigest().encode('utf-8') res = res.decode('utf-8') else: res = hashlib.sha256(res).hexdigest() return res # Convert the fancy_hash python function into its UDF fancy_hash_udf = F.udf(lambda arg1, arg2: fancy_hash(arg1, arg2), StringType()) sales.withColumn('hashed_bill', fancy_hash_udf(sales['order_id'], sales['bill_raw_text']))\\ .groupby('hashed_bill').agg(F.count('*').alias('cnt')).filter(F.col('cnt') \u003e 1).show() # 返回为空，即无哈希冲突 ","date":"2020-09-03","objectID":"/spark-practice-101/:4:0","tags":["spark"],"title":"Spark 101: DataFrame基本使用","uri":"/spark-practice-101/"},{"categories":null,"content":"Example 5. UDF 数据集DataFrame [startDate: timestamp, binaryIds: array\u003cbigint\u003e] 寻找最新的100个binaryId ","date":"2020-09-03","objectID":"/spark-practice-101/:5:0","tags":["spark"],"title":"Spark 101: DataFrame基本使用","uri":"/spark-practice-101/"},{"categories":null,"content":"什么是数据倾斜？ 对于Spark/Hadoop等分布式系统，机器间工作量的不均匀比单纯的工作量大更难处理，因为单纯的工作量大基本通过scale-out就可以解决。假设有100个任务并行处理，若任务间工作量相当，20台机器要比10台机器耗时减半（假设机器性能相当）。然而当任务间工作量相差巨大时（例如，任务中10个大任务，90个小任务，工作量差别1M倍），很难通过scale-out的方式充分利用并行优势，此时，完成总耗时取决于最慢的大任务何时完成（木桶原理）。 对于Spark这种计算引擎，工作量主要在于所需处理的数据量。因此当任务划分时，数据分布不均匀，即发生了数据倾斜。 ","date":"2020-08-30","objectID":"/spark-data-skew/:1:0","tags":["spark"],"title":"Spark: 解决数据倾斜的N种姿势","uri":"/spark-data-skew/"},{"categories":null,"content":"数据是如何倾斜的？ 当Spark产生shuffle操作时，相同key的数据会被放在相同的partition。因此当某一个key的数据量过大（即popular key），会造成partition间工作量巨大差别，造成数据倾斜。这样不仅影响了并行效率，更加容易造成内存不足，产生OOM（Out Of Memory）报错使整个应用崩溃。 常见会触发shuffle的算子：distinct, groupByKey, reduceByKey, aggregateByKey, join, cogroup, repartition。 ","date":"2020-08-30","objectID":"/spark-data-skew/:2:0","tags":["spark"],"title":"Spark: 解决数据倾斜的N种姿势","uri":"/spark-data-skew/"},{"categories":null,"content":"如何识别数据倾斜？ 观察stage进度条，发现大多数task很快执行完，但是剩余task等待时间巨长甚至出现OOM报错。（如上图） 查看Spark Web UI里的Shuffle Read Size/Records，查看任务间数据量分布是否均匀。 计算key的分布。（如下） df.select(\"key\").sample(false, 0.1) // 数据采样 .(k =\u003e (k, 1)).reduceBykey(_ + _) // 统计 key 出现的次数 .map(k =\u003e (k._2, k._1)).sortByKey(false) // 根据 key 出现次数进行排序 .take(10) // 取前 10 个。 ","date":"2020-08-30","objectID":"/spark-data-skew/:3:0","tags":["spark"],"title":"Spark: 解决数据倾斜的N种姿势","uri":"/spark-data-skew/"},{"categories":null,"content":"发生了数据倾斜怎么办？ ","date":"2020-08-30","objectID":"/spark-data-skew/:4:0","tags":["spark"],"title":"Spark: 解决数据倾斜的N种姿势","uri":"/spark-data-skew/"},{"categories":null,"content":"思路1 - 过滤异常数据 如果数据包含大量异常key，过滤掉就好了。 异常key： 空值 Null 无效数据，大量重复的测试数据或是对结果影响不大的有效数据 有效数据，业务导致的正常数据分布 对于情况1\u00262，直接过滤即可。对于3，直接过滤不适用，尝试以下其他方法。 ","date":"2020-08-30","objectID":"/spark-data-skew/:4:1","tags":["spark"],"title":"Spark: 解决数据倾斜的N种姿势","uri":"/spark-data-skew/"},{"categories":null,"content":"思路2 - 提高shuffle并行度 通过增加partition的方法，让每个task执行更少的不同key，把原本被分配到同一task的不同key分配到不同task。 RDD 操作 可在需要 Shuffle 的操作算子上直接设置并行度或者使用 spark.default.parallelism 设置。如果是 Spark SQL，还可通过 SET spark.sql.shuffle.partitions=[num_tasks] 设置并行度。默认参数由不同的 Cluster Manager 控制。 dataFrame 和 sparkSql 可以设置 spark.sql.shuffle.partitions=[num_tasks] 参数控制 shuffle 的并发度，默认为200。 TIPS 可以把数据倾斜类比为 hash 冲突。提高并行度就类似于 提高 hash 表的大小。 ","date":"2020-08-30","objectID":"/spark-data-skew/:4:2","tags":["spark"],"title":"Spark: 解决数据倾斜的N种姿势","uri":"/spark-data-skew/"},{"categories":null,"content":"思路3 - 自定义Partitioner ","date":"2020-08-30","objectID":"/spark-data-skew/:4:3","tags":["spark"],"title":"Spark: 解决数据倾斜的N种姿势","uri":"/spark-data-skew/"},{"categories":null,"content":"思路4 - Broadcast机制 对于Join算子，若一边数据足够小到放入内存，可以通过Broadcast方法广播到Worker中。这样的Broadcast Join完全避免了shuffle，彻底消除了数据倾斜产生的条件。 from pyspark.sql.functions import broadcast result = broadcast(A).join(B, [\"join_col\"], \"left\") ","date":"2020-08-30","objectID":"/spark-data-skew/:4:4","tags":["spark"],"title":"Spark: 解决数据倾斜的N种姿势","uri":"/spark-data-skew/"},{"categories":null,"content":"思路5 - 拆分join再union 对于Join算子，若一边数据倾斜，另一边数据均匀，且无法map端join（broadcast），可以把两边大表各拆分为popular key与unpopular key部分，分别join再union。 join例子： left （数据倾斜）和 right（数据均匀） 采样统计left中Top K popular key，把两表按照key是否popular分拆 left = leftSkew + leftUnskew right = rightSkew + rightUnskew 左加盐，右膨胀 对leftSkew加盐，即key -\u003e (key, rand(N)), 这样大key会被分配到不同partition 对rightSkew做flatMap操作把每条数据转化为N条数据，即key -\u003e (key, 1), (key, 2), ... (key, N) 分别join再union，即Union ( Join(leftSkew, rightSkew), Join(leftUnskew, rightUnskew) ) ","date":"2020-08-30","objectID":"/spark-data-skew/:4:5","tags":["spark"],"title":"Spark: 解决数据倾斜的N种姿势","uri":"/spark-data-skew/"},{"categories":null,"content":"思路6 - 大表key加盐，小表扩大N倍join 对于数据倾斜表中key都很大的情况，分拆popular key与unpopular key意义不大。可直接对大表整体加盐，小表扩大N倍后再join，即此思路为思路5的局部优化Join(leftSkew, rightSkew)。 例子 创建两个表来模拟，其中大表数据倾斜，小表相对均匀 from math import exp from random import randint from datetime import datetime def count_elements(splitIndex, iterator): n = sum(1 for _ in iterator) yield (splitIndex, n) def get_part_index(splitIndex, iterator): for it in iterator: yield (splitIndex, it) num_parts = 18 # create the large skewed rdd skew_rdd = sc.parallelize(range(0,num_parts), num_parts).flatMap(lambda x: range(0, int(exp(x)))) skew_rdd = skew_rdd.mapPartitionsWithIndex(lambda idx, x: get_part_index(idx, x)) skew_df = spark.createDataFrame(skewed_large_rdd,['x','y']) small_rdd = sc.parallelize(range(0,num_parts), num_parts).map(lambda x: (x, x)) small_df = spark.createDataFrame(small_rdd,['a','b']) # skew_df: small_df: # x, y a, b # ==== ==== # 0, 0 0, 0 # 1, 0 1, 1 # 1, 1 2, 2 # 2, 0 3, 3 # 2, 1 4, 4 # 2, 2 5, 5 # 2, 3 6, 6 # 2, 4 7, 7 # 2, 5 8, 8 # 2, 6 9, 9 # ... ... 大表key加盐，小表扩大N（=100）倍 salt_bins = 100 from pyspark.sql import functions as F skew_df_salt = skew_df.withColumn('salt', (F.rand()*salt_bins).cast('int')).cache() small_df_rep = small_df.withColumn('replicate', F.array([F.lit(i) for i in range(salt_bins)])) small_df_rep = small_df_rep.select('*', F.explode('replicate').alias('salt')).drop('replicate').cache() # skew_df: small_df: # x, y, salt a, b, salt # ========== ========== # 0, 0, 24 0, 0, 0 # 1, 0, 53 0, 0, 1 # 1, 1, 24 0, 0, 2 # 2, 0, 37 0, 0, 3 # 2, 1, 99 0, 0, 4 # 2, 2, 87 0, 0, 5 # 2, 3, 14 0, 0, 6 # 2, 4, 94 0, 0, 7 # 2, 5, 12 0, 0, 8 # 2, 6, 5 0, 0, 9 # ... ... 最后join %%time # measure excution time in jupyter notebook res = skew_df_salt.join(small_df_rep, (skew_df_salt['x'] == small_df_rep['a'])\\ \u0026 (skew_df_salt['salt'] == small_df_rep['salt'])) res.count() # res: # x, y, b # ========= # 0, 0, 0 # 1, 0, 1 # 1, 1, 1 # 2, 0, 2 # 2, 1, 3 # 2, 2, 2 # 2, 3, 2 # 2, 4, 2 # 2, 5, 2 # 2, 6, 2 # ... ","date":"2020-08-30","objectID":"/spark-data-skew/:4:6","tags":["spark"],"title":"Spark: 解决数据倾斜的N种姿势","uri":"/spark-data-skew/"},{"categories":null,"content":"思路7 - map端先局部聚合 ","date":"2020-08-30","objectID":"/spark-data-skew/:4:7","tags":["spark"],"title":"Spark: 解决数据倾斜的N种姿势","uri":"/spark-data-skew/"},{"categories":null,"content":"思路8 - 加盐局部聚合 + 去盐全局聚合 ","date":"2020-08-30","objectID":"/spark-data-skew/:4:8","tags":["spark"],"title":"Spark: 解决数据倾斜的N种姿势","uri":"/spark-data-skew/"},{"categories":null,"content":"参考 Arganzheng’s Blog, Spark数据倾斜及其解决方案 ","date":"2020-08-30","objectID":"/spark-data-skew/:5:0","tags":["spark"],"title":"Spark: 解决数据倾斜的N种姿势","uri":"/spark-data-skew/"},{"categories":null,"content":"什么是Job, Stage, Task? Spark数据处理是像流水线一样，通过一系列操作（算子）完成对RDD的处理, 即RDD1 -\u003e RDD2 -\u003e ...。操作分为两类：Transformation和Action。Spark使用lazy evaluation模式，即Transformation操作下达后，实际并不立刻运行，只有当遇到Action时才把之前所有的Transformation和当前Action运行完毕。每当一个Action触发，就会生成一个Job。因此Job以Action划分。Job之间是串行的，只有当前job结束，才会启动下一个job。 一个Job会被划分为一个或多个stage。在一个stage中，任务是可以并行计算的。stage是按照ShuffleDependency来进行划分的。两种依赖方式为窄依赖（narrow dependency）与宽依赖（wide dependency）。区分两种依赖的方法是看：父RDD的partition是否被多个（\u003e1）子RDD的partition使用，若未被多个子RDD的partition使用，则为窄依赖，不需shuffle，不划分stage； 否则为宽依赖，划分stage。上图对比了两种依赖方式的不同。具体划分stage的算法是: 从最后一个RDD开始，从后往前推，找该RDD和父RDD之间的依赖关系，如果是窄依赖，会继续找父RDD的父RDD，如果是宽依赖，就会从该RDD开始到前面所有的RDD划分为一个stage，递归的出口是直到找不到父RDD，最后把所有的RDD划分为一个stage。 一个例子： 一个stage并行的任务称为task，对应一个partition的处理，即task总数为stage的partition总数。 ","date":"2020-08-29","objectID":"/spark-fundamentals/:1:0","tags":["spark"],"title":"Spark FAQ","uri":"/spark-fundamentals/"},{"categories":null,"content":"参考 Wide vs Narrow Dependencies github blog stackoverflow, Does stages in an application run parallel in spark Queirozf Apache Spark Architecture Overview: Jobs, Stages, Tasks, etc cnblogs, qingyunzong csdn, Z_Data Spark by Examples, Spark Repartition vs Coalesce Arganzheng’s Blog, Spark数据倾斜及其解决方案 ","date":"2020-08-29","objectID":"/spark-fundamentals/:2:0","tags":["spark"],"title":"Spark FAQ","uri":"/spark-fundamentals/"},{"categories":null,"content":"目录结构 /bin (/usr/bin, /usr/local/bin): binary,存放最经常使用的命令 /sbin (/usr/sbin, /usr/local/sbin): s: super user, 存放系统管理员使用的系统管理程序 /home: 存放普通用户的主目录，每个用户都有一个自己的目录 /root: 超级权限者的用户主目录(This is not the root (/) filesystem. It is the home directory for the root user.) /lib: 系统开机所需要最基本的动态连接共享库，类似Windows的DLL文件。几乎所有应用程序都需要用到这些共享库 /etc: 系统管理所需要的配置文件和子目录 /usr: 用户的很多应用程序和文件都放在这个目录下，类似Windows的program files目录 /proc,/srv,/sys: 内核相关目录（不要轻易修改） /dev: 硬件以文件的形式存放在该处 /media: U盘，光驱，等等 /mnt: 用户临时挂载的文件系统 /opt: 存放安装软件 /usr/local: 存放安装软件所安装的目录，一般是通过编译源码的方式安装的程序 /var: 存放经常被修改的东西，比如日志文件 ","date":"2020-08-19","objectID":"/linux-intro/:1:0","tags":["linux"],"title":"Linux入门","uri":"/linux-intro/"},{"categories":null,"content":"Vi/Vim快捷键 拷贝当前行yy, 拷贝当前行以下的5行5yy,粘贴p 删除当前行dd, 删除当前行以下的5行5dd 查找关键词/keyword,下一个出现n 显示行号:set nu,隐藏行号:set nonu 阅览最首行gg最末行G 撤销输入动作u 移动光标至第20行20+shift g ","date":"2020-08-19","objectID":"/linux-intro/:2:0","tags":["linux"],"title":"Linux入门","uri":"/linux-intro/"},{"categories":null,"content":"开关重启命令 sync # 把内存数据同步到磁盘，以下操作前先执行该命令 shutdown -h now # 立即关机 shutdown -h 1 # 1min 关机 shutdown -r now # 立即重启 halt # 等同于关机 reboot # 立即重启 ","date":"2020-08-19","objectID":"/linux-intro/:3:0","tags":["linux"],"title":"Linux入门","uri":"/linux-intro/"},{"categories":null,"content":"用户管理 useradd xiaoming # 自动创建home下同名目录 passwd xiaoming # 指定密码 userdel xiaoming # 删除用户xiaoming，home下其目录会保留 userdel -r xiaoming # 删除用户xiaoming，home下其目录不会保留 su - xiaoming # 切换用户登陆， 权限不足会给提示，exit返回到原先用户 groupadd zuming # 创建组 groupdel zuming # 删除组 useradd -g zuming xiaoming # 创建用户时，指定组 id xiaoming # 查询用户信息 usermod -g zuming2 xiaoming # 修改用户所在组 用户配置文件在： /etc/passwd （用户id，组id，家目录，shell） 组配置文件在：/etc/group 口令配置文件（密码，登录信息）：/etc/shadow(加密的) ","date":"2020-08-19","objectID":"/linux-intro/:4:0","tags":["linux"],"title":"Linux入门","uri":"/linux-intro/"},{"categories":null,"content":"实用命令 man ls # 显示ls用法 help cd # 显示cd用法 touch filename # 创建空文件 cat -n filename ｜ more # 打开文件内容（只读方式）, -n 显示行号，more分页显示 more filename # 按页显示文件，空格翻页，Enter下一行，ctrl+f/b less filename # 分页查看，lazy加载，利于显示大文件 \"less is more\" ls -l \u003e filename # 重定向（覆盖） ls -l \u003e\u003e filename # 追加（append到尾部） head -n 5 filename # 只显示文件前5行（默认10行） tail -n 5 filename # 只显示文件后5行（默认10行） -f追踪文件更新，日志监控经常用 date \"+%Y-%m-%d %H:%M:%S\" # 按格式显示当前年月日时分秒，“+”必要， -s设定 cal # 显示当前日历 find [scope] [-name 文件名, -user 用户, -size 文件大小] grep [-n 显示匹配行行号， -i 忽略大小写] 查找内容 源文件 cat hello.txt | grep -ni yes # 在hello.txt中，不区分大小写的查找yes grep -r [keyword] /data/reports zip -r xxx.zip files unzip -d 位置 xxx.zip tar -zcvf a.tar.gz a1.txt a2.txt tar -zxvf a.tar.gz ","date":"2020-08-19","objectID":"/linux-intro/:5:0","tags":["linux"],"title":"Linux入门","uri":"/linux-intro/"},{"categories":null,"content":"组管理，权限管理 在linux中的每个用户必须属于一个组，不能独立于组外。在linux中每个文件有所有者，所在组，其他组的概念。 ","date":"2020-08-19","objectID":"/linux-intro/:6:0","tags":["linux"],"title":"Linux入门","uri":"/linux-intro/"},{"categories":null,"content":"任务调度 crontab -e crontab -l crontab -r 45 22 * * * 在22点45分执行 0 17 * * 1 每周一17点0分执行 0 5 1,15 * * 每月1号15号凌晨5点执行 40 4 * * 1-5 每周一到周五凌晨4点40分执行 */10 4 * * * 每天凌晨4点每隔10分执行一次 0 0 1,15 * 1 每月1号和15号，每周一的0点0分执行。星期几和几号最好不要同时出现，容易混乱 ","date":"2020-08-19","objectID":"/linux-intro/:7:0","tags":["linux"],"title":"Linux入门","uri":"/linux-intro/"},{"categories":null,"content":"进程管理 ps -a/u/x | more ps -ef | grep sshd # 查看sshd的父进程ID kill [pid] pstree -p top netstat -anp | more # 查看网络服务 USER 用户名称 PID 进程号 %CPU 进程占用CPU的百分比 %MEM 进程占用物理内存的百分比 VSZ 进程占用的虚拟内存大小（KB） RSS 进程占用的物理内存大小（KB） TT 终端名称 STAT 进程状态 S-睡眠 R-正在运行 Z-僵死 STARTED 进程的启动时间 TIME 使用CPU总时间 COMMAND 启动进程的命令和参数 ","date":"2020-08-19","objectID":"/linux-intro/:8:0","tags":["linux"],"title":"Linux入门","uri":"/linux-intro/"},{"categories":null,"content":"服务管理 开机流程： 开机 -\u003e BIOS -\u003e /boot -\u003e init process (1) -\u003e 运行级别 -\u003e 运行级别对应的服务 service [service name] start|stop|restart|reload|status ls -l /etc/init.d chkconfig --list 服务的运行级别(runlevel)： 运行级别0: 系统停机状态，系统默认运行级别不能设为0，否则不能正常启动 运行级别1: 单用户工作状态，root权限，用于系统维护，禁止远程登录 运行级别2: 多用户状态（没有NFS），不支持网络 运行级别3: 完全的多用户状态（有NFS），登陆后进入控制台命令行模式 运行级别4: 系统未使用，保留 运行级别5: X11控制台，登陆后进入图形GUI模式 运行级别6: 系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动 ","date":"2020-08-19","objectID":"/linux-intro/:9:0","tags":["linux"],"title":"Linux入门","uri":"/linux-intro/"},{"categories":null,"content":"Ubuntu su root # 切换root用户，因为初始root未设置密码，提示错误 sudo passwd # 设置root密码 su root # 切换root用户，设置root密码后可以成功切换 ","date":"2020-08-19","objectID":"/linux-intro/:10:0","tags":["linux"],"title":"Linux入门","uri":"/linux-intro/"},{"categories":null,"content":"什么是精确率（precision）与召回率（recall）？ Precision和Recall是衡量模型预测能力的指标。在简单的分类问题（种类数=2）中，根据实际答案与模型预测，可分为如下4种情况： True Positive (TP) - 正确预测了阳类 True Negative (TN) - 正确预测了阴类 False Positive (FP) - 错误预测了阳类（实际为阴类） False Negative (FN) - 错误预测了阴类（实际为阳类） 注：True和False表示预测是否正确，Positive和Negative表示预测结果 精准率和召回率定义： Precision = TP / (TP + FP) Recall = TP / (TP + FN) 他们区别在分母不同，所取值范围均为0～1 ","date":"2020-08-12","objectID":"/precision-recall/:1:0","tags":["Machine Learning"],"title":"Precision和Recall","uri":"/precision-recall/"},{"categories":null,"content":"如何理解Precision和Recall？ 信息检索中，Precision又叫查准率（找得对），Recall又叫查全率（找得全）。 举个例子，池塘有大龙虾30只，小龙虾70只。我们发明了一只捕大龙虾神器专捕大龙虾。神器一网下去，捕到大龙虾20只，小龙虾5只。那么： 精准率 = 20 /（20 + 5） = 0.80 召回率 = 20 / 30 = 0.67 我们来看3个极端神器的Precision和Recall。 神器谨慎版：只捕了一只，且为大龙虾。Precision = 1/1 = 1.0, Recall = 1/30 = 0.033 神器电鱼版：捕了全池塘的100只。Precision = 30/100 = 0.3, Recall = 30/30 = 1.0 神器专业版：补了30只，且全为大龙虾。Precision = 30/30 = 1.0, Recall = 30/30 = 1.0 实际应用中，Precision和Recall往往不能兼得。有时我们更在意Precision，而有时我们更在意Recall。比如判断视频是否适合儿童观看（适合-正，不适合-负），我们更青睐high precision - low recall的分类器（声称安全的视频真是安全的，但可能也拦截了其他安全的视频）。再比如报警器判断是否有小偷（有小偷-正，无小偷-负），我们更青睐low precision - high recall的警报器（声称有小偷的时候可能是误报，但是真有小偷的时候它通常会响）。 ","date":"2020-08-12","objectID":"/precision-recall/:2:0","tags":["Machine Learning"],"title":"Precision和Recall","uri":"/precision-recall/"},{"categories":null,"content":"PR曲线 机器学习模型往往先预测概率（scoring），再根据概率决策分类（label）。比如score高于threshold输出positive，低于输出negative。这样Precision与Recall将是Threshold的函数，即P(t)和R(t)。如果把P(t)和R(t)作为坐标画在坐标中,就形成了PR曲线，其中(1,1)为理想点。我们可以用PR曲线下的面积（AUPR）来衡量模型表现。 相比于ROC曲线，PR曲线对不平衡数据集的性能描述更为准确。 ","date":"2020-08-12","objectID":"/precision-recall/:3:0","tags":["Machine Learning"],"title":"Precision和Recall","uri":"/precision-recall/"},{"categories":null,"content":"参考 如何解释召回率与精确率？ - 知乎 推荐系统评测指标—准确率(Precision)、召回率(Recall)、F值(F-Measure) ","date":"2020-08-12","objectID":"/precision-recall/:4:0","tags":["Machine Learning"],"title":"Precision和Recall","uri":"/precision-recall/"},{"categories":null,"content":"什么是Cookie ","date":"2020-08-09","objectID":"/cookie-track-user/:1:0","tags":["AdTech"],"title":"网络广告是如何用cookie来追踪用户的？","uri":"/cookie-track-user/"},{"categories":null,"content":"参考 Web客户端追踪(上)-Cookie追踪 网络广告代理商是如何通过 cookie 收集用户信息的？ - LO的回答 - 知乎 RTB广告竞价系统的算法介绍 你是如何被广告跟踪的？ - 巴伐利亚啤酒馆的文章 - 知乎 第一方Cookie和第三方Cookie 第一方Cookie与第三方Cookie的区别 第一方和第三方cookie是什么？ ETP,ITP,NO-TP,是时候把第三方Cookie讲清楚了 ","date":"2020-08-09","objectID":"/cookie-track-user/:2:0","tags":["AdTech"],"title":"网络广告是如何用cookie来追踪用户的？","uri":"/cookie-track-user/"},{"categories":null,"content":"PySpark的特性 Immutable Changes create new object references Old versions are unchanged Lazy Compute does not happen until output is requested ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:1:0","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"Pandas VS PySpark ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:2:0","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"Load CSV # Pandas df = pd.read_csv(\"datafile.csv\") # PySpark df = spark.read.options(header=True, inferSchema=True).csv(\"datafile.csv\") ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:2:1","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"View Dataframe # Pandas df # PySpark df.show() ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:2:2","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"Columns \u0026 Data Types # Pandas df.columns df.dtypes # PySpark df.columns df.dtypes ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:2:3","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"Rename Columns # Pandas df.columns = ['a', 'b', 'c'] df.rename(columns = {'old': 'new'}) # PySpark df.toDF('a', 'b', 'c') df.withColumnRenamed('old', 'new') ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:2:4","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"Drop Columns # Pandas df.drop('colx', axis=1) # PySpark df.drop('colx') ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:2:5","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"Filtering # Pandas df[df.col1 \u003c 20] df[(df.col1 \u003c 20) \u0026 (df.col2 == 6)] # 注意括号 # PySpark df[df.col1 \u003c 20] df[(df.col1 \u003c 20) \u0026 (df.col2 == 6)] # 注意括号 ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:2:6","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"Add Column # Pandas df['col3'] = 1 / df.col1 # 除以0得infty # PySpark df.withColumn('col3', 1 / df.col1) # 除以0得Null ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:2:7","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"Fill Nulls # Pandas df.fillna(0) # more options # PySpark df.fillna(0) ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:2:8","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"Aggregation # Pandas df.groupby(['col1', 'col2']).agg({'col3': 'mean', 'col4': 'min'}) # PySpark df.groupby(['col1', 'col2']).agg({'col3': 'mean', 'col4': 'min'}) ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:2:9","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"标准的转化 # Pandas import numpy as np df['logCol'] = np.log(df.col) # PySpark import pyspark.sql.functions as F df.withColumn('logCol', F.log(df.col)) 使用pyspark.sql.functions里的函数，可以直接调用JVM，即Java引擎，而非使用较慢的python。 例子Row Conditional Statements # Pandas df['status'] = df.apply(lambda r: 1 if r.col1 \u003e 20 else 2 if r.col2 == 6 else 3, axis=1) # PySpark import pyspark.sql.functions as F df.withColumn('status', \\ F.when(df.col1 \u003e 20, 1) \\ .when(df.col2 == 6, 2) \\ .otherwise(3)) ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:3:0","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"更复杂的转化，python必要时 # Pandas df['col5'] = df.col1.apply(lambda x : x + 1) # PySpark import pyspark.sql.functions as F from pyspark.sql.types import DoubleType # udf必须deterministic，pyspark优化默认相同运算结果相同 fn = F.udf(lambda x : x + 1, DoubleType()) df.withColumn('col5', fn(df.col1)) ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:4:0","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"Join # Pandas leftDF.merge(rightDF, on='key') leftDF.merge(rightDF, left_on='a', right_on='b') # PySpark leftDF.join(rightDF, on='key') leftDF.join(rightDF, leftDF.a == rightDF.b) 默认为inner join ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:5:0","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"统计 # Pandas df.describe() # PySpark df.describe().show() df.selectExpr(\"percentile_approx(col1, array(.25, .5, .75)) as col1\").show() ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:6:0","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"统计图 # Pandas df.hist() # PySpark df.sample(False, 0.1).toPandas().hist() ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:7:0","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"SQL # Pandas NA # PySpark df.createOrReplaceTempView('foo') df2 = spark.sql('select * from foo') ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:8:0","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"使用习惯 使用pyspark.sql.functions内置函数。 在cluster中保持和driver相同的版本和库。 观测状态http://localhost:4040/ Learn about SSH port forwarding 不要： Try to iterate through rows Hard code a master in your dirver Use spark-submit for that df.toPandas().head() instead do: df.limit(5).toPandas() 参考 Spark Submit 2017 ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:9:0","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":" The git directory acts as a database for all the changes tracked in Git and the working tree acts as a sandbox where we can edit the current versions of the files. ","date":"2020-07-28","objectID":"/git-github/:0:0","tags":["git"],"title":"Git与Github使用","uri":"/git-github/"},{"categories":null,"content":"1. 基本操作 git init # 创建仓库 # 登陆当前操作系统的用户范围 (否则为项目级别) git config --global user.name \"My Name\" git config --global user.email \"me@example.com\" git status # 显示 working tree, staging area # 创建文件new-file.py git add new-file.py git commit -m \"[message]\" git status # 修改new-file.py git commit -a -m \"[messsage]\" # -a: shortcut of \"git add, git commit\" for the modified git log # 查看提交(当前分支) git log --oneline # 查看提交（简洁显示） git reflog # 查看HEAD曾经经过的commit # throws away unstaged changes, younger commits becomes dangling (can be retrieved via reflog if within days) git reset --hard [commitID] git reset --hard HEAD^^^ # back 3 commits git reset --hard HEAD~[n] # back n commits git diff file.py # compare file.py between work tree and staging area git diff HEAD file.py # compare between work tree and HEAD commit git show commitID # show details (+-) for one specific commit git mv file.py newname.py # rename a file git rm newname.py # remove a file ","date":"2020-07-28","objectID":"/git-github/:1:0","tags":["git"],"title":"Git与Github使用","uri":"/git-github/"},{"categories":null,"content":"2. 分支合并 git branch -v # 查看分支 git branch feature # 创建分支feature git checkout feature # 切换分支feature git checkout -b feature # 创建并切换分支feature git branch -d feature # 删除分支feature # 合并： 切换到接受修改的分支（e.g. master）增加新内容(e.g. feature上的新内容) git checkout master git merge feature # 冲突 # \u003c\u003c\u003c\u003c\u003c\u003c\u003c HEAD # abc (当前分支修改) # ======= # def (并入分支修改) # \u003e\u003e\u003e\u003e\u003e\u003e\u003e feature git add files git commit -m \"conflict resolved, merging -\u003e merged\" ","date":"2020-07-28","objectID":"/git-github/:2:0","tags":["git"],"title":"Git与Github使用","uri":"/git-github/"},{"categories":null,"content":"3. 远程合作 git remote -v # 查看本地保存的远程库地址 git remote add origin https://github.com/[username]/[reponame].git git push origin master git clone https://github.com/[username]/[reponame].git # pull = fetch + merge git fetch origin master git checkout origin/master git merge origin/master git pull origin master # 如果不是基于Github远程库的最新版所做的修改，不能推送，必须先pull # pull后如果进入冲突状态，则解决冲突后即可再推送(git commit, git push) # 跨团队协作 1) fork 2) clone 3) modified 4) pull request ","date":"2020-07-28","objectID":"/git-github/:3:0","tags":["git"],"title":"Git与Github使用","uri":"/git-github/"},{"categories":null,"content":"4. 工作流 Steps: (junior)创建分支feature (junior)推送feature分支 (senior)切换分支，审查代码 (senior)切换master，合并feature (senior)推送master分支 TODO ","date":"2020-07-28","objectID":"/git-github/:4:0","tags":["git"],"title":"Git与Github使用","uri":"/git-github/"},{"categories":null,"content":"撤销 git checkout unstaged.py # revert unstaged changes git reset HEAD staged.py # revert staged changes # overwrite the previous commit with staged changes. # ONLY LOCAL: avoid amending commits that have already been made public git commit --amend git revert HEAD # roll back to previous commit git revert commitID # roll back ","date":"2020-07-28","objectID":"/git-github/:5:0","tags":["git"],"title":"Git与Github使用","uri":"/git-github/"},{"categories":null,"content":"远程 git push # push changes to remote repo “origin” is the default name for the remote repo git remote -v # list remote repos verbosely git remote show origin # describe a single remote repo git branch -r # list remote branches What’s the main difference between git fetch and git pull? git fetch fetches remote updates but doesn’t merge; git pull fetches remote updates and merges. git fetch git log origin/master git merge origin/master # merge into local git remote update will update all of your branches set to track remote ones, but not merge any changes in. git fetch will update only the branch you’re on, but not merge any changes in. git pull will update and merge any remote changes of the current branch you’re on. This would be the one you use to update a local branch. git log --graph --oneline --all git log -p origin/master git push -u origin new-feature # push to \"origin\" remote repo, with \"new-feature\" branch Rebasing instead of merging rewrites history and maintains linearity, making for cleaner code. git checkout new-feature git rebase master git log --graph --oneline git checkout master git merge new-feature # fast forward merge, linear history git push --delete origin new-feature # delete remote branch git branch -d new-feature # delete local branch git fetch git rebase origin/master git add health_checks.py git rebase --continue ","date":"2020-07-28","objectID":"/git-github/:6:0","tags":["git"],"title":"Git与Github使用","uri":"/git-github/"},{"categories":null,"content":"参考 Git scm official Understanding branches in Git CS Visualized: Useful Git Commands - Lydia Hallie What is the difference between ‘git remote update’, ‘git fetch’ and ‘git pull’? Listing and deleting Git commits that are under no branch (dangling?) How can I undo git reset –hard HEAD~1? How do I check out a remote Git branch? ","date":"2020-07-28","objectID":"/git-github/:7:0","tags":["git"],"title":"Git与Github使用","uri":"/git-github/"},{"categories":null,"content":" while位 ","date":"2020-07-26","objectID":"/leetcode-bit-manipulation/:0:0","tags":["leetcode"],"title":"Leetcode：位运算","uri":"/leetcode-bit-manipulation/"},{"categories":null,"content":"342. Power of Four (easy) 简述：判断是否为4的幂 思路：mask挪位置 联系：出自693 # class Solution(object): # def isPowerOfFour(self, num): # \"\"\" # :type num: int # :rtype: bool # \"\"\" # base = 1 while base \u003c= num: # if base == num: # return True # 要点1-1: 偶数位为1 base \u003c\u003c= 2 # return False ","date":"2020-07-26","objectID":"/leetcode-bit-manipulation/:1:0","tags":["leetcode"],"title":"Leetcode：位运算","uri":"/leetcode-bit-manipulation/"},{"categories":null,"content":"476. Number Complement (easy) 简述：将所给数二进制取反输出对应十进制 思路：利用stack 联系：出自342 # class Solution(object): # def findComplement(self, num): # \"\"\" # :type num: int # :rtype: int # \"\"\" # stack = [] # while num: # stack.append(1 ^ (num \u0026 1)) # num = num \u003e\u003e 1 # res = 0 # while stack: res = (res \u003c\u003c 1) + stack.pop() # return res ","date":"2020-07-26","objectID":"/leetcode-bit-manipulation/:2:0","tags":["leetcode"],"title":"Leetcode：位运算","uri":"/leetcode-bit-manipulation/"},{"categories":null,"content":"693. Binary Number with Alternating Bits (easy) 简述：判断所给数二进制是否间隔均不同，即...0101...或者...1010... 思路：while异常退出，逐位判断 联系：342 # class Solution(object): # def hasAlternatingBits(self, n): # \"\"\" # :type n: int # :rtype: bool # \"\"\" # state = n \u0026 1 # while n: # n = n \u003e\u003e 1 # 要点1-1: python位与，位xor if state ^ (n \u0026 1) != 1: # return False # state ^= 1 # return True ","date":"2020-07-26","objectID":"/leetcode-bit-manipulation/:3:0","tags":["leetcode"],"title":"Leetcode：位运算","uri":"/leetcode-bit-manipulation/"},{"categories":null,"content":"477. Total Hamming Distance (medium) 简述：求所有数对hamming距离之和 思路：找出每一位位置上，多少个数为1或为0 联系：342 # class Solution(object): # def totalHammingDistance(self, nums): # \"\"\" # :type nums: List[int] # :rtype: int # \"\"\" # res = 0 # for i in range(32): countZeros = sum([x \u0026 (1\u003c\u003ci) == 0 for x in nums]) res += countZeros * (len(nums) - countZeros) # return res ","date":"2020-07-26","objectID":"/leetcode-bit-manipulation/:4:0","tags":["leetcode"],"title":"Leetcode：位运算","uri":"/leetcode-bit-manipulation/"},{"categories":null,"content":"201. Bitwise AND of Numbers Range (medium) 简述：求区间内所有数位AND值 思路：只要区间跨过1，末位AND值为0，递归求解 联系： # class Solution(object): # def rangeBitwiseAnd(self, m, n): # \"\"\" # :type m: int # :type n: int # :rtype: int # \"\"\" # if m == n: # return m # if n == m + 1: # return m \u0026 n # 要点1-1: 区间跨过1，末位AND值为0，递归 return self.rangeBitwiseAnd(m \u003e\u003e 1, n \u003e\u003e 1) \u003c\u003c 1 与关系 ","date":"2020-07-26","objectID":"/leetcode-bit-manipulation/:5:0","tags":["leetcode"],"title":"Leetcode：位运算","uri":"/leetcode-bit-manipulation/"},{"categories":null,"content":"191. Number of 1 Bits (easy) 简述：求所给数二进制里多少位是1 思路：n \u0026 (n-1)去掉最后一位1 联系： # class Solution(object): # def hammingWeight(self, n): # \"\"\" # :type n: int # :rtype: int # \"\"\" # res = 0 # while n: # n \u0026 (n-1) 去掉最后一位1 n = n \u0026 (n - 1) # res += 1 # return res ","date":"2020-07-26","objectID":"/leetcode-bit-manipulation/:6:0","tags":["leetcode"],"title":"Leetcode：位运算","uri":"/leetcode-bit-manipulation/"},{"categories":null,"content":"231. Power of Two (easy) 简述：判断是否为2的幂 思路：二进制中有且仅有1个1 联系：出自191 # class Solution(object): # def isPowerOfTwo(self, n): # \"\"\" # :type n: int # :rtype: bool # \"\"\" # return n \u0026 (n-1) == 0 and n != 0 ","date":"2020-07-26","objectID":"/leetcode-bit-manipulation/:7:0","tags":["leetcode"],"title":"Leetcode：位运算","uri":"/leetcode-bit-manipulation/"},{"categories":null,"content":"461. Hamming Distance (easy) 简述：求所给数对的hamming distance 思路：先亦或，再数多少个1 联系：出自191 # class Solution(object): # def hammingDistance(self, x, y): # \"\"\" # :type x: int # :type y: int # :rtype: int # \"\"\" num = x ^ y # res = 0 # while num: num = num \u0026 (num - 1) # res += 1 # return res 异或关系 ","date":"2020-07-26","objectID":"/leetcode-bit-manipulation/:8:0","tags":["leetcode"],"title":"Leetcode：位运算","uri":"/leetcode-bit-manipulation/"},{"categories":null,"content":"136. Single Number (easy) 简述：数组中除某元素外每个元素出现两次，找出该元素 思路：碰碰对 联系： # class Solution(object): # def singleNumber(self, nums): # \"\"\" # :type nums: List[int] # :rtype: int # \"\"\" res = 0 # for num in nums: # res ^= num # return res ","date":"2020-07-26","objectID":"/leetcode-bit-manipulation/:9:0","tags":["leetcode"],"title":"Leetcode：位运算","uri":"/leetcode-bit-manipulation/"},{"categories":null,"content":"389. Find the Difference (easy) 简述：字符串shuffle后添加一个字符，找出该字符 思路：碰碰对 联系：出自136 # class Solution(object): # def findTheDifference(self, s, t): # \"\"\" # :type s: str # :type t: str # :rtype: str # \"\"\" # res = 0 # # 要点1-1: python中ord与chr的使用 # for c in s: # res = res ^ ord(c) # for c in t: # res = res ^ ord(c) # return chr(res) ","date":"2020-07-26","objectID":"/leetcode-bit-manipulation/:10:0","tags":["leetcode"],"title":"Leetcode：位运算","uri":"/leetcode-bit-manipulation/"},{"categories":null,"content":" In-Order ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:0:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"230. Kth Smallest Element in a BST (medium) 简述：在BST中，求第k小的值 思路：inorder，记录遍历idx 联系：模板题 # class Solution(object): # def kthSmallest(self, root, k): # \"\"\" # :type root: TreeNode # :type k: int # :rtype: int # \"\"\" # self.idx, self.res = 0, None # self.k = k # self.inorder(root) # return self.res # def inorder(self, root): # if root is None or self.res is not None: # return # if self.res is not None: # return # self.inorder(root.left) # self.idx += 1 # if self.idx == self.k: # self.res = root.val # self.inorder(root.right) ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:1:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"938. Range Sum of BST (easy) 简述：求BST中值介于[L,R]的节点值的和 思路：inorder + 短路判断 联系：出自230 # class Solution(object): # def rangeSumBST(self, root, L, R): # \"\"\" # :type root: TreeNode # :type L: int # :type R: int # :rtype: int # \"\"\" # self.res = 0 # self.L, self.R = L, R # self.inorder(root) # return self.res # def inorder(self, root): # if root is None: # return # self.inorder(root.left) # if self.L \u003c= root.val \u003c= self.R: # self.res += root.val if root.val \u003e self.R: return # self.inorder(root.right) ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:2:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"538. Convert BST to Greater Tree (easy) 简述：改变BST各节点值，使得节点值为后缀和 思路：inorder从后到前遍历 联系：出自230 # class Solution(object): # def convertBST(self, root): # \"\"\" # :type root: TreeNode # :rtype: TreeNode # \"\"\" # self.running_total = 0 # self.inorder(root) # return root # def inorder(self, root): # if root is None: # return None # self.inorder(root.right) root.val += self.running_total self.running_total = root.val # self.inorder(root.left) ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:3:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"501. Find Mode in Binary Search Tree (easy) 简述：求BST中出现最多的值 思路：inorder建立字典 联系：出自230 # class Solution(object): # def findMode(self, root): # \"\"\" # :type root: TreeNode # :rtype: List[int] # \"\"\" # if root is None: # return [] # self.memo = dict() # self.inorder(root) # 要点2-1: python语法，总结value mode = max(self.memo.values()) res = [key for key in self.memo if self.memo[key] == mode] # return res # def inorder(self, root): # if root is None: # return # self.inorder(root.left) # 要点2-2: 异常if用来，初始化key不在字典中的情况 if root.val not in self.memo: self.memo[root.val] = 0 # self.memo[root.val] += 1 # self.inorder(root.right) ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:4:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"530. Minimum Absolute Difference in BST (easy) 简述：在BST节点对中，求最小的相差绝对值 思路：BST的in-order将返回排序数组 联系：出自230 # class Solution(object): # def getMinimumDifference(self, root): # \"\"\" # :type root: TreeNode # :rtype: int # \"\"\" # self.res = sys.maxsize self.prev = None # self.inorder(root) # return self.res # def inorder(self, root): # if root is None: # return # self.inorder(root.left) # if self.prev is not None: # self.res = min(self.res, abs(root.val - self.prev)) # self.prev = root.val # self.inorder(root.right) ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:5:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"783. Minimum Distance Between BST Nodes (easy) 简述：在BST节点对中，求最小的距离（相差） 思路：inorder，记录历史 联系：出自530 # class Solution(object): # def minDiffInBST(self, root): # \"\"\" # :type root: TreeNode # :rtype: int # \"\"\" # self.prev, self.res = None, sys.maxsize # self.inorder(root) # return self.res # def inorder(self, root): # if root is None: # return None # self.inorder(root.left) # if self.prev is not None: # self.res = min(self.res, root.val - self.prev) # self.prev = root.val # self.inorder(root.right) ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:6:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"897. Increasing Order Search Tree (easy) 简述：把BST变为单向链表 思路：记录遍历前的node 联系：出自530 # class Solution(object): # def increasingBST(self, root): # \"\"\" # :type root: TreeNode # :rtype: TreeNode # \"\"\" # self.dummy = TreeNode(0) # self.p = self.dummy # self.inorder(root) # return self.dummy.right # def inorder(self, root): # if root is None: # return # self.inorder(root.left) root.left, self.p.right, self.p.left = None, root, None self.p = self.p.right # self.inorder(root.right) Pre-Order ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:7:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"144. Binary Tree Preorder Traversal (medium) 简述：二叉树pre-order遍历 思路：recursive简单，主要尝试iterative 联系： # class Solution(object): # def preorderTraversal(self, root): # \"\"\" # :type root: TreeNode # :rtype: List[int] # \"\"\" # if root is None: # return [] # 要点1-1: 用stack存待搜索树 stack = [root] # res = [] # while stack: # node = stack.pop() # res.append(node.val) # if node.right is not None: # stack.append(node.right) # if node.left is not None: # stack.append(node.left) # return res ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:8:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"965. Univalued Binary Tree (easy) 简述：判断树中节点值是否单一 思路：遍历时，维护全局变量 联系： # class Solution(object): # def isUnivalTree(self, root): # \"\"\" # :type root: TreeNode # :rtype: bool # \"\"\" # if root.left is None and root.right is None: # return True # self.rootval, self.res = root.val, True # self.preOrder(root) # return self.res # def preOrder(self, root): # \"\"\" # :type root: TreeNode # :rtype: bool # \"\"\" # if root is None: # return # if root.val != self.rootval: # self.res = False # self.preOrder(root.left) # self.preOrder(root.right) Post-Order backtrack ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:9:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"404. Sum of Left Leaves (easy) 简述：求二叉树中，所有左叶节点和 思路：左转向下时标注“左”，右转向下时标注“右” 联系： # class Solution(object): # def sumOfLeftLeaves(self, root): # \"\"\" # :type root: TreeNode # :rtype: int # \"\"\" # self.res = 0 self.inorder(root, False) # return self.res # def inorder(self, root, isLeft): # if root is None: # return # self.inorder(root.left, True) # if root.left is None and root.right is None and isLeft: # self.res += root.val # self.inorder(root.right, False) Non-recursive ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:10:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"510. Inorder Successor in BST II (medium) 简述：给二叉树中某个节点，树中找in-order顺序中的下一个节点（此题节点额外含有：子-\u003e父） 思路：while 联系： # class Solution(object): # def inorderSuccessor(self, node): # \"\"\" # :type node: Node # :rtype: Node # \"\"\" # if node is None: # return None # if node.right: # curr = node.right # while curr.left: # curr = curr.left # return curr # else: # curr = node # while curr.parent and curr == curr.parent.right: # curr = curr.parent # return curr.parent ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:11:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"222. Count Complete Tree Nodes (medium) 简述：complete二叉树 （complete指从上到下，从左到右尽量排满），求树中节点个数 思路：最优复杂度O(logN*logN) 联系：树与二分法很漂亮的结合题 # class Solution(object): # def countNodes(self, root): # \"\"\" # :type root: TreeNode # :rtype: int # \"\"\" # if root is None: # return 0 # height = self.findHeight(root) # res_full = 2**height - 1 # 要点3-1: 二分法模板 # left, right = 1, 2**height # while left + 1 \u003c right: # mid = (left + right) // 2 # if self.pathHasNode(root, height, mid - 1): # left = mid # else: # right = mid # if self.pathHasNode(root, height, right - 1): # return res_full + right # else: # return res_full + left # def findHeight(self, root): # res, p = 0, root # while p.left: # res += 1 # p = p.left # return res # 要点3-2: path encoding def pathHasNode(self, root, height, encoding_int): # p = root # 要点3-3: 构造mask，将encoded path从高位到地位二进制扫描出来 # mask = 2**(height-1) # for _ in range(height): if encoding_int \u0026 mask == 0: # if p.left is None: # return False # p = p.left # else: # if p.right is None: # return False # p = p.right mask \u003e\u003e= 1 # return True ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:12:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"701. Insert into a Binary Search Tree (medium) 简述：将所给值插入BST（假设原BST不含所给值） 思路：用BST性质 联系： # class Solution(object): # def insertIntoBST(self, root, val): # \"\"\" # :type root: TreeNode # :type val: int # :rtype: TreeNode # \"\"\" # 要点1-1：边界情况 if root is None: return TreeNode(val) # p = root # while True: # if val \u003e p.val: # if p.right is None: # p.right = TreeNode(val) # return root # else: # p = p.right # else: # if p.left is None: # p.left = TreeNode(val) # return root # else: # p = p.left ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:13:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"94. Binary Tree Inorder Traversal (medium) 简述：不用递归，in-order遍历二叉树 思路：左子树为优先级 联系：出自510 # class Solution(object): # def inorderTraversal(self, root): # \"\"\" # :type root: TreeNode # :rtype: List[int] # \"\"\" if root is None: return [] dummy = TreeNode(0) dummy.right = root stack = [dummy] inorder = [] while stack: node = stack.pop() if node.right: # 想处理此节点，先把此节点的右子树加入优先级栈 node = node.right while node: stack.append(node) node = node.left if stack: inorder.append(stack[-1].val) return inorder ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:14:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":" Title -- ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:0:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"100. Same Tree (easy) 简述：判断两棵二叉树是否相同 思路：分治法 联系：模板题 # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None # class Solution(object): # def isSameTree(self, p, q): # \"\"\" # :type p: TreeNode # :type q: TreeNode # :rtype: bool # \"\"\" # if p is None and q is None: # return True # if p is None or q is None: # return False return p.val == q.val and \\ self.isSameTree(p.left, q.left) and \\ self.isSameTree(p.right, q.right) ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:1:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"572. Subtree of Another Tree (easy) 简述：判断t是否为s的子树（相同也算子树） 思路：构造isSame()辅助 联系：出自100 # class Solution(object): # def isSubtree(self, s, t): # \"\"\" # :type s: TreeNode # :type t: TreeNode # :rtype: bool # \"\"\" # if s is None: # return False return self.isSame(s, t) or self.isSubtree(s.left, t) or self.isSubtree(s.right, t) # def isSame(self, s, t): # if s is None and t is None: # return True # if s is None or t is None: # return False # return s.val == t.val and \\ # self.isSame(s.left, t.left) and \\ # self.isSame(s.right, t.right) ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:2:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"101. Symmetric Tree (easy) 简述：判断二叉树是否对称 思路：改造为判断两棵树是否对称 联系：出自100 # class Solution(object): # def isSymmetric(self, root): # \"\"\" # :type root: TreeNode # :rtype: bool # \"\"\" # if root is None: # return True # return self._isSymmetric(root.left, root.right) # 要点1-1: 下划线命名helper函数，添加参数 def _isSymmetric(self, r1, r2): # if r1 is None and r2 is None: # return True # if r1 is None or r2 is None: # return False # return r1.val == r2.val and \\ # self._isSymmetric(r1.left, r2.right) and \\ # self._isSymmetric(r1.right, r2.left) ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:3:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"270. Closest Binary Search Tree Value (easy) 简述：在BST里找最接近目标的值 思路：分治 联系：出自100 # class Solution(object): # def closestValue(self, root, target): # \"\"\" # :type root: TreeNode # :type target: float # :rtype: int # \"\"\" # if root.left is None and root.right is None: # return root.val # if target == root.val: # return root.val # if target \u003e root.val: # if root.right is None: # return root.val # tmp_res = self.closestValue(root.right, target) if abs(root.val - target) \u003c= abs(tmp_res - target): # return root.val # else: # return tmp_res # else: # if root.left is None: # return root.val # tmp_res = self.closestValue(root.left, target) if abs(root.val - target) \u003c= abs(tmp_res - target): # return root.val # else: # return tmp_res ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:4:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"104. Maximum Depth of Binary Tree (easy) 简述：求二叉树最大深度, 通常定义如下 （此题按节点数量算深度） I learned that depth and height are properties of a node: The depth of a node is the number of edges from the node to the tree’s root node. A root node will have a depth of 0. The height of a node is the number of edges on the longest path from the node to a leaf. A leaf node will have a height of 0. Properties of a tree: The height of a tree would be the height of its root node, or equivalently, the depth of its deepest node. The diameter (or width) of a tree is the number of nodes on the longest path between any two leaf nodes. The tree below has a diameter of 6 nodes. depth往根（上）数，height往最远的叶（下）数，height等于maxDepth 思路：分治法，也可以遍历法 联系：出自100 # class Solution(object): # def maxDepth(self, root): # \"\"\" # :type root: TreeNode # :rtype: int # \"\"\" # if root is None: # return 0 # return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1 ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:5:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"111. Minimum Depth of Binary Tree (easy) 简述：求二叉树最小深度 思路：分治法 联系：出自104 # class Solution(object): # def minDepth(self, root): # \"\"\" # :type root: TreeNode # :rtype: int # \"\"\" # if root is None: # return 0 if root.left is None and root.right is None: return 1 if root.left is None: return self.minDepth(root.right) + 1 if root.right is None: return self.minDepth(root.left) + 1 # return min(self.minDepth(root.left), self.minDepth(root.right)) + 1 ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:6:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"226. Invert Binary Tree (easy) 简述：左右反转二叉树 思路：分治 联系：出自100 # class Solution(object): # def invertTree(self, root): # \"\"\" # :type root: TreeNode # :rtype: TreeNode # \"\"\" # if root is None: # return None # if root.left is None and root.right is None: # return root root.left, root.right = self.invertTree(root.right), self.invertTree(root.left) # return root ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:7:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"669. Trim a Binary Search Tree (easy) 简述：裁剪BST，使得裁剪后元素位于区间[L, R](R\u003e=L)内 思路：根节点三种情况：\u003cL, \u003eR, LR之间 联系：出自100 # class Solution(object): # def trimBST(self, root, L, R): # \"\"\" # :type root: TreeNode # :type L: int # :type R: int # :rtype: TreeNode # \"\"\" # if root is None: # return None # if root.val \u003c L: # return self.trimBST(root.right, L, R) # if root.val \u003e R: # return self.trimBST(root.left, L, R) root.left, root.right = self.trimBST(root.left, L, R), self.trimBST(root.right, L, R) # return root ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:8:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"110. Balanced Binary Tree (easy) 简述：判断二叉树是否平衡，即每个节点左右子树高度差不超过1 思路：分治+全局变量 联系：出自104 # class Solution(object): # def isBalanced(self, root): # \"\"\" # :type root: TreeNode # :rtype: bool # \"\"\" # 要点2-1: 添加全局变量 self._isBalanced = True # height = self.findHeight(root) # return self._isBalanced # def findHeight(self, root): # 要点2-2: 添加短路判断 if root is None or not self._isBalanced: return 0 # left_height = self.findHeight(root.left) # right_height = self.findHeight(root.right) # if abs(left_height - right_height) \u003e 1: # self._isBalanced = False # return max(left_height, right_height) + 1 ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:9:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"543. Diameter of Binary Tree (easy) 简述：求二叉树的直径，即节点间的最长路径（可不经过根节点） 思路：分治+全局变量 联系：出自110 # class Solution(object): # def diameterOfBinaryTree(self, root): # \"\"\" # :type root: TreeNode # :rtype: int # \"\"\" # 要点1-1: 添加全局变量 self.res = 0 # self.findDepth(root) # return self.res # def findDepth(self, root): # if root is None: # return 0 # left_depth = self.findDepth(root.left) # right_depth = self.findDepth(root.right) self.res = max(self.res, left_depth + right_depth) # return max(left_depth, right_depth) + 1 ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:10:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"124. Binary Tree Maximum Path Sum (hard) 简述：求二叉树中路径最大和（任意节点到任意节点，不必经过根节点） 思路：分治+全局变量 联系：出自110 # class Solution(object): # def maxPathSum(self, root): # \"\"\" # :type root: TreeNode # :rtype: int # \"\"\" # 要点1-1: python最小整数 self.res = -sys.maxsize - 1 # self.maxSumFromRoot(root) # return self.res # def maxSumFromRoot(self, root): # if root is None: # return 0 # if root.left is None and root.right is None: # self.res = max(self.res, root.val) # return root.val # left_max = self.maxSumFromRoot(root.left) # right_max = self.maxSumFromRoot(root.right) self.res = max(self.res, root.val + \\ max(0, left_max, right_max, left_max + right_max)) # return max(root.val, root.val + left_max, root.val + right_max) ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:11:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"257. Binary Tree Paths (easy) 简述：打印二叉树所有根到叶路径 思路：分治 联系：出自100 # class Solution(object): # def binaryTreePaths(self, root): # \"\"\" # :type root: TreeNode # :rtype: List[str] # \"\"\" # if root is None: # return [] # if root.left is None and root.right is None: # return [str(root.val)] # left_paths = self.binaryTreePaths(root.left) # right_paths = self.binaryTreePaths(root.right) # res = [] # res += [str(root.val) + '-\u003e' + p for p in left_paths] # res += [str(root.val) + '-\u003e' + p for p in right_paths] # return res ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:12:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"654. Maximum Binary Tree (medium) 简述：给数组，按规则构造树，规则：数组最大值为根，最大值左边为左子树，最大值右边为右子树，左右子树继续符合规则 思路：递归定义，分治 联系：出自100 # class Solution(object): # def constructMaximumBinaryTree(self, nums): # \"\"\" # :type nums: List[int] # :rtype: TreeNode # \"\"\" # if not nums: # return None # root = TreeNode(max(nums)) # root.left = self.constructMaximumBinaryTree(nums[0:nums.index(max(nums))]) # root.right = self.constructMaximumBinaryTree(nums[nums.index(max(nums))+1:]) # return root ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:13:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"108. Convert Sorted Array to Binary Search Tree (easy) 简述：给已排序的数组，构造相应的平衡BST 思路：中点作为pivot 联系：出自654 # class Solution(object): # def sortedArrayToBST(self, nums): # \"\"\" # :type nums: List[int] # :rtype: TreeNode # \"\"\" # if not nums: # return None # mid = len(nums) // 2 # root = TreeNode(nums[mid]) # root.left = self.sortedArrayToBST(nums[0: mid]) # root.right = self.sortedArrayToBST(nums[mid + 1:]) # return root ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:14:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"606. Construct String from Binary Tree (easy) 简述：按preorder规则通过添加括号把二叉树转为字符串，以保证树与字符串的一一对应。 思路：如果左子树为空，可添加一对空括号 联系：出自654 # class Solution(object): # def tree2str(self, t): # \"\"\" # :type t: TreeNode # :rtype: str # \"\"\" # if t is None: # return \"\" # if t.left is None and t.right is None: # return str(t.val) if t.left is None: return str(t.val) + '()(' + self.tree2str(t.right) + ')' if t.right is None: return str(t.val) + '(' + self.tree2str(t.left) + ')' # return str(t.val) + '(' + self.tree2str(t.left) + ')(' + self.tree2str(t.right) + ')' ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:15:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"1120. Maximum Average Subtree (medium) 简述：求子树中最大平均值 思路：维护平均值，辅助函数返回树的总和与总节点个数 联系：出自110 # class Solution(object): # def maximumAverageSubtree(self, root): # \"\"\" # :type root: TreeNode # :rtype: float # \"\"\" # 要点1-1: 初始为最小浮点数 self.res = float('-inf') # res_cnt, res_sum = self.findSum(root) # return self.res # def findSum(self, root): # if root is None: # return 0, 0 # if root.left is None and root.right is None: # self.res = max(self.res, root.val) # return 1, root.val # left_cnt, left_sum = self.findSum(root.left) # right_cnt, right_sum = self.findSum(root.right) # res_cnt = left_cnt + right_cnt + 1 # res_sum = left_sum + right_sum + root.val # self.res = max(self.res, res_sum * 1.0 / res_cnt) # return res_cnt, res_sum ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:16:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"563. Binary Tree Tilt (easy) 简述：按定义求树的tilt，定义：节点tilt-左子树节点和与右子树节点和差值的绝对值，树的tilt-所有节点tilt的和 思路：辅助函数findSum(), 维护全局变量 联系：出自110 # class Solution(object): # def findTilt(self, root): # \"\"\" # :type root: TreeNode # :rtype: int # \"\"\" # self.res = 0 # total_sum = self.findSum(root) # return self.res # def findSum(self, root): # if root is None: # return 0 # if root.left is None and root.right is None: # return root.val # left_sum, right_sum = self.findSum(root.left), self.findSum(root.right) self.res += abs(left_sum - right_sum) return left_sum + right_sum + root.val ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:17:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"366. Find Leaves of Binary Tree (medium) 简述：二叉树剥洋葱，返回最外层（叶节点），然后次外层（倒数第二层节点），以此类推 思路：标注节点高度，构造节点-\u003e高度映射，再返回反向索引 联系：出自110 # class Solution(object): # def findLeaves(self, root): # \"\"\" # :type root: TreeNode # :rtype: List[List[int]] # \"\"\" # 要点2-1: 全局变量，映射 height_memo = dict() # self.label_height(root, height_memo) # # 要点2-2: 反向索引inverted index return self.convert_memo(height_memo) # def label_height(self, root, height_memo): # if root is None: # return 0 # if root.left is None and root.right is None: # height_memo[root] = 1 # return 1 # left_height = self.label_height(root.left, height_memo) # right_height = self.label_height(root.right, height_memo) # res_height = max(left_height, right_height) + 1 # height_memo[root] = res_height # return res_height # def convert_memo(self, height_memo): # res = dict() # for k, v in height_memo.items(): # if v not in res: # res[v] = list() # res[v].append(k.val) # ans = [] # for i in range(len(res.keys())): # ans.append(res[i + 1]) # return ans ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:18:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"617. Merge Two Binary Trees (easy) 简述：合并两棵二叉树，合并后节点为两棵对应节点之和 思路：分治 联系：出自669 # class Solution(object): # def mergeTrees(self, t1, t2): # \"\"\" # :type t1: TreeNode # :type t2: TreeNode # :rtype: TreeNode # \"\"\" # if t1 is None: # return t2 # if t2 is None: # return t1 # root = TreeNode(t1.val + t2.val) # root.left = self.mergeTrees(t1.left, t2.left) # root.right = self.mergeTrees(t1.right, t2.right) # return root ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:19:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"1490. Clone N-ary Tree (medium) 简述：深拷贝N元树 思路：递归定义，分治 联系：出自100 # class Solution(object): # def cloneTree(self, root): # \"\"\" # :type root: Node # :rtype: Node # \"\"\" # if root is None: # return None # root_copy = Node(val=root.val) # for el in root.children: # root_copy.children.append(self.cloneTree(el)) # return root_copy ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:20:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"814. Binary Tree Pruning (medium) 简述：二叉树树中节点只能为0或1，裁剪二叉树，使得最后没有全为0的子树 思路：分治 联系：出自100 # class Solution(object): # def pruneTree(self, root): # \"\"\" # :type root: TreeNode # :rtype: TreeNode # \"\"\" # if root is None: # return None # if root.left is None and root.right is None: # if root.val == 0: # return None # else: # return root # left_pruned = self.pruneTree(root.left) # right_pruned = self.pruneTree(root.right) if left_pruned is None and right_pruned is None and root.val == 0: return None # root.left, root.right = left_pruned, right_pruned # return root ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:21:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"236. Lowest Common Ancestor of a Binary Tree (medium) 简述：求两节点在二叉树里的LCA（假设两节点都在树中） 思路：分治 联系：出自100 # class Solution(object): # 要点1-1: 三种情况：1）两个节点都在树中返回lca， 2）一个在树中返回该节点，3）两个都不在返回None def lowestCommonAncestor(self, root, p, q): # \"\"\" # :type root: TreeNode # :type p: TreeNode # :type q: TreeNode # :rtype: TreeNode # \"\"\" # if root is None: # return None # if root == p or root == q: # return root # left_lca = self.lowestCommonAncestor(root.left, p, q) # right_lca = self.lowestCommonAncestor(root.right, p, q) # if left_lca and right_lca: # return root # if left_lca: # return left_lca # if right_lca: # return right_lca # return None ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:22:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"235. Lowest Common Ancestor of a Binary Search Tree (easy) 简述：求两节点在BST里的LCA（假设两节点都在树中） 思路：分治，根据情况走一边子树 联系：出自236 # class Solution(object): # def lowestCommonAncestor(self, root, p, q): # \"\"\" # :type root: TreeNode # :type p: TreeNode # :type q: TreeNode # :rtype: TreeNode # \"\"\" # if root is None: # return None # if root == p or root == q: # return root # if p.val \u003c root.val \u003c q.val or q.val \u003c root.val \u003c p.val: # return root # if root.val \u003c p.val: # return self.lowestCommonAncestor(root.right, p, q) # else: # return self.lowestCommonAncestor(root.left, p, q) ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:23:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"156. Binary Tree Upside Down (medium) 简述：上下翻转二叉树，所给二叉树的性质：右节点是空或是有兄弟节点的叶节点 思路：画图按例子翻转 联系：出自226 # class Solution(object): # def upsideDownBinaryTree(self, root): # \"\"\" # :type root: TreeNode # :rtype: TreeNode # \"\"\" # if root is None: # return None # if root.left is None and root.right is None: # return root # res = self.upsideDownBinaryTree(root.left) root.left.left, root.left.right = root.right, root # root.left, root.right = None, None # return res ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:24:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"114. Flatten Binary Tree to Linked List (medium) 简述：in-place转化二叉树成链表结构 思路：分治 联系：出自226 # class Solution(object): # def flatten(self, root): # \"\"\" # :type root: TreeNode # :rtype: None Do not return anything, modify root in-place instead. # \"\"\" # tail = self.flatten_tail(root) # def flatten_tail(self, root): # if root is None: # return None # if root.left is None and root.right is None: # return root # if root.left is None: # return self.flatten_tail(root.right) # if root.right is None: # left_tail = self.flatten_tail(root.left) # root.left, root.right = None, root.left # return left_tail # left_tail = self.flatten_tail(root.left) # right_tail = self.flatten_tail(root.right) # root.left, root.right, left_tail.right = None, root.left, root.right # return right_tail VERSION II (from girikuncoro’s post) # class Solution(object): # def __init__(self): self.prev = None # def flatten(self, root): # \"\"\" # :type root: TreeNode # :rtype: None Do not return anything, modify root in-place instead. # \"\"\" # if root is None: # return # self.flatten(root.right) # self.flatten(root.left) # # 要点1-1: 先右子树再左子树，这样会把右子树通过prev移花接木到左子树尾部 root.right = self.prev # root.left = None # self.prev = root ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:25:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"298. Binary Tree Longest Consecutive Sequence (medium) 简述：在二叉树中找连续值路径（路径这里指从父节点向下） 思路：分治，维护全局变量 联系：出自110 # class Solution(object): # def longestConsecutive(self, root): # \"\"\" # :type root: TreeNode # :rtype: int # \"\"\" # self.res = 0 # self.longest_from_root(root) # return self.res # def longest_from_root(self, root): # if root is None: # return 0 # if root.left is None and root.right is None: # self.res = max(self.res, 1) # return 1 # 要点1-1: 无论当前节点与左右子节点是否差1，都要执行搜索 left_longest = self.longest_from_root(root.left) right_longest = self.longest_from_root(root.right) # curr = 1 # if root.left and root.val + 1 == root.left.val: # curr = max(curr, left_longest + 1) # if root.right and root.val + 1 == root.right.val: # curr = max(curr, right_longest + 1) # self.res = max(self.res, curr) # return curr ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:26:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"285. Inorder Successor in BST (medium) 简述：BST中找所给节点的下一个按序节点，即比所给节点大的最小节点 思路：分治 联系：出自100 # class Solution(object): # def inorderSuccessor(self, root, p): # \"\"\" # :type root: TreeNode # :type p: TreeNode # :rtype: TreeNode # \"\"\" # if root is None: # return None # if p.val \u003e= root.val: # return self.inorderSuccessor(root.right, p) # left_res = self.inorderSuccessor(root.left, p) # if left_res is None: # return root # return left_res ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:27:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"671. Second Minimum Node In a Binary Tree (easy) 简述：二叉树满足：每个节点有0或2个子节点，当2个子节点时，root.val = min(root.left.val, root.right.val)，求树中第二小的节点值 思路：分治，注意比较时的初始化 联系：出自100 # class Solution(object): # def findSecondMinimumValue(self, root): # \"\"\" # :type root: TreeNode # :rtype: int # \"\"\" # if root is None: # return -1 # if root.left is None and root.right is None: # return -1 # left_res = self.findSecondMinimumValue(root.left) # right_res = self.findSecondMinimumValue(root.right) # 要点1-1: 初始化比较值，题目要求无第二最小值，返回-1 if left_res == -1: left_res = sys.maxsize if right_res == -1: right_res = sys.maxsize # if root.val == root.left.val == root.right.val: res = min(left_res, right_res) return res if res != sys.maxsize else -1 # else: # if root.val == root.left.val: # return min(left_res, root.right.val) # else: # return min(right_res, root.left.val) ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:28:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"模板 # def binarySearch(nums, target): # if len(nums) == 0: # return -1 # start, end = 0, len(nums) - 1 while start + 1 \u003c end: # 要点3-1 mid = (start + end) // 2 # 要点3-2: python动态数据类型 # if nums[start] \u003c target: start = mid # 要点3-3: mid不+-1 # else: # end = mid # if nums[start] == target: # return start # if nums[end] == target: # return end # return -1 找位置 ","date":"2020-07-07","objectID":"/leetcode-binary-search/:0:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"34. Find First and Last Position of Element in Sorted Array (medium) 简述：已排序数组，求目标值第一次和最后一次出现的位置 思路：拆解为两个子函数，findFirst()和findLast() 联系：基础模板题 # class Solution(object): # def searchRange(self, nums, target): # \"\"\" # :type nums: List[int] # :type target: int # :rtype: List[int] # \"\"\" # first, last = self.findFirst(nums, target), self.findLast(nums, target) # return [first, last] # def findFirst(self, nums, target): # if len(nums) == 0: # return -1 # left, right = 0, len(nums) - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 if nums[mid] \u003c target: # 要点2-1 # left = mid # else: # right = mid # if nums[left] == target: # return left # if nums[right] == target: # return right # return -1 # def findLast(self, nums, target): # if len(nums) == 0: # return -1 # left, right = 0, len(nums) - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 if nums[mid] \u003e target: # 要点2-2 # right = mid # else: # left = mid # if nums[right] == target: # return right # if nums[left] == target: # return left # return -1 ","date":"2020-07-07","objectID":"/leetcode-binary-search/:1:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"35. Search Insert Position (easy) 简述：已排序数组，求插入位置保证插入后依然排序 思路：类似findFirst() 联系：出自34 # class Solution(object): # def searchInsert(self, nums, target): # \"\"\" # :type nums: List[int] # :type target: int # :rtype: int # \"\"\" # # 要点1-1: 注意输入边界情况 if target \u003c nums[0]: return 0 if target \u003e nums[-1]: return len(nums) # left, right = 0, len(nums) - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 # if nums[mid] \u003c target: # left = mid # else: # right = mid # if nums[left] \u003e= target: # return left # return right ","date":"2020-07-07","objectID":"/leetcode-binary-search/:2:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"744. Find Smallest Letter Greater Than Target (easy) 简述：已排序的数组，求大于目标的最前位置 思路：类似findFirst() 联系：出自34 # class Solution(object): # def nextGreatestLetter(self, letters, target): # \"\"\" # :type letters: List[str] # :type target: str # :rtype: str # \"\"\" # left, right = 0, len(letters) - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 # if letters[mid] \u003c= target: # left = mid # else: # right = mid # if letters[left] \u003e target: # return letters[left] # if letters[right] \u003e target: # return letters[right] # return letters[0] ","date":"2020-07-07","objectID":"/leetcode-binary-search/:3:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"702. Search in a Sorted Array of Unknown Size (medium) 简述：已排序数组，但不知size，求目标值位置 思路：扩右边直到包含目标值，再二分 联系：出自34 # class Solution(object): # def search(self, reader, target): # \"\"\" # :type reader: ArrayReader # :type target: int # :rtype: int # \"\"\" # # 要点1-1: 倍增右边界 right = 1 while reader.get(right) \u003c target: right *= 2 left = right // 2 # while left + 1 \u003c right: # mid = (left + right) // 2 # if reader.get(mid) == target: # return mid # if reader.get(mid) \u003c target: # left = mid # else: # right = mid # if reader.get(left) == target: # return left # if reader.get(right) == target: # return right # return -1 ","date":"2020-07-07","objectID":"/leetcode-binary-search/:4:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"74. Search a 2D Matrix (medium) 简述：已排序的2D数组(每行排序，一行最后元素小于下行最前元素)，求目标值是否存在 思路：只是1D数组layout变化，模板不变 联系：出自34 # class Solution(object): # def searchMatrix(self, matrix, target): # \"\"\" # :type matrix: List[List[int]] # :type target: int # :rtype: bool # \"\"\" # if not matrix or not matrix[0]: # return False # M, N = len(matrix), len(matrix[0]) # left, right = 0, M * N - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 # row, col = mid // N, mid % N # if matrix[row][col] == target: # return True # if matrix[row][col] \u003c target: # left = mid # else: # right = mid # return matrix[left//N][left%N] == target or matrix[right//N][right%N] == target ","date":"2020-07-07","objectID":"/leetcode-binary-search/:5:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"240. Search a 2D Matrix II (medium) 简述：已排序的2D数组(每行排序，每列排序)，求目标值是否存在 思路：斜对角线一个个坐标走，不是二分题 联系：出自74，不是二分 # class Solution(object): # def searchMatrix(self, matrix, target): # \"\"\" # :type matrix: List[List[int]] # :type target: int # :rtype: bool # \"\"\" # if not matrix or not matrix[0]: # return False # M, N = len(matrix), len(matrix[0]) # x, y = M - 1, 0 # while True: # if not (0 \u003c= x \u003c M and 0 \u003c= y \u003c N): # return False # if matrix[x][y] == target: # return True # # 要点1-1: 不是二分，走坐标 if matrix[x][y] \u003e target: x -= 1 else: y += 1 # return False ","date":"2020-07-07","objectID":"/leetcode-binary-search/:6:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"658. Find K Closest Elements (medium) 简述：已排序数组，求k个最邻近目标的元素们 思路：先找到最邻近目标的元素，再往两边扩展 联系：出自34 # class Solution(object): # def findClosestElements(self, arr, k, x): # \"\"\" # :type arr: List[int] # :type k: int # :type x: int # :rtype: List[int] # \"\"\" # left, right = 0, len(arr) - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 # if arr[mid] \u003c x: # left = mid # else: # right = mid # # 要点1-1: 最后的范围左右开区间(left, right) return self.expand(arr, left, right, k, x) # def expand(self, arr, left, right, k, x): # cnt = 0 # while cnt \u003c k: # if right \u003e= len(arr) or abs(arr[left] - x) \u003c= abs(arr[right] - x): # left -= 1 # else: # right += 1 # cnt += 1 return arr[left + 1 : left + 1 + k] 非单调 ","date":"2020-07-07","objectID":"/leetcode-binary-search/:7:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"153. Find Minimum in Rotated Sorted Array (medium) 简述：rotate过的排序数组(无重复元素)，求最小值 思路：pivot出现在前半段，经过顺序为 中\u003c右\u003c左，pivot出现在后半段，经过顺序为 右\u003c左\u003c中 联系：左右关系无法判断, 应判断中右关系 # class Solution(object): # def findMin(self, nums): # \"\"\" # :type nums: List[int] # :rtype: int # \"\"\" # left, right = 0, len(nums) - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 if nums[mid] \u003e nums[right]: # left = mid # else: # right = mid # return min(nums[left], nums[right]) ","date":"2020-07-07","objectID":"/leetcode-binary-search/:8:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"33. Search in Rotated Sorted Array (medium) 简述：rotate过的排序数组(无重复元素)，求目标值位置 思路：先找pivot，再传统二分 联系：出自153 # class Solution(object): # def search(self, nums, target): # \"\"\" # :type nums: List[int] # :type target: int # :rtype: int # \"\"\" # if len(nums) == 0: # return -1 # pivot = self.findPivot(nums) # L = len(nums) # left, right = 0, L - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 # # 要点1-1: 访问排序数组时转化坐标 if nums[(mid + pivot) % L] \u003e target: # right = mid # else: # left = mid # if nums[(left + pivot) % L] == target: # return (left + pivot) % L # if nums[(right + pivot) % L] == target: # return (right + pivot) % L # return -1 def findPivot(self, nums): # left, right = 0, len(nums) - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 # if nums[mid] \u003e nums[right]: # left = mid # else: # right = mid # if nums[left] \u003c nums[right]: # return left # else: # return right ","date":"2020-07-07","objectID":"/leetcode-binary-search/:9:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"154. Find Minimum in Rotated Sorted Array II (hard) 简述：rotate过的排序数组(有重复元素)，求最小元素 思路：11111011 (最坏情况linear查找) 联系：出自33 # class Solution(object): # def findMin(self, nums): # \"\"\" # :type nums: List[int] # :rtype: int # \"\"\" # left, right = 0, len(nums) - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 # if nums[right] \u003e nums[mid]: # right = mid # elif nums[right] \u003c nums[mid]: # left = mid else: # 要点1-1: 如何把线性查找与二分查找合并 right = right - 1 # return min(nums[left], nums[right]) ","date":"2020-07-07","objectID":"/leetcode-binary-search/:10:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"852. Peak Index in a Mountain Array (easy) 简述：山形数组，求山峰位置 思路：思考山峰若在前半段发生什么(A[mid-1] \u003e A[mid] \u003e A[mid+1])，若在后半段发生什么(A[mid-1] \u003c A[mid] \u003c A[mid+1]) 联系：思考方式出自153，都是在想目标出现前后半段的性质差别，二分保证充要 # class Solution(object): # def peakIndexInMountainArray(self, A): # \"\"\" # :type A: List[int] # :rtype: int # \"\"\" # left, right = 0, len(A) - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 # if A[mid] \u003e A[mid+1] and A[mid] \u003e A[mid-1]: # return mid # if A[mid] \u003e A[mid+1] and A[mid] \u003c A[mid-1]: # right = mid # else: # left = mid # if A[left] \u003e A[right]: # return left # else: # return right ","date":"2020-07-07","objectID":"/leetcode-binary-search/:11:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"162. Find Peak Element (medium) 简述：重峦叠嶂数组(相邻不等)，求任意一个山峰位置 思路：类似852，但并不充要 # class Solution(object): # def findPeakElement(self, nums): # \"\"\" # :type nums: List[int] # :rtype: int # \"\"\" # left, right = 0, len(nums) - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 # if nums[mid] \u003e nums[mid - 1] and nums[mid] \u003e nums[mid + 1]: # return mid # if nums[mid] \u003e nums[mid - 1] and nums[mid] \u003c nums[mid + 1]: # left = mid # else: # right = mid # if nums[left] \u003e nums[right]: # return left # else: # return right 找状态 ","date":"2020-07-07","objectID":"/leetcode-binary-search/:12:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"278. First Bad Version (easy) 简述：OOOOXXX, 求第一个失败版本idx 思路：目标出现前后半段导致mid状态差别 联系： # # The isBadVersion API is already defined for you. # # @param version, an integer # # @return a bool # # def isBadVersion(version): # class Solution(object): # def firstBadVersion(self, n): # \"\"\" # :type n: int # :rtype: int # \"\"\" # left, right = 1, n # while left + 1 \u003c right: # mid = (left + right) // 2 # if isBadVersion(mid): # right = mid # else: # left = mid # if isBadVersion(left): # return left # return right ","date":"2020-07-07","objectID":"/leetcode-binary-search/:13:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"374. Guess Number Higher or Lower (easy) 简述：1-n猜数字，api回答高低，求目标数字 思路：从目标开始后面都会猜高 联系：出自278 # # The guess API is already defined for you. # # @param num, your guess # # @return -1 if my number is lower, 1 if my number is higher, otherwise return 0 # # def guess(num): # class Solution(object): # def guessNumber(self, n): # \"\"\" # :type n: int # :rtype: int # \"\"\" # left, right = 1, n # while left + 1 \u003c right: # mid = (left + right) // 2 # api_res = guess(mid) # if api_res == 0: # return mid # if api_res == 1: # left = mid # else: # right = mid # return left if guess(left) == 0 else right ","date":"2020-07-07","objectID":"/leetcode-binary-search/:14:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"69. Sqrt(x) (easy) 简述：求根号x，取整 思路：从正确答案后，平方大于x 联系：出自278 # class Solution(object): # def mySqrt(self, x): # \"\"\" # :type x: int # :rtype: int # \"\"\" # left, right = 1, x # while left + 1 \u003c right: # mid = (left + right) // 2 # if mid * mid == x: # return mid # if mid * mid \u003e x: # right = mid # else: # left = mid # return right if right * right \u003c= x else left ","date":"2020-07-07","objectID":"/leetcode-binary-search/:15:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"302. Smallest Rectangle Enclosing Black Pixels (hard) 简述：二值化图片，黑色像素相连，给一个黑色像素坐标，求包围黑色区域的最小矩形面积 思路：从黑色坐标向上下左右找边界，一旦超过边界将再无黑色行列 联系：出自278 # class Solution(object): # def minArea(self, image, x, y): # \"\"\" # :type image: List[List[str]] # :type x: int # :type y: int # :rtype: int # \"\"\" # m, n = len(image), len(image[0]) # def row_has_black(row): # for j in range(n): # if image[row][j] == '1': # return True # return False # def col_has_black(col): # for i in range(m): # if image[i][col] == '1': # return True # return False def find_upper(): # left, right = 0, x # while left + 1 \u003c right: # mid = (left + right) // 2 # if row_has_black(mid): # right = mid # else: # left = mid # if row_has_black(left): # return left # return right def find_lower(): # left, right = x, m - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 # if row_has_black(mid): # left = mid # else: # right = mid # if row_has_black(right): # return right # return left def find_left(): # left, right = 0, y # while left + 1 \u003c right: # mid = (left + right) // 2 # if col_has_black(mid): # right = mid # else: # left = mid # if col_has_black(left): # return left # return right def find_right(): # left, right = y, n - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 # if col_has_black(mid): # left = mid # else: # right = mid # if col_has_black(right): # return right # return left # upper, lower, left, right = find_upper(), find_lower(), find_left(), find_right() return (lower - upper + 1) * (right - left + 1) 二分答案 ","date":"2020-07-07","objectID":"/leetcode-binary-search/:16:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"274. H-Index (medium) 简述：引用数组，求hIndex–h篇每篇至少h引用，其余每篇不超过h引用 思路：二分答案，答案经过一次状态改变 联系： # class Solution(object): # def hIndex(self, citations): # \"\"\" # :type citations: List[int] # :rtype: int # \"\"\" # if not citations: # return 0 # left, right = 0, len(citations) # while left + 1 \u003c right: # h = (left + right) // 2 cnt = sum([x \u003e= h for x in citations]) # if cnt == h: # return h # if cnt \u003e h: # left = h # else: # right = h # cnt = sum([x \u003e= right for x in citations]) # if cnt \u003e= right: # return right # return left ","date":"2020-07-07","objectID":"/leetcode-binary-search/:17:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"275. H-Index II (hard) 简述：引用数组(已排序)，求hIndex–h篇每篇至少h引用，其余每篇不超过h引用 思路：不是二分答案，注意结尾情况 联系：出自274，但不属于二分答案 # class Solution(object): # def hIndex(self, citations): # \"\"\" # :type citations: List[int] # :rtype: int # \"\"\" # if not citations: # return 0 # N = len(citations) # left, right = 0, N - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 # if N - mid \u003e= citations[mid]: # left = mid # else: # right = mid # 要点1-1: 结尾情况很难想全 if N - right \u003e= citations[right]: return citations[right] if N - right \u003e= citations[left]: return N - right if N - left \u003e= citations[left]: return citations[left] return N - left ","date":"2020-07-07","objectID":"/leetcode-binary-search/:18:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"Coursera specializations offered by UM Course I Time Value of Money ","date":"2020-07-06","objectID":"/coursera-umich-fffsdm/:0:0","tags":null,"title":"Foundational Finance for Strategic Decision Making","uri":"/coursera-umich-fffsdm/"},{"categories":null,"content":"Simple Future Value (FV) PV = Present Value (unit: $) FV = Present Value (unit: $) n = # of Periods (#) r = Interest Rate (%, not $) \u003e 0 (assumption) Insight: A dollar today is worth more than a dollar tomorrow. You cannot compare money across time. Example: Power of Compounding! Peter Minuit bought the Manhattan Island from Native Americans for $24 in 1626. Suppose that Native Americans could have earned 6% on their investments all these years. How much would they have today (year 2020)? $224,244,683,837.58 Some Important Formulae Future Value of a Single Cash Flow Invested for n Periods $$F = P(1+r)^n$$ Present Value of a Single Cash Flow Received n Periods from Now $$P = F\\frac{1}{(1+r)^n}$$ Future Value of a Stream of Cash Flows as of n Periods from Now $$F = C_1(1+r)^{n-1} + C_2(1+r)^{n-2} + \\cdots + C_{n-1}(1+r) + C_n$$ Present Value of a Stream of Cash Flows $$P = \\frac{C_1}{1+r} + \\frac{C_2}{(1+r)^2} + \\cdots + \\frac{C_n}{(1+r)^n}$$ ","date":"2020-07-06","objectID":"/coursera-umich-fffsdm/:1:0","tags":null,"title":"Foundational Finance for Strategic Decision Making","uri":"/coursera-umich-fffsdm/"},{"categories":null,"content":"Hugo: 一个静态网页生成器，将markdown格式的博文编译为HTML，CSS，JavaScript Github Pages: 静态网页托管服务，将hugo转化后的博客公开给读者访问 reference: Mogeko博客《使用 Hugo + GitHub Pages 搭建个人博客》 ","date":"2020-07-03","objectID":"/hugo-blog-site/:0:0","tags":null,"title":"使用 Hugo + Github Pages 搭建个人博客","uri":"/hugo-blog-site/"},{"categories":null,"content":"Step 1 - 创建Github Pages对应的repo repo name: [username].github.io reference: Github Pages official page ","date":"2020-07-03","objectID":"/hugo-blog-site/:1:0","tags":null,"title":"使用 Hugo + Github Pages 搭建个人博客","uri":"/hugo-blog-site/"},{"categories":null,"content":"Step 2 - 安装Hugo (Mac系统) brew install hugo reference: Hugo official quickstart ","date":"2020-07-03","objectID":"/hugo-blog-site/:2:0","tags":null,"title":"使用 Hugo + Github Pages 搭建个人博客","uri":"/hugo-blog-site/"},{"categories":null,"content":"Step 3 - 使用Hugo创建本地博客文件夹 hugo new site myBlog cd myBlog 创建myBlog文件夹来存放博客站点。其中： content存放markdown博文 themes存放皮肤主题 config.toml配置站点 ","date":"2020-07-03","objectID":"/hugo-blog-site/:3:0","tags":null,"title":"使用 Hugo + Github Pages 搭建个人博客","uri":"/hugo-blog-site/"},{"categories":null,"content":"Step 4 - 安装皮肤主题 此博客使用mogege主题，原repo 安装主题至themes下 git clone https://github.com/Mogeko/mogege.git themes/mogege ","date":"2020-07-03","objectID":"/hugo-blog-site/:4:0","tags":null,"title":"使用 Hugo + Github Pages 搭建个人博客","uri":"/hugo-blog-site/"},{"categories":null,"content":"Step 5 - 创建页面 hugo new about.md hugo new posts/my-first-post.md 在content下自动生成页面，meta data包括： title: 页面标题 date: 创建时间 draft: 是否为草稿。建立server时，草稿需要加上--buildDrafts参数才能在public正确显示 description: 描述 (optional) tags:: 标签，用于文章分类 (optional) ","date":"2020-07-03","objectID":"/hugo-blog-site/:5:0","tags":null,"title":"使用 Hugo + Github Pages 搭建个人博客","uri":"/hugo-blog-site/"},{"categories":null,"content":"Step 6 - 配置网站 修改配置文件config.toml baseURL = \"https://xuwenzhe.github.io\" # \u003chead\u003e 里面的 baseurl 信息，填你的博客地址 title = \"Wenzhe's Blog\" # 浏览器的标题 languageCode = \"zh-cn\" # 语言 hasCJKLanguage = true # 开启可以让「字数统计」统计汉字 theme = \"mogege\" # 主题 (需要自己下载) paginate = 11 # 每页的文章数 enableEmoji = true # 支持 Emoji enableRobotsTXT = true # 支持 robots.txt googleAnalytics = \"\" # Google 统计 id preserveTaxonomyNames = true [blackfriday] hrefTargetBlank = true nofollowLinks = true noreferrerLinks = true [Permalinks] posts = \"/:year/:filename/\" [menu] [[menu.main]] name = \"Blog\" url = \"/posts/\" weight = 1 [[menu.main]] name = \"Categories\" url = \"/categories/\" weight = 2 [[menu.main]] name = \"Tags\" url = \"/tags/\" weight = 3 [[menu.main]] name = \"About\" url = \"/about/\" weight = 4 [params] since = 2020 author = \"Wenzhe\" # Author's name avatar = \"/images/me/avatar.png\" # Author's avatar subtitle = \"Just for Fun\" # Subtitle cdn_url = \"\" # Base CDN URL home_mode = \"\" # post or other enableGitalk = true # gitalk 评论系统 google_verification = \"\" description = \"\" # (Meta) 描述 keywords = \"\" # site keywords beian = \"\" baiduAnalytics = \"\" license= '本文采用\u003ca rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003e知识共享署名-非商业性使用 4.0 国际许可协议\u003c/a\u003e进行许可' [params.social] GitHub = \"https://github.com/xuwenzhe\" Twitter = \"xxoo\" Email = \"xxoo\" Instagram = \"xxoo\" Wechat = \"/images/me/wechat.png\" # Wechat QRcode image Facebook = \"xxoo\" Telegram = \"xxoo\" Dribbble = \"xxoo\" Medium = \"xxoo\" [params.gitalk] # Github: https://github.com/gitalk/gitalk clientID = \"\" # Your client ID clientSecret = \"\" # Your client secret repo = \"\" # The repo to store comments owner = \"\" # Your GitHub ID admin= \"\" # Required. Github repository owner and collaborators. (Users who having write access to this repository) id= \"location.pathname\" # The unique id of the page. labels= \"gitalk\" # Github issue labels. If you used to use Gitment, you can change it perPage= 15 # Pagination size, with maximum 100. pagerDirection= \"last\" # Comment sorting direction, available values are 'last' and 'first'. createIssueManually= false # If it is 'false', it is auto to make a Github issue when the administrators login. distractionFreeMode= false # Enable hot key (cmd|ctrl + enter) submit comment. ","date":"2020-07-03","objectID":"/hugo-blog-site/:6:0","tags":null,"title":"使用 Hugo + Github Pages 搭建个人博客","uri":"/hugo-blog-site/"},{"categories":null,"content":"Step 7 - 本地预览 hugo server --buildDrafts -w --buildDrafts: 生成draft博文 -w: 监控修改，自动更新修改过的站点 此时，在http://localhost:1313已经可以访问到博客啦 ","date":"2020-07-03","objectID":"/hugo-blog-site/:7:0","tags":null,"title":"使用 Hugo + Github Pages 搭建个人博客","uri":"/hugo-blog-site/"},{"categories":null,"content":"Step 8 - 编译发布 在myBlog文件夹中编译 hugo 此时，编译后的静态文件会存放在public文件夹 cd public # 进入public文件夹 git init # 建立本地git仓库 git remote add origin https://github.com/[username]/[username].github.io.git # 关联 git add . # add git commit -m \"[commit message]\" # commit git push -u origin master # push 之后发布新博文可以在public直接执行后三条命令add,commit,push即可。 记得draft改为false ","date":"2020-07-03","objectID":"/hugo-blog-site/:8:0","tags":null,"title":"使用 Hugo + Github Pages 搭建个人博客","uri":"/hugo-blog-site/"},{"categories":null,"content":"this is wenzhe’s about ","date":"2020-07-02","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"}]