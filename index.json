[{"categories":null,"content":"1. 类和对象 ","date":"2021-04-03","objectID":"/java-shk-3/:1:0","tags":["Java"],"title":"Java零基础教程（三.面向对象-封装Encapsulation）","uri":"/java-shk-3/"},{"categories":null,"content":"1.1 面向对象的思想 package com.atguigu.java; /* * 一· Java面向对象学习的三条主线 * 1. Java类及类的成员：属性，方法，构造器，代码块，内部类 * 2. 面向对象的三大特征：封装性，继承性，多态性，（抽象性） * 3. 其他关键字：this, super, static, final, abstract, interface, package, import等 * * 二·“人把大象装进冰箱” * 1. 面向对象：强调的是功能行为，以函数为最小单位，考虑怎么做。 * 1）把冰箱门打开 * 2）抬起大象，塞进冰箱 * 3）把冰箱门关闭 * 2. 面向对象：强调具备了功能的对象，以类/对象为最小单位，考虑[谁]来做。 * 人 { * 打开(冰箱) { * 冰箱.开开(); * } * 抬起(大象) { * 大象.进入(冰箱); * } * 关闭(冰箱) { * 冰箱.闭合(); * } * } * * 冰箱 { * 开开(){} * 闭合(){} * } * * 大象 { * 进入(冰箱){} * } * 程序员从面向过程的执行者转化成了面向对象的指挥者 * * 三·面向对象的两个要素 * 类：对一类事物的描述，是抽象的，概念上的定义 * 对象：是实际存在的该类事物的每个个体，因而也称为实例（instance） * \u003e 面向对象程序设计的重点是类的设计 * \u003e 设计类，就是设计类的成员 */ public class OOPTest { public static void main(String[] args) { // TODO Auto-generated method stub } } ","date":"2021-04-03","objectID":"/java-shk-3/:1:1","tags":["Java"],"title":"Java零基础教程（三.面向对象-封装Encapsulation）","uri":"/java-shk-3/"},{"categories":null,"content":"1.2 类的属性和方法 package com.atguigu.java; /* * 一·设计类，其实就是设计类的成员 * * 属性 = 成员变量 = field * 方法 = 成员方法 = 函数 = method * * 创建类的对象 = 类的实例化 * * 二·类和对象的使用（面向对象思想落地） * 1. 创建类，设计类的成员 * 2. 创建类的对象 * 3. 通过“对象.属性”或“对象.方法”调用对象的结构 * * 三·如果创建了一个类的多个对象，则每个对象都独立的拥有一套类的属性（非static） * 意味着：如果我们修改一个对象的属性a，则不影响另外一个对象属性a的值。 */ // 测试类 public class PersonTest { public static void main(String[] args) { // TODO Auto-generated method stub // 2. 创建Person类的对象 Person p1 = new Person(); // Scanner scanner = new Scanner(System.in); // 调用对象的结构：属性，方法 // 调用属性： “对象.属性” p1.name = \"Tom\"; p1.isMale = true; System.out.println(p1.name); // 调用方法：“对象.方法” p1.eat(); p1.sleep(); p1.talk(\"Chinese\"); // ******************************** Person p2 = new Person(); System.out.println(p2.name);// null System.out.println(p2.isMale);// false // ******************************** // 将p1变量保存的对象地址值赋给p3，导致p1和p3指向了堆空间的同一个对象实体 Person p3 = p1; System.out.println(p3.name);//Tom p3.age = 10; System.out.println(p1.age);//10 } } // 1. 创建类 class Person { // 属性 String name; int age; boolean isMale; // 方法 public void eat() { System.out.println(\"人可以吃饭\"); } public void sleep() { System.out.println(\"人可以睡觉\"); } public void talk(String language) { System.out.println(\"人可以说话，使用的是： \" + language); } } ","date":"2021-04-03","objectID":"/java-shk-3/:1:2","tags":["Java"],"title":"Java零基础教程（三.面向对象-封装Encapsulation）","uri":"/java-shk-3/"},{"categories":null,"content":"1.3 属性 vs. 局部变量 package com.atguigu.java; /* * 类中属性的使用 * * 属性 vs 局部变量 * 1. 相同点： * 1）定义变量的格式：数据类型 变量名 = 变量值 * 2）先声明，后使用 * 3）变量都有其对应的作用域 * * 2. 不同点： * 1） 在类中声明位置的不同 * 属性：直接定义在类的一对{} * 局部变量：声明在方法内，方法形参，代码块内，构造器形参，构造器内部的变量 * * 2）关于权限修饰符的不同 * 属性：可以在声明属性时，指明其权限，使用权限修饰符。 * 常用的权限修饰符：private, public, 缺省, protected ---\u003e 封装性 * 目前，大家声明属性时，都是用缺省就可以了 * 局部变量：不可以使用权限修饰符。 * * 3）默认初始化的情况： * 属性：类的属性，根据其类型，都有默认初始化值。 * 整型(byte, short, int, long) 0 * 浮点型(float, double) 0.0 * 字符型(char), 0 或 '\\u0000' * boolean: false * 引用数据类型(类，数组，接口) null * * 局部变量：没有默认初始化值。 * 意味着，我们在调用局部变量之前，一定要显式复制。 * 特别地：形参在调用时，我们再赋值即可。 * * 4）在内存中家在的位置不同： * 属性：加载到堆空间中（非static） * 局部变量：加载到栈空间 * */ public class UserTest { public static void main(String[] args) { // TODO Auto-generated method stub User u1 = new User(); System.out.println(u1.name); System.out.println(u1.age); System.out.println(u1.isMale); } } class User { // 属性 String name; public int age; boolean isMale; public void talk(String language) {// language: 形参，也是局部变量 System.out.println(\"我们使用\" + language + \"进行交流\"); } public void eat() { String food = \"烙饼\";// 局部变量，不赋值会报错 System.out.println(\"北方人喜欢吃: \" + food); } } ","date":"2021-04-03","objectID":"/java-shk-3/:1:3","tags":["Java"],"title":"Java零基础教程（三.面向对象-封装Encapsulation）","uri":"/java-shk-3/"},{"categories":null,"content":"1.4 类方法的声明和使用 package com.atguigu.java; /* * 类中方法的声明和使用 * * 方法：描述类应该具有的功能 * 比如：Math类: sqrt() random() * Scanner类: nextXxx() * Arrays类: sort(), binarySearch(), toString(), equals() * * 1. 举例： * public void eat(){} * public void sleep(int hour){} * public String getName(){} * public String getNation(String nation){} * * 2. 方法的声明： 权限修饰符 返回值类型 方法名(形参列表) { * 方法体 * } * static, final, abstract 来修饰的方法，后面再讲 * * 3. 说明： * 1） 关于权限修饰符：默认方法的权限修饰符先都使用public * Java规定的4种权限修饰符：private, public, 缺省, protected ---\u003e 封装性细说 * 2） 返回值类型：有返回值 vs 没有返回值 * 2.1）如果方法有返回值，则必须在方法声明时，指定返回值的类型。 * 同时方法中，需要使用return关键字类返回指定类型的变量或常量：\"return 数据\"。 * 如果方法没有返回值，则方法声明时，使用void来表示。通常，没有返回值的方法中，就不需要return。 * 但是如果使用的话，只能“return;”表示结束此方法的意思。 * 2.2）我们定义方法该不该有返回值？ * 题目要求 * 凭经验：具体问题具体分析 * 3） 方法名：属于标识符，遵循标识符的规则和规范，“见名知意” * 4） 形参列表： 方法可以声明0个，1个，或多个形参。 * 4.1) 格式：数据类型1 形参1, 数据类型2 形参2, ... * 4.2) 我们定义方法时，该不该定义形参？ * 题目要求 * 凭经验：具体问题具体分析 * 5） 方法体：方法功能的体现 * * 4. return关键字的使用： * 1）使用范围：使用在方法体中 * 2）作用： * 结束方法 * 针对于有返回值类型的方法，使用\"return 数据\"方法返回所要的数据。 * 3）注意点：return关键字后面不可以声明执行语句。 * * 5. 方法的使用中，可以调用当前类的属性或方法 * 特殊的：方法A中有调用了方法A：递归方法。 * 方法中不可以定义方法 */ public class CustomerTest { public static void main(String[] args) { // TODO Auto-generated method stub } } class Customer { String name; int age; boolean isMale; public void eat() { System.out.println(\"客户吃饭\"); } public void sleep(int hour) { System.out.println(\"休息了\" + hour + \"个小时\"); } public String getName() { return name; } public String getNation(String nation) { String info = \"我的国籍是：\" + nation; return info; } } ","date":"2021-04-03","objectID":"/java-shk-3/:1:4","tags":["Java"],"title":"Java零基础教程（三.面向对象-封装Encapsulation）","uri":"/java-shk-3/"},{"categories":null,"content":"1.5 匿名对象 package com.atguigu.java; /* * 匿名对象的使用 * 1. 理解： 我们创建的对象，没有显式地赋给一个变量名，即为匿名对象。 * 2. 特征：匿名对象只能调用一次。 * 3. 使用：如下 */ public class InstanceTest { public static void main(String[] args) { new Phone().price = 1999; new Phone().showPrice(); PhoneFactory pf = new PhoneFactory(); // 匿名对象的使用 pf.show(new Phone()); } } class PhoneFactory { public void show(Phone phone) { phone.showPrice(); } } class Phone { double price; public void showPrice() { System.out.println(\"价格为：\" + price); } } ","date":"2021-04-03","objectID":"/java-shk-3/:1:5","tags":["Java"],"title":"Java零基础教程（三.面向对象-封装Encapsulation）","uri":"/java-shk-3/"},{"categories":null,"content":"1.6 方法的重载 package com.atguigu.java1; /* * 方法的重载（overload）loading... * 1. 定义：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。 * “两同一不同”：同一个类，相同方法名；参数列表不同：参数个数不同，参数类型不同 * * 2. 举例 * Arrays类中重载的sort() / binarySearch() * * 3. 判断是否是重载 * 跟方法的权限修饰符，返回值类型，形参变量名，方法体没有关系。 * * 4. 在通过对象调用方法时，如何确定某一个指定的方法： * 方法名 -\u003e 参数列表 */ public class OverLoadTest { // 如下的4个方法构成了重载 public void getSum(int i, int j) { System.out.println(\"1\"); } public void getSum(double d1, double d2) { System.out.println(\"2\"); } public void getSum(String s, int i) { System.out.println(\"3\"); } public void getSum(int i, String s) { System.out.println(\"4\"); } // 下面的都不算重载 // public int getSum(int i, int j) { // // } // public void getSum(int m, int n) { // // } // private void getSum(int i, int j) { // // } } ","date":"2021-04-03","objectID":"/java-shk-3/:1:6","tags":["Java"],"title":"Java零基础教程（三.面向对象-封装Encapsulation）","uri":"/java-shk-3/"},{"categories":null,"content":"1.7 可变个数形参 package com.atguigu.java1; /* * 可变个数形参的方法 * 1. jdk 5.0 新增的内容 * 2. 具体使用： * 1） 可变个数形参的格式： 数据类型 ... 变量名 * 2） 当调用可变个数形参的方法时，传入参数的个数可以是0，1，2... * 3） 可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载 * 4） 可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。换句话说，二者不能共存 * 5） 可变个数形参在方法的形参中，必须声明在末尾 * 6） 可变个数形参在方法的形参中，最多只能声明一个可变形参。 */ public class MethodArgsTest { public static void main(String[] args) { MethodArgsTest test = new MethodArgsTest(); test.show(12);//1 test.show(\"hello\");//2 test.show(\"hello\", \"world\");//3 test.show();//3 } public void show(int i) { System.out.println(\"1\"); } public void show(String s) { System.out.println(\"2\"); } public void show(String ... strs) { System.out.println(\"3\"); } // public void show(String[] strs) { // // } } ","date":"2021-04-03","objectID":"/java-shk-3/:1:7","tags":["Java"],"title":"Java零基础教程（三.面向对象-封装Encapsulation）","uri":"/java-shk-3/"},{"categories":null,"content":"1.8 方法的值传递机制 package com.atguigu.java1; /* * 方法的形参的值传递机制：值传递 * 1. 形参：方法定义时，声明的小括号内的参数 * 实参：方法调用时，实际传递给形参的数据 * * 2. 值传递机制： * 如果参数是基本数据类型，此时赋值的是变量所保存的数据值。 * 如果参数是引用数据类型，此时赋值的是变量所保存的数据的地址值。 */ public class ValueTransferTest1 { public static void main(String[] args) { int m = 10; int n = 20; // 交换两个变量的值 int tmp = m; m = n; n = tmp; System.out.println(\"m = \" + m + \", n = \" + n); ValueTransferTest1 test = new ValueTransferTest1(); m = 10; n = 20; test.swap(m, n); System.out.println(\"m = \" + m + \", n = \" + n); System.out.println(\"**************************\"); Data data = new Data(); data.m = 10; data.n = 20; test.swap(data); System.out.println(\"m = \" + data.m + \", n = \" + data.n); } public void swap(int m, int n) { int tmp = m; m = n; n = tmp; } public void swap(Data data) { int tmp = data.m; data.m = data.n; data.n = tmp; } } class Data { int m; int n; } ","date":"2021-04-03","objectID":"/java-shk-3/:1:8","tags":["Java"],"title":"Java零基础教程（三.面向对象-封装Encapsulation）","uri":"/java-shk-3/"},{"categories":null,"content":"2. 面向对象特征之一：封装与隐藏 为什么需要封装？封装的作用和含义？ 我要用洗衣机，只需要按一下开关和洗涤模式就可以了。有必要了解洗衣机内部的结构吗？有必要碰电动机吗？ 我要开车，… 我们程序设计追求“高内聚，低耦合”。 高内聚：类的内部数据操作细节自己完成，不允许外部干涉； 低耦合：仅对外暴露少量的方法用于使用。 package com.atguigu.java; /* * 面向对象的特征一：封装与隐藏 * 一·问题的引入 * 当我们创建一个类的对象以后，我们可以通过“对象.属性”的方式，对对象的属性进行赋值。这里赋值操作 * 要受到属性的数据类型和存储范围的制约。除此之外，没有其他制约条件。但是，在实际问题中，我们往往需要 * 给属性赋值加入额外的限制条件。这个条件就不能在属性声明时体现，我们只能通过方法进行限制条件的添加。 * （比如：set）同时，我们需要避免用户再使用“对象.属性”的方式对属性进行赋值。则需要将属性声明为私有的（private） * ---\u003e 此时，针对于属性就体现了封装性。 * * 二·封装性的体现： * 我们将类的属性私有化（private），同时，提供公共的（public）方法来获取（getXxx）和设置（setXxx）此属性的值 * * 拓展：封装性的体现： * 1） 如上 * 2） 不对外暴露的私有的方法 * 3） 单例模式 * * 三·封装性的体现，需要权限修饰符来配合。 * 1. Java规定的4种权限：（从小到大）private, 缺省, protected, public * 2. 四种权限可以用来修饰类及类的内部结构：属性，方法，构造器，内部类 * 3. 具体地， 四种权限都可以用来修饰类的内部结构：属性，方法，构造器，内部类 * 修饰类的话，只能使用：缺省，public * * 总结封装性：Java提供了4种权限修饰符来修饰类及类的内部结构，体现类及类的内部结构在被调用时的可见性大小 */ public class AnimalTest { public static void main(String[] args) { Animal a = new Animal(); a.name = \"大黄\"; a.age = 1; // a.legs = 4; a.show(); a.setLegs(4); a.show(); } } class Animal { String name; int age; private int legs; public void eat() { System.out.println(\"动物进食\"); } public void show() { System.out.println(\"name = \" + name + \", age = \" + age + \", legs = \" + legs); } public void setLegs(int l) { if (l \u003e= 0 \u0026\u0026 l % 2 == 0) { legs = l; } else { legs = 0; // 抛出异常 } legs = l; } public int getLegs() { return legs; } } 修饰符 类内部 同一个包 不同包的子类 同一个工程 private yes （缺省） yes yes protected yes yes yes public yes yes yes yes ","date":"2021-04-03","objectID":"/java-shk-3/:2:0","tags":["Java"],"title":"Java零基础教程（三.面向对象-封装Encapsulation）","uri":"/java-shk-3/"},{"categories":null,"content":"3. 构造器 ","date":"2021-04-03","objectID":"/java-shk-3/:3:0","tags":["Java"],"title":"Java零基础教程（三.面向对象-封装Encapsulation）","uri":"/java-shk-3/"},{"categories":null,"content":"3.1 构造器的使用 package com.atguigu.java1; /* * 类的结构之三：构造器（或构造方法，constructor）的使用 * * 一·构造器的作用： * 1. 创建对象 * 2. 初始化对象的的信息 * * 二·说明： * 1. 如果没有显式的定义类的构造器的话，则系统默认提供一个空参的构造器。 * 2. 定义构造器的格式：权限修饰符 类名(形参列表){} * 3. 一个类中定义的多个构造器，彼此构成重载 * 4. 一旦我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器。 * 5. 一个类中，至少会有一个构造器。 */ public class PersonTest { public static void main(String[] args) { // 创建类的对象: new + 构造器 Person p = new Person(); p.eat(); Person p1 = new Person(\"Tom\"); System.out.println(p1.name); } } class Person { // 属性 String name; int age; // 构造器 public Person() { System.out.println(\"constructing object\"); } public Person(String n) { name = n; } // 方法 public void eat() { System.out.println(\"人吃饭\"); } } ","date":"2021-04-03","objectID":"/java-shk-3/:3:1","tags":["Java"],"title":"Java零基础教程（三.面向对象-封装Encapsulation）","uri":"/java-shk-3/"},{"categories":null,"content":"3.2 属性赋值的先后顺序 package com.atguigu.java1; /* * 总结：属性赋值的先后顺序 * * 1. 默认初始化值 * 2. 显式初始化 * 3. 构造器中赋值 * 4. 通过“对象.方法” 或 “对象.属性”的方式赋值 * * 以上操作的先后顺序：1 - 2 - 3 - 4 * */ public class UserTest { } class User { String name; int age = 1; public User() { } public User(int a) { age = a; } } ","date":"2021-04-03","objectID":"/java-shk-3/:3:2","tags":["Java"],"title":"Java零基础教程（三.面向对象-封装Encapsulation）","uri":"/java-shk-3/"},{"categories":null,"content":"3.3 JavaBean package com.atguigu.java1; /* * JavaBean 是一种Java语言写成的可重用组建。 * 所谓JavaBean，是指符合如下标准的Java类： * 1） 类是公共的 * 2） 有一个无参的公共构造器 * 3） 有属性，且有对应的get，set方法 */ public class Customer { private int id; private String name; public Customer() { } public void setId(int i) { id = i; } public int getId() { return id; } public void setName(String n) { name = n; } public String getName() { return name; } } ","date":"2021-04-03","objectID":"/java-shk-3/:3:3","tags":["Java"],"title":"Java零基础教程（三.面向对象-封装Encapsulation）","uri":"/java-shk-3/"},{"categories":null,"content":"4 关键字 ","date":"2021-04-03","objectID":"/java-shk-3/:4:0","tags":["Java"],"title":"Java零基础教程（三.面向对象-封装Encapsulation）","uri":"/java-shk-3/"},{"categories":null,"content":"4.1 this关键字 package com.atguigu.java2; /* * this 关键字的使用 * 1. this可以用来修饰,调用：属性，方法，构造器 * 2. this修饰属性和方法： * this理解为当前对象 或 当前正在创建的对象 * * 1） 在类的方法中，我们可以使用“this.属性”或“this.方法”的方式，调用当前对象的属性和方法。 * 但是通常情况下，我们都选择省略“this.”。特殊情况下，如果方法的形参和类的属性同名时，我们必须显式 * 的使用\"this.变量\"的方式，表明此变量是属性，而非形参。 * * 2） 在类的构造器中，我们可以使用“this.属性”或“this.方法”的方式，调用当前正在创建的对象属性和方法。 * 但是通常情况下，我们都选择省略“this.”。特殊情况下，如果构造器的形参和类的属性同名时，我们必须显式 * 的使用\"this.变量\"的方式，表明此变量是属性，而非形参。 * * 3. this调用构造器 * 1）我们在类的构造器中，可以显式的使用“this(形参列表)”方式，调用本类中指定的其他构造器。 * 2）构造器中不能通过“this(形参列表)”方式调用自己。 * 3）如果一个类中有n个构造器，则最多有n-1构造器中使用了“this(形参列表)” * 4）规定：“this(形参列表)”必须声明在当前构造器的首行 * 5）构造器内部，最多只能声明一个“this(形参列表)”，用来调用其他的构造器 */ public class PersonTest { public static void main(String[] args) { Person p1 = new Person(); p1.setAge(1); System.out.println(p1.getAge()); } } class Person { private String name; private int age; public Person() { this.eat(); String info = \"Person初始化时，需要考虑如下的1，2，3，4，... (共40行代码)\"; System.out.println(info); } public Person(int age) { this(); this.age = age; } public Person(String name) { this(); this.name = name; } public Person(String name, int age) { this(age); this.name = name; // this.age = age; } public void setName(String name) { this.name = name; } public String getName() { return name; } public void setAge(int age) { this.age = age; } public int getAge() { return age; } public void eat() { System.out.println(\"人吃饭\"); this.study(); } public void study() { System.out.println(\"人学习\"); } } ","date":"2021-04-03","objectID":"/java-shk-3/:4:1","tags":["Java"],"title":"Java零基础教程（三.面向对象-封装Encapsulation）","uri":"/java-shk-3/"},{"categories":null,"content":"4.2 package和import关键字 package com.atguigu.java2; import java.util.Date; import static java.lang.System.*; /* * 一·package关键字的作用（类似班级的概念） * 1. 为了更好地实现项目中类的管理，提供包的概念。 * 2. 使用package声明类或接口所属的包，声明在源文件的首行 * 3. 包，属于标识符，遵循标识符的命名规则，规范(xxxyyyzzz)，“见名知意” * 4. 每“.”一次，就代表一层文件目录 * * 补充：同一个包下，不能命名同名的接口，类。 * 不同的包下，可以命名同名的接口，类。 * * 二·import关键字的使用 * 1. 在源文件中显式的使用import结构导入指定包下的类，接口。 * 2. 声明在包的声明和类的声明之间 * 3. 如果需要导入多个结构，则并列写出即可 * 4. 可以使用“xxx.*”的方式，表示可以导入xxx包下的所有结构。 * 5. 如果使用的类或接口是java.lang包下定义的，则可以省略import结构 * 6. 如果使用的类或接口是本包下定义的，则可以省略import接口。 * 7. 如果在源文件中，使用了不同包下的同名类，则必须至少有一个类需要以全类名的方式显式 * 8. 使用“xxx.*”方式表明可以调用xxx包下的所有结构。但是如果使用的是xxx子包下的结构，则仍需要显式import * 9. import static: 导入指定类或接口[中]的静态结构：属性或方法。 */ public class PackageImportTest { public static void main(String[] args) { Date date = new Date(); // 全类名 java.sql.Date date1 = new java.sql.Date(0); out.println(\"hello\"); } } ","date":"2021-04-03","objectID":"/java-shk-3/:4:2","tags":["Java"],"title":"Java零基础教程（三.面向对象-封装Encapsulation）","uri":"/java-shk-3/"},{"categories":null,"content":"1. 关键字 数据类型：class, interface, enum, byte, short, int, long, float, double, char, boolean, void 数值：true, false, null 流程控制：if, else, switch, case, default, while, do, for, break, continue, return 访问权限：private, protected, public 类，函数，变量的修饰符：abstract, final, static, synchronized 类与类关系：extends, implements 实例的创建，引用，判断：new, this, super, instanceof 异常处理：try, catch, finally, throw, throws 包：package, import 其他：native, strictfp, transient, volatile, assert ","date":"2021-03-10","objectID":"/java-shk-2/:1:0","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"2. 标识符 标识符（aka变量方法类名）的命名规范： 包：都小写 xxxyyy 类,接口：XxxYyy 变量方法：xxxYyy 常量：XXX_YYY_ZZZ ","date":"2021-03-10","objectID":"/java-shk-2/:2:0","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"3. 变量 ","date":"2021-03-10","objectID":"/java-shk-2/:3:0","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"3.1 数据类型 包含变量类型，变量名，和存储的值。变量都定义在其作用域内，在作用域内，它是有效的，除了作用域就失效了。 基本数据类型：整数类型byte（-128～127）, short（两字节-2^15～2^15-1）, int(四字节，-21亿～21亿), long（八字节，必须以小写或大写L结尾）； 浮点类型float（四字节，必须以f或F结尾，精确到7位有效数字，范围-3.403e38～3.403e38）, double（八字节，精度为float两倍，范围-1.798e308～1.798e308）;字符型char（两字节），布尔型boolean; 引用数据类型：类（例如String类），接口，数组 ASCII字符集：8bit表示 Unicode字符集：将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，使用Unicode没有乱码的问题。char c = \\u0043(字母C)。 UTF-8: 互联网上使用最广的一种Unicode的实现方式，采用变长编码方式，使用1～6个字节表示一个符号。 ","date":"2021-03-10","objectID":"/java-shk-2/:3:1","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"3.2 基本数据类型之间的转换 自动类型提升 当容量小的数据类型的变量与容量大的数据类型的变量做运算时，结果自动提升为容量大的数据类型。 所表示数据范围（容量）排序：byte， char， short \u003c int \u003c long \u003c float \u003c double,注意这里是范围大小，而不是所占空间大小（float四字节小于long的八字节）。 特别的，当byte，char，short之间做运算时，结果为int型。 // Example short s1 = 10; byte b1 = 10; char c1 = 'a'; // char c = c1 + s1; // 编译报错 // char c = c1 + b1; // 编译报错 // short s = b1 + s1; // 编译报错 // short s = b1 + b1; // 编译报错 long l = 123213; // 成功，自动类型提升 // long l1 = 12313213123232; // 编译报错 long l1 = 12313213123232L; // 成功 //float f = 12.3; // 编译报错，double往float转了 // 整形常量默认为int型，浮点型常量默认为double型 强制类型转换 是自动类型提升的逆操作，将范围大的值向范围小的变量转换 // Example double d = 12.3; // int i = d; // 编译报错 int i = (int)d; // 成功，但截断损失精度 int i2 = 128; byte b = (byte)i2; // 成功，但是b = -128 (二进制最高位的原因) ","date":"2021-03-10","objectID":"/java-shk-2/:3:2","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"3.3 String数据类型 String类型变量的使用： String属于引用数据类型 声明String类型变量时，使用一对“” String可以和8种基本数据类型做运算，且运算只能是连接运算“+” 运算的结果仍然是String类型。 String s1 = \"Hello World!\"; // 练习：判断+是相加还是连接 char c = 'a'; int num = 10; String str = \"hello\"; System.out.println(c + num + str); // 107hello System.out.println(c + str + num); // ahello10 System.out.println(c + (num + str)); // a10hello System.out.println((c + num) + str); // 107hello System.out.println(str + num + c); // hello10a System.out.println(\"* *\"); // * * System.out.println('*' + '\\t' + '*'); // 93, 因为是char之间的数值运算 System.out.println('*' + \"\\t\" + '*'); // * * System.out.println('*' + '\\t' + \"*\"); // 51*, 第一个相加执行的是数值运算 System.out.println('*' + ('\\t' + \"*\")); // * * ","date":"2021-03-10","objectID":"/java-shk-2/:3:3","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"3.4 进制转换 整数的四种常见进制：二进制（0b或0B），十进制，八进制（以数字0开头表示），十六进制（0x或0X） 三码： 原码：直接将一个数值换成二进制数，最高位是符号位。 负数的反码：是对原码按位取反，只是最高位（符号位）确定为1。 负数的补码：其反码加1。 正数的原码，反码，补码相同。负数的补码是其反码+1。 00001110: 十进制14 10001110: -14的原码，第一位是符号位 11110001: -14的反码，除第一位外按位取反 11110010: -14的补码，计算机底层以补码形式存储数据。 求10111011储存的是什么数？ 去补10111010 取反11000101 所以储存的是-(64+4+1) = -69 特别地，10000000储存的是-128 ","date":"2021-03-10","objectID":"/java-shk-2/:3:4","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"4. 运算符 ","date":"2021-03-10","objectID":"/java-shk-2/:4:0","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"4.1 算数运算符 加减乘除（/）取模（%），前自增，后自增，前自减，后自减，字符串连接（+） int num1 = 12; int num2 = 5; System.out.println(num1 / num2); // 2 System.out.println(num1 / num2 * num2); // 10 double res = num1 / num2; System.out.println(res); // 2.0 System.out.println(num1 / (num2 + 0.0)); // 2.4 System.out.println(12 % 5); // 2 System.out.println(-12 % 5); // -2 System.out.println(12 % -5); // 2 System.out.println(-12 % -5); // -2 // 取模的符号与被模数（12/-12）相同 int a1 = 10; int b1 = ++a1; int a2 = 10; int b2 = a2++; //执行后，a1是11，b1是11，a2是11，b2是10 //注意点 short s1 = 10; // s1 = s1 + 1; // 编译失败，int值放入short变量 s1++; //编译通过，自增不改变本身变量数据类型 byte b1 = 127; b1++; System.out.println(b1); // -128 ","date":"2021-03-10","objectID":"/java-shk-2/:4:1","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"4.2 赋值运算符 =， +=， -=， *=， /=， %= // option 1 int i1 = 10; int j1 = 10; // option 2 int i2, j2; i2 = j2 = 10; // option 3 int i3 = 10; j3 = 20; short s1 = 10; // s1 = s1 + 2; // 编译失败 s1 += 2; System.out.println(s1); // 12 // 所以开发中希望变量+2 // option1: num = num + 2; // option2 (推荐): num += 2; // 所以开发中希望变量+1 // option1: num = num + 1; // option2: num += 1; // option3 (推荐): num++; int n = 10; n += (n++) + (++n); System.out.println(n); // n = n + (n++) + (++n) = 10 + 10 + 12 = 32 ","date":"2021-03-10","objectID":"/java-shk-2/:4:2","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"4.3 比较运算符 ==, !=, \u003c, \u003e, \u003c=, \u003e=, instanceof ","date":"2021-03-10","objectID":"/java-shk-2/:4:3","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"4.4 逻辑运算符 \u0026, \u0026\u0026, |, ||, !（非）, ^（异或） ","date":"2021-03-10","objectID":"/java-shk-2/:4:4","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"4.5 位运算符 \u003c\u003c, \u003e\u003e, \u003e\u003e\u003e, \u0026, |, ^（异或运算）, ~（取反） 区分逻辑\u0026和位运算\u0026：逻辑\u0026计算的是boolean型，位运算\u0026计算的是数值。 总结 位运算符操作的都是整形的数据 在一定范围内，每向左移一位，相当于 *2 在一定范围内，每向右移一位，相当于 /2 // 交换两个变量的值 // option1: 推荐 int tmp = num1; num1 = num2; num2 = num1; // option2: 可能超出存储范围 num1 = num1 + num2; num2 = num1 - num2; num1 = num1 - num2; // option3: trick num1 = num1 ^ num2; num2 = num1 ^ num2; num1 = num1 ^ num2; ","date":"2021-03-10","objectID":"/java-shk-2/:4:5","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"4.6 三元运算符 (condition) ? caseTrue : caseFalse; ","date":"2021-03-10","objectID":"/java-shk-2/:4:6","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"5. 流程控制 import java.util.Scanner; class IfTest { public static void main(String[] args) { Scanner scan = new Scanner(System.in); System.out.println(\"Input exam score: (0-100)\"); int score = scan.nextInt(); if (score == 100) { System.out.println(\"win a BMW\"); } else if (score \u003e 80) { System.out.println(\"win a iPhone\"); } else if (score \u003e= 60) { System.out.println(\"win a iPad\"); } else { System.out.println(\"no prize\"); } } } 总结： 如果多个条件表达式之间互斥，哪个判断在上面在下面，无所谓。 如果多个条件表达式之间有交集，需要考虑清楚谁在上。 如果多个条件表达式之间有包含，通常情况下，范围小的在上面，否则范围小的可能没机会执行。 int number = 2; switch (number) { case 0: System.out.println(\"zero\"); break; case 1: System.out.println(\"one\"); break; case 2: System.out.println(\"two\"); break; default: System.out.println(\"other\"); break; } 总结： 根据switch的表达式中的值，依次匹配各个case的常量。一旦匹配成功，则进入相应的case结构中，调用其执行语句。当调用完执行语句以后，则依然继续向下执行其他case结构中的执行语句，直到遇到break关键字或此switch-case结构末尾结束为止。 break可以使用在switch-case结构中，表示一旦执行到此关键字，就跳出switch-case结构。 switch结构中的表达式，只能是如下的6种数据结构之一：byte，short，char，int，枚举类型（JDK5.0新增），String类型（JDK7.0新增）。 case之后只能声明常量，不能声明范围。 break关键字是可选的。 default类似于if-else结构中的else。default结构是可选的。 如果switch-case结构中的多个case执行语句相同，则可以考虑合并。 凡是可以使用switch-case结构的地方，都可以转换为if-else。反之不成立。 我们写分支结构时，当发现既可以使用switch-case，（同时，switch中表达式的取值情况不太多），又可以使用if-else时，我们优先选择使用switch-case。原因：switch-case执行效率稍高。 for (①；②；④) { ③; } // 1-2-3-4-2-3-4-...-2 ①; while (②) { ③; ④; } // 1-2-3-4-2-3-4-...-2 do { ③; ④; } while (②); // 1-3-4-2-3-4-...-2 class PrimeNumberTest { public static void main(String[] args) { boolean isFlag = true; int count = 0; // 获取当前时间距离1970-01-01 00:00:00 的毫秒数 long start = System.currentTimeMillis(); for (int i = 2; i \u003c= 100000; i++) { for (int j = 2; j \u003c= Math.sqrt(i); j++) { if (i % j == 0) { isFlag = false; break; } } if (isFlag == true) { count++; } isFlag = true; } long end = System.currentTimeMillis(); System.out.println(\"prime number count: \" + count); System.out.println(\"elapsed time: \" + (end - start)); } } 使用范围 不同 相同 break switch-case，循环结构中 结束当前循环 关键字后面不能声明执行语句 continue 循环结构中 结束当次循环 关键字后面不能声明执行语句 label: for (int i = 2; i \u003c 100000; i++) { for (int j = 2; j \u003c Math.sqrt(i); j++) { if (i % j == 0) { // break; 默认跳出包裹此关键字的最近一层循环。 // continue; // break label; //结束指定标识的一层循环结构 // continue label; //结束指定标识的一层循环结构的当次循环 continue label; } count++; } } 循环语句的四个组成部分 初始化部分 循环条件部分 循环体部分 迭代部分 总结： 写while循环千万小心不要丢了迭代条件。一旦丢了，就可能导致死循环。 我们写程序，要避免出现死循环。 for循环和while循环是可以互相转化的。区别：for循环和while循环的初始化条件部分的作用范围不同。 do-while循环至少会执行一次循环体。 ","date":"2021-03-10","objectID":"/java-shk-2/:5:0","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"6. 数组 ","date":"2021-03-10","objectID":"/java-shk-2/:6:0","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"6.1 Array的概念与基础使用 数组的理解： 数组（Array），是多个相同数据类型按照一定顺序排列的集合，并使用一个名字命名， 并通过编号的方式对这些数据进行统一管理。 数据相关的概念：数组名，元素，下标（索引），数组的长度（元素的个数） 数据的特点： 数组是有序排列的。 数组属于引用数据类型的变量，引用数据类型有数组，类，接口。String是一个类。数组的元素，既可以是基本数据类型，也可以是引用数据类型。 创建数组对象会在内存中开辟一整块连续的空间。 数组的长度一旦确定，就不能修改。 数组的分类： 按照维数：一维数组，二维数组。。。 按照元素类型：基本数据类型元素的数组，引用数据类型元素的数组 一维数组的使用 一维数组的声明和初始化 如何调用数组的指定位置的元素 如何获取数组的长度 如何遍历数组 数组元素的默认初始化值 数组的内存解析 package com.atguigu.java; import java.util.Iterator; public class ArrayTest { public static void main(String[] args) { // 1. 一维数组的声明和初始化 int num; // 声明 num = 10; // 初始化 int id = 1001; //声明 + 初始化 int[] ids; //声明 // 1.1 静态初始化：数组的初始化和数组元素的赋值操作同时进行 ids = new int[]{1001, 1002, 1003, 1004}; // 1.2 动态初始化：数组的初始化和数组元素的赋值操作分开进行 String[] names = new String[5]; // 也是正确的写法（类型推断） int[] arr4 = {1,2,3,4,5}; // 错误的写法： // int[] arr1 = new int[]; // int[5] arr2 = new int[5]; // int[] arr3 = new int[3]{1,2,3}; // 总结：数组一旦初始化完成，其长度就确定了。 // 2. 如何调用数组的指定位置的元素：通过角标的方式调用。 // 数组的角标（或索引）从0开始，到数组的长度-1结束。 names[0] = \"aaa\"; names[1] = \"bbb\"; names[2] = \"ccc\"; names[3] = \"ddd\"; names[4] = \"eee\"; // 3. 如何获取数组的长度。 // 属性：length System.out.println(names.length); // 5 // 4. 如何遍历数组 for (int i = 0; i \u003c names.length; i++) { System.out.println(names[i]); } } } package com.atguigu.java; public class ArrayTest1 { public static void main(String[] args) { // 5. 数组元素的默认初始化值 // \u003e 数组元素是整型：0 // \u003e 数组元素是浮点型：0.0 // \u003e 数组元素是char型：ASCII0的char或'\\u0000'(null) // \u003e 数组元素是boolean型：false // \u003e 数组元素是引用数据类型：null，String时也是null，而不是空字符串 // int[] arr = new int[4]; for (int i = 0; i \u003c arr.length; i++) { System.out.println(arr[i]); } System.out.println(\"************\"); float[] arr1 = new float[4]; for (int i = 0; i \u003c arr1.length; i++) { System.out.println(arr1[i]); } System.out.println(\"************\"); char[] arr2 = new char[4]; for (int i = 0; i \u003c arr2.length; i++) { System.out.println(\"----\" + arr2[i] + \"====\"); } System.out.println(\"************\"); boolean[] arr3 = new boolean[4]; for (int i = 0; i \u003c arr3.length; i++) { System.out.println(\"----\" + arr3[i] + \"====\"); } } } package com.atguigu.java; public class ArrayTest2 { public static void main(String[] args) { // 1. 二维数组的声明和初始化 // 静态初始化 int[] arr = new int[]{1,2,3}; // 一维数组 // int[][] arr1 = new int[][]{{1,2,3},{4,5},{6,7,8}}; // 二维数组 // 动态初始化1 String[][] arr2 = new String[3][2]; // 动态初始化2 String[][] arr3 = new String[3][]; // 错误的情况 // String[][] arr4 = new String[][4]; // String[4][3] arr5 = new String[][]; // int[][] arr6 = new int[4][3]{{1,2,3},{4,5,{6,7,8}}}; // 正确： // int[] arr4[] = new int[][]{{1,2,3},{4,5},{6,7,8}}; } } 内存解析： 栈（stack）：局部变量 堆（heap）：new出来的结构，对象，数组 方法区：常量池，静态域 ","date":"2021-03-10","objectID":"/java-shk-2/:6:1","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"6.2 Arrays工具类的使用 package com.atguigu.java; import java.util.Arrays; // java.util.Arrays: 操作数组的工具类，包含了用来操作数组的方法 public class ArraysTest { public static void main(String[] args) { // 1. 判断两个数组是否相等。 int[] arr1 = new int[]{1,2,3,4}; int[] arr2 = new int[]{1,3,2,4}; boolean isEquals = Arrays.equals(arr1, arr2); System.out.println(isEquals); // 2. 输出数组信息 System.out.println(Arrays.toString(arr1)); // 3. 将指定值填充到数组之中 Arrays.fill(arr1, 10); System.out.println(Arrays.toString(arr1)); // 4. 对数组排序 Arrays.sort(arr2); System.out.println(Arrays.toString(arr2)); // 5. 二分查找 int[] arr3 = new int[] {-98, -34, 2, 34, 54, 66, 79, 105, 210, 333}; int index = Arrays.binarySearch(arr3, 211); System.out.println(index); } } ","date":"2021-03-10","objectID":"/java-shk-2/:6:2","tags":["Java"],"title":"Java零基础教程（二.基本语法）","uri":"/java-shk-2/"},{"categories":null,"content":"1. 硬件介绍 ","date":"2020-11-18","objectID":"/java-shk/:1:0","tags":["Java"],"title":"Java零基础教程（一.概论）","uri":"/java-shk/"},{"categories":null,"content":"1.1 CPU（中央处理器） 冯诺伊曼体系结构：冯诺伊曼被人们称为“计算机之父”。计算机由输入设备，输出设备，存储器，运算器，控制器构成。现代计算机中的CPU负责其中的运算与控制功能。 赫兹：现代计算机的计算速度以千兆赫（GHz）来表述。英文进制：KHz，MHz，GHz Intel i7-6700HQ：“6”第六代，HQ标压版本，U低压版本 摩尔定律：每一美元所能买到的电脑性能，每隔18-24个月翻一倍以上。 ","date":"2020-11-18","objectID":"/java-shk/:1:1","tags":["Java"],"title":"Java零基础教程（一.概论）","uri":"/java-shk/"},{"categories":null,"content":"1.2 存储 硬盘 硬盘存储的数据断电不丢失（持久化设备）。在windows系统中，A/B盘的位置是预留给软驱的（软驱已经淘汰）。 内存 Read-Access Memory，内存存储数据速度比硬盘快10倍以上，其部分解决了CPU运算过快，而硬盘数据存取太慢的问题。断电会导致数据丢失 bit：二进制表示0/1 byte：8 bits，内存中每个byte拥有唯一的地址。 进制：1KB = 1024B, 1MB = 1024KB, 1GB = 1024MB, 1T = 1024GB, 1PB = 1024TB, EB,ZB,YB,以此类推。 ROM：手机的“硬盘”，例如16GB，128GB。但是经常被大众（误）叫做手机内存。 ","date":"2020-11-18","objectID":"/java-shk/:1:2","tags":["Java"],"title":"Java零基础教程（一.概论）","uri":"/java-shk/"},{"categories":null,"content":"1.3 输入输出 输入设备： 鼠标键盘； 输出设备： 显示器打印机 1920x1080：像素矩阵 2K屏幕：比如2244x1080（2244\u003e2000） 屏幕尺寸：屏幕对角线长度 像素密度：sqrt(长度像素数^2 + 宽度像素数^2) / 屏幕尺寸 ","date":"2020-11-18","objectID":"/java-shk/:1:3","tags":["Java"],"title":"Java零基础教程（一.概论）","uri":"/java-shk/"},{"categories":null,"content":"1.4 通信设备 ","date":"2020-11-18","objectID":"/java-shk/:1:4","tags":["Java"],"title":"Java零基础教程（一.概论）","uri":"/java-shk/"},{"categories":null,"content":"2. 计算机发展史 图灵：计算机之父，人工智能之父 冯诺伊曼：计算机之父，博弈论之父 www（万维网）：简称web。www可以让Web客户端（如浏览器）访问浏览Web服务器上的页面。是一个由许多互相连接的超文本组成的系统，通过互联网访问。在这个系统中，每个有用的事物，称为一样资源，并且由一个全局统一资源标识符（URI）标识；这些资源通过超文本传输协议HTTP（Hypertext Transfer Protocol）传送给用户，用户通过点击链接来获得资源。 万维网vs因特网vs互联网：他们是包含关系。万维网是无数个网络站点和网页集合。因特网除了万维网，还包括电子邮件等。 BS架构，CS架构：browser server（例如百度搜索）； client server（例如QQ） ","date":"2020-11-18","objectID":"/java-shk/:2:0","tags":["Java"],"title":"Java零基础教程（一.概论）","uri":"/java-shk/"},{"categories":null,"content":"3. Java语言概述 ","date":"2020-11-18","objectID":"/java-shk/:3:0","tags":["Java"],"title":"Java零基础教程（一.概论）","uri":"/java-shk/"},{"categories":null,"content":"3.1 编程语言 机器语言 -\u003e 汇编语言 -\u003e 高级语言（面向过程）-\u003e 高级语言（面向对象） 执行效率越来越低，但开发效率越来越高。 TIOBE语言热度排行榜 ","date":"2020-11-18","objectID":"/java-shk/:3:1","tags":["Java"],"title":"Java零基础教程（一.概论）","uri":"/java-shk/"},{"categories":null,"content":"3.2 Java语言的历史 Java由SUN（Stanford University Network）于1995年推出的编程语言。 1991 - Green项目，最初命名Oak（橡树） 1994 - 开发组意识到Oak适合互联网（可以在Web浏览器中运行，使得用户可以使用图形界面进行交互） 1996 - 发布JDK1.0 2004 - 发布JDK1.5，因为具有里程碑特性，更名为JDK5.0 2005 - J2SE改名为JavaSE，J2EE改名为JavaEE，J2ME改名为JavaME 2009 - Oracle收购SUN 2014 - 发布JDK8.0，是继JDK5.0以来变化最大的版本，也是业界常用的版本。 其他常用于后台开发的语言：Java，PhP，Python，Go，NodeJS JavaSE：桌面应用（例如QQ） JavaEE：企业互联网后台开发 JavaME：移动端开发 现在JavaSE不常开发桌面应用了，之前SE与EE是并列关系，但是这里我们把SE当作EE的基础知识。 Java应用领域： 企业级应用 Android平台应用 大数据平台开发 ","date":"2020-11-18","objectID":"/java-shk/:3:2","tags":["Java"],"title":"Java零基础教程（一.概论）","uri":"/java-shk/"},{"categories":null,"content":"3.3 Java语言特性 特性： 面向对象（封装，继承，多态） 健壮性（去掉指针，提供了内存管理机制，但Java程序也会出现内存泄漏和内存溢出的问题！） 跨平台性（Write Once, Run Anywhere）只需要安装一个Java虚拟机（JVM），JVM有不同操作系统对应的版本Win，Linux，Mac等。 ","date":"2020-11-18","objectID":"/java-shk/:3:3","tags":["Java"],"title":"Java零基础教程（一.概论）","uri":"/java-shk/"},{"categories":null,"content":"3.4 环境搭建 常见简称： JDK：（Java Development Kit） JRE：（Java Runtime Environment）运行环境 JDK = JRE + 开发工具集（例如Javac编译工具等） JRE = JVM + JavaSE标准类库 jdk-8u131: JDK8.0，“u”-update，131补丁 Steps： 安装JDK8.0（不建议安装在系统C盘下，下一步。。。下一步） 安装JRE（理论上JDK安装包里包含JRE，但是Eclipse需要识别单独的JRE） 配置环境变量（使得javac等命令可以在任意目录执行） path环境变量：Windows操作系统执行命令时，索要搜寻的路径 Administrator的用户变量适用于当前登陆用户，而系统变量则适用于所有用户。 ","date":"2020-11-18","objectID":"/java-shk/:3:4","tags":["Java"],"title":"Java零基础教程（一.概论）","uri":"/java-shk/"},{"categories":null,"content":"4. 第一个程序HelloWorld 程序执行的流程：javac编译生成.class文件，java运行.class文件。 $ javac HelloWorld.java # 生成 HelloChina.class $ java HelloChina class HelloChina { public static void main(String[] args) { System.out.println(\"Hello, World!\"); } } 总结： 一个java文件中可以声明多个class， 但只能最多有一个类声明为public，而且public只能加在与文件名相同的类前面。 程序的入口是main方法，格式是固定的。 程序行以分号结尾。 编译以后，会生成一个或多个class文件，文件名与源文件中类名相同。 单行注释//, 多行注释/**/, javadoc文档注释javadoc -d myHello -author -version ","date":"2020-11-18","objectID":"/java-shk/:4:0","tags":["Java"],"title":"Java零基础教程（一.概论）","uri":"/java-shk/"},{"categories":null,"content":"5. Eclipse使用 先创建包（例如：com.atguigu.contact）,再创建类（例如HelloWorld.java）。 运行，右键Run As 快捷键 补全代码的声明：alt + / 快速修复：ctrl + 1 单行注释：ctrl + / 多行注释：ctrl + shift + / 取消多行注释：ctrl + shift + \\ 复制指定行的代码：command + option + down或command + option + up 删除指定行的代码：command + d 上下移动代码：option + up或option + down 切换到下一行代码空位：shift + enter 切换到上一行代码空位：ctrl + shift + enter 查看原码：command + 选中 退回到前一个编辑的页面：alt + left 自动补全main，sysout：ctrl + space 使用定义好的注释模版: /** + Enter 添加注释模版 Window -\u003e Preferences -\u003e Java -\u003e Code Style -\u003e Code Templates ","date":"2020-11-18","objectID":"/java-shk/:5:0","tags":["Java"],"title":"Java零基础教程（一.概论）","uri":"/java-shk/"},{"categories":null,"content":"Chapter 1: The Machine Learning Landscape 下载github库中csv数据集: import urllib.request DOWNLOAD_ROOT = \"https://raw.githubusercontent.com/ageron/handson-ml2/master/\" os.makedirs(datapath, exist_ok=True) for filename in (\"oecd_bli_2015.csv\", \"gdp_per_capita.csv\"): print(\"Downloading\", filename) url = DOWNLOAD_ROOT + \"datasets/lifesat/\" + filename urllib.request.urlretrieve(url, datapath + filename) 预处理pivot: def prepare_country_stats(oecd_bli, gdp_per_capita): # 筛选行 oecd_bli = oecd_bli[oecd_bli[\"INEQUALITY\"]==\"TOT\"] # 抽取多行数据为多列数据 oecd_bli = oecd_bli.pivot(index=\"Country\", columns=\"Indicator\", values=\"Value\") # 列重命名 gdp_per_capita.rename(columns={\"2015\": \"GDP per capita\"}, inplace=True) gdp_per_capita.set_index(\"Country\", inplace=True) # join full_country_stats = pd.merge(left=oecd_bli, right=gdp_per_capita, left_index=True, right_index=True) # 排序 full_country_stats.sort_values(by=\"GDP per capita\", inplace=True) # 剔除不需要的行 remove_indices = [0, 1, 6, 8, 33, 34, 35] keep_indices = list(set(range(36)) - set(remove_indices)) # 按整数索引行 return full_country_stats[[\"GDP per capita\", 'Life satisfaction']].iloc[keep_indices] # df.pivot()作用： # Country | INDICATOR | Value Country | Dwe....... | Housing .. | ... # ---------------------------- ===》 ---------------------------------------- # Australia| Dwe...... | 1.10 Australia| 1.10 | 20.00 | ... # Australia| Housing ..| 20.00 Austria | ... # ... ... 保存图片: # Where to save the figures PROJECT_ROOT_DIR = \".\" CHAPTER_ID = \"fundamentals\" IMAGES_PATH = os.path.join(PROJECT_ROOT_DIR, \"images\", CHAPTER_ID) os.makedirs(IMAGES_PATH, exist_ok=True) def save_fig(fig_id, tight_layout=True, fig_extension=\"png\", resolution=300): path = os.path.join(IMAGES_PATH, fig_id + \".\" + fig_extension) print(\"Saving figure\", fig_id) if tight_layout: plt.tight_layout() plt.savefig(path, format=fig_extension, dpi=resolution) 在图片上加注释: sample_data.plot(kind='scatter', x=\"GDP per capita\", y='Life satisfaction', figsize=(5,3)) plt.axis([0, 60000, 0, 10]) position_text = { \"Hungary\": (5000, 1), # 文本框左下角xy \"Korea\": (18000, 1.7), \"France\": (29000, 2.4), \"Australia\": (40000, 3.0), \"United States\": (52000, 3.8), } for country, pos_text in position_text.items(): pos_data_x, pos_data_y = sample_data.loc[country] country = \"U.S.\" if country == \"United States\" else country # xy：箭头位置， xytext：文本框位置，shrink：箭头缩短10% plt.annotate(country, xy=(pos_data_x, pos_data_y), xytext=pos_text, arrowprops=dict(facecolor='black', width=0.5, shrink=0.1, headwidth=5)) plt.plot(pos_data_x, pos_data_y, \"ro\") plt.xlabel(\"GDP per capita (USD)\") save_fig('money_happy_scatterplot') plt.show() 如果数据集中某些样本缺少一些特征（比如5%的顾客没有声明年龄），可以尝试的方法：1）忽略所有样本的年龄，2）忽略缺少年龄特征的样本，3）补缺（比如年龄的中位数）4）训练两个模型，一个包含所有特征，一个不含缺失特征。 Holdout validation: 在training set上效果好的模型，不一定在新数据上表现好，所以我们需要训练集外的数据来评判模型泛化能力。在test set上表现好的模型也只能表示其在该特定test set上表现好，还需要第三个数据集客观评判。所以，常见的处理是把数据集分为training dataset，validation dataset，和test dataset。用training dataset训练模型，确定模型参数。用validation dataset挑选一系列模型（比如确定hyperparameter）。通过validation dataset上的表现，选出最优模型再在training+validation上训练。最后通过test dataset客观评价模型的泛化能力。（思考kaggle的open和private数据集） ","date":"2020-10-25","objectID":"/handson-ml2-1/:1:0","tags":["machine learning"],"title":"《机器学习实战（第二版）》-读书笔记1","uri":"/handson-ml2-1/"},{"categories":null,"content":"数据的读入 ","date":"2020-10-19","objectID":"/kaggle-regression-eda/:1:0","tags":["kaggle","eda"],"title":"Kaggle Regression Eda","uri":"/kaggle-regression-eda/"},{"categories":null,"content":"特征的理解 ","date":"2020-10-19","objectID":"/kaggle-regression-eda/:2:0","tags":["kaggle","eda"],"title":"Kaggle Regression Eda","uri":"/kaggle-regression-eda/"},{"categories":null,"content":"特征的数据类型 df.info(verbose=True) # 查看每列缺省情况和数据类型 Pandas dtype Python type NumPy type Usage object str or mixed string_, unicode_, mixedtypes 字符串文本 int64 int int_, int8, int16, int32, int64, uint8, uint16, uint32, uint64 整数 float64 float float_, float16, float32, float64 浮点数 bool bool bool_ 真假 datetime64 NA datetime64[ns] 日期与时间 timedelta[ns] NA NA 日期时间差 category NA NA Finite list of text values ","date":"2020-10-19","objectID":"/kaggle-regression-eda/:2:1","tags":["kaggle","eda"],"title":"Kaggle Regression Eda","uri":"/kaggle-regression-eda/"},{"categories":null,"content":"特征类型 这个步骤是用来理解数据中每一列的具体含义，通过查看feature与label的关系，可以检查是否符合自己的直观感受。比如，通常情况下，房子越大，房子越新，房价越高，等等。可以通过数据类型将每个feature划归到对应的特征类型，便于后续的分析与建模。 类型1: ID 主要查看数据集是否为event level，看是否需要聚合操作将每个ID的行为总结。数据集可以是交易数据，每行数据为一笔交易，也可以是看房数据，同一套房子可能触发多个看房事件。例如，聚合每套房子的看房者数量，可以一定程度上帮助预测房子的火热程度。 类型2: Numerical 区别于类别型，数值型的特征值是可比较的，包含连续型和离散型。连续型的例子可以是价格，面积，温度, 时间。离散型的例子可以是用户打分（例如五星好评）。对于时间特征，可以做差生成时间段特征。 类型3: Categorical def specify_feature_type(df): numerical_cols = df.select_dtypes(include='number').columns.tolist() object_cols = df.select_dtypes(include='object').columns.tolist() id_features = ['Id'] label = ['SalePrice'] numerical_features = list(set(numerical_cols) - set(id_features) - set(label)) categorical_features = object_cols return id_features, numerical_features, categorical_features, label id_features, numerical_features, categorical_features, label = specify_feature_type(df) assert len(id_features) + len(numerical_features) + len(categorical_features) + len(label) == df.shape[1] ","date":"2020-10-19","objectID":"/kaggle-regression-eda/:2:2","tags":["kaggle","eda"],"title":"Kaggle Regression Eda","uri":"/kaggle-regression-eda/"},{"categories":null,"content":"特征的分布与预测能力 对于numerical feaure，可以计算feature与label的线性相关性Pearson Correlation Coefficient (PCC)，并将强相关性关系画出来。 def rank_feature_by_corr(df, method='pearson'): \"\"\"calculate Pearson correlation coefficient between feature and label, and rank the results\"\"\" feature_corr = dict() for feature in numerical_features: feature_corr[feature] = df[feature].corr(df[label[0]], method) corr_df = pd.DataFrame(feature_corr.items(), columns=['feature', 'corr']) corr_df['abs'] = np.abs(corr_df['corr']) return corr_df.sort_values('abs', ascending=False).reset_index(drop=True) def plot_feature_correlation(df, feature): fig = px.scatter(df, x=feature, y=label[0], \\ marginal_x=\"histogram\", marginal_y=\"histogram\",\\ width=600, height=450) fig.show() pcc_rank = rank_feature_by_corr(df) for i in range(2): plot_feature_correlation(df, pcc_rank.loc[i,'feature']) 而对于categorical feature, 可以画出feature列中每种类别的label分布。 import plotly.figure_factory as ff def plot_label_distribution_per_class(df, feature): hist_data = [] group_labels = [] for name, group in df.groupby(feature): hist_data.append(group[label[0]]) group_labels.append(name) # Create distplot with curve_type set to 'normal' fig = ff.create_distplot(hist_data, group_labels, show_hist=False) # Add title fig.update_layout(title_text='Curve and Rug Plot') fig.show() plot_label_distribution_per_class(df, categorical_features[0]) 也可以用heatmap将两两之间的相关性画出来。 fig = px.imshow(df.corr()) fig.show() ","date":"2020-10-19","objectID":"/kaggle-regression-eda/:2:3","tags":["kaggle","eda"],"title":"Kaggle Regression Eda","uri":"/kaggle-regression-eda/"},{"categories":null,"content":"参考 pandas数据类型 Kaggle房价预测 correlation between categorical and numerical variable ","date":"2020-10-19","objectID":"/kaggle-regression-eda/:3:0","tags":["kaggle","eda"],"title":"Kaggle Regression Eda","uri":"/kaggle-regression-eda/"},{"categories":null,"content":"Example 1. DataFrame的5种基本操作 1.筛选行，2.选取列，3.增加行列，4.分组总结，5.排序 一个简单的工资数据集： df = spark.createDataFrame([ (1, 'sales', 4200), (2, 'admin', 3100), (3, 'sales', 4000), (4, 'sales', 4000), (5, 'admin', 2700), (6, 'dev', 3400), (7, 'dev', 5200), (8, 'dev', 3700), (9, 'dev', 4400), (10, 'dev', 4400) ], schema=['id', 'dept', 'salary']) df.show() # +---+-----+------+ # | id| dept|salary| # +---+-----+------+ # | 1|sales| 4200| # | 2|admin| 3100| # | 3|sales| 4000| # | 4|sales| 4000| # | 5|admin| 2700| # | 6| dev| 3400| # | 7| dev| 5200| # | 8| dev| 3700| # | 9| dev| 4400| # | 10| dev| 4400| # +---+-----+------+ Q1: 列出dev部门工资大于4000的所有id。(filter, select, show) df.filter((F.col('dept') == 'dev') \u0026 (F.col('salary') \u003e 4000)).select(['id', 'salary']).show() # +---+------+ # | id|salary| # +---+------+ # | 6| 3400| # | 7| 5200| # | 8| 3700| # | 9| 4400| # | 10| 4400| # +---+------+ Q2: 求基础工资的10%奖金列，并补全列名dept-\u003edepartment。(withColumn, withColumnRenamed) df.withColumn('bonus', F.col('salary')*0.1).withColumnRenamed('dept', 'department').show() # +---+----------+------+-----+ # | id|department|salary|bonus| # +---+----------+------+-----+ # | 1| sales| 4200|420.0| # | 2| admin| 3100|310.0| # | 3| sales| 4000|400.0| # | 4| sales| 4000|400.0| # | 5| admin| 2700|270.0| # | 6| dev| 3400|340.0| # | 7| dev| 5200|520.0| # | 8| dev| 3700|370.0| # | 9| dev| 4400|440.0| # | 10| dev| 4400|440.0| # +---+----------+------+-----+ Q3: 求每个部门的最低工资，平均工资，最高工资。(groupby, agg, alias, sort), 并按平均工资降序排序。 df.groupby('dept').agg(F.min(F.col('salary')).alias('minimum'), \\ F.avg(F.col('salary')).alias('mean'), \\ F.max(F.col('salary')).alias('maximum'))\\ .sort('mean', ascending=False).show() # +-----+-------+------------------+-------+ # | dept|minimum| mean|maximum| # +-----+-------+------------------+-------+ # | dev| 3400| 4220.0| 5200| # |sales| 4000|4066.6666666666665| 4200| # |admin| 2700| 2900.0| 3100| # +-----+-------+------------------+-------+ ","date":"2020-09-03","objectID":"/spark-practice-101/:1:0","tags":["spark"],"title":"Spark 101: DataFrame基本使用","uri":"/spark-practice-101/"},{"categories":null,"content":"Example 2. groupby 与 window 参考：Youtube, How do spark window functions work? Q1: 求部门工资数组，和部门总工资。(groupby, agg, collect_list) df = df.groupby('dept').agg( F.expr('collect_list(salary)').alias('list_salary'), F.expr('avg(salary)').alias('average_salary'), F.expr('sum(salary)').alias('total_salary') ).show() # +-----+--------------------+------------------+------------+ # | dept| list_salary| average_salary|total_salary| # +-----+--------------------+------------------+------------+ # | dev|[3400, 5200, 3700...| 4220.0| 21100| # |sales| [4200, 4000, 4000]|4066.6666666666665| 12200| # |admin| [3100, 2700]| 2900.0| 5800| # +-----+--------------------+------------------+------------+ Q2: 在每条数据旁列出所在部门的工资情况（上问的答案）。(Window, partitionBy, over) windowSpec = Window.partitionBy('dept') df = df.withColumn('list_salary', F.collect_list(F.col('salary')).over(windowSpec))\\ .withColumn('average_salary', F.avg(F.col('salary')).over(windowSpec))\\ .withColumn('total_salary', F.sum(F.col('salary')).over(windowSpec)).show() # +---+-----+------+--------------------+------------------+------------+ # | id| dept|salary| list_salary| average_salary|total_salary| # +---+-----+------+--------------------+------------------+------------+ # | 6| dev| 3400|[3400, 5200, 3700...| 4220.0| 21100| # | 7| dev| 5200|[3400, 5200, 3700...| 4220.0| 21100| # | 8| dev| 3700|[3400, 5200, 3700...| 4220.0| 21100| # | 9| dev| 4400|[3400, 5200, 3700...| 4220.0| 21100| # | 10| dev| 4400|[3400, 5200, 3700...| 4220.0| 21100| # | 1|sales| 4200| [4200, 4000, 4000]|4066.6666666666665| 12200| # | 3|sales| 4000| [4200, 4000, 4000]|4066.6666666666665| 12200| # | 4|sales| 4000| [4200, 4000, 4000]|4066.6666666666665| 12200| # | 2|admin| 3100| [3100, 2700]| 2900.0| 5800| # | 5|admin| 2700| [3100, 2700]| 2900.0| 5800| # +---+-----+------+--------------------+------------------+------------+ Q3: 将工资在其部门顺序，在部门内扫描得到前缀和（相等的工资同时扫描）。(orderBy) windowSpec = Window.partitionBy('dept').orderBy(F.asc('salary')) df = df.withColumn('list_salary', F.collect_list(F.col('salary')).over(windowSpec))\\ .withColumn('average_salary', F.avg(F.col('salary')).over(windowSpec))\\ .withColumn('total_salary', F.sum(F.col('salary')).over(windowSpec)).show() # +---+-----+------+--------------------+------------------+------------+ # | id| dept|salary| list_salary| average_salary|total_salary| # +---+-----+------+--------------------+------------------+------------+ # | 6| dev| 3400| [3400]| 3400.0| 3400| # | 8| dev| 3700| [3400, 3700]| 3550.0| 7100| # | 9| dev| 4400|[3400, 3700, 4400...| 3975.0| 15900| # | 10| dev| 4400|[3400, 3700, 4400...| 3975.0| 15900| # | 7| dev| 5200|[3400, 3700, 4400...| 4220.0| 21100| # | 3|sales| 4000| [4000, 4000]| 4000.0| 8000| # | 4|sales| 4000| [4000, 4000]| 4000.0| 8000| # | 1|sales| 4200| [4000, 4000, 4200]|4066.6666666666665| 12200| # | 5|admin| 2700| [2700]| 2700.0| 2700| # | 2|admin| 3100| [2700, 3100]| 2900.0| 5800| # +---+-----+------+--------------------+------------------+------------+ 注：注意观察id9\u002610的重复工资，相等的工资条将导致工资前缀和的同时扫描。请看下问一个更贴切实际的前缀和实例。 Q4: Q3问题不变（相等的工资先后扫描）。(rowsBetween) windowSpec = Window.partitionBy('dept').orderBy(F.asc('salary'))\\ .rowsBetween(Window.unboundedPreceding, Window.currentRow) df = df.withColumn('list_salary', F.collect_list(F.col('salary')).over(windowSpec))\\ .withColumn('average_salary', F.avg(F.col('salary')).over(windowSpec))\\ .withColumn('total_salary', F.sum(F.col('salary')).over(windowSpec)).show() # +---+-----+------+--------------------+------------------+------------+ # | id| dept|salary| list_salary| average_salary|total_salary| # +---+-----+------+--------------------+------------------+------------+ # | 6| dev| 3400| [3400]| 3400.0| 3400| # | 8| dev| 3700| [3400, 3700]| 3550.0| 7100| # | 9| dev| 4400| [3400, 3700, 4400]|3833.3333333333335| 11500| # | 10| dev| 4400|[3400, 3700, 4400...| 3975.0| 15900| # | 7| dev| 5200|[3400, 3700, 4400...| 4220.0| 21100| # | 3|sales| 4000| [4000]| 4000.0| 4000| # | 4|sales| 4000| [4000, 4000]| 4000.0| 8000| # | ","date":"2020-09-03","objectID":"/spark-practice-101/:2:0","tags":["spark"],"title":"Spark 101: DataFrame基本使用","uri":"/spark-practice-101/"},{"categories":null,"content":"Example 3. Join与Skew Join join可以把两张表内关键字匹配的数据做笛卡尔乘积，放入结果表。 参考： Medium, 6 spark exercises to rule them all 数据集：三张表sales, products, sellers, 大约6GB，使用local模式。 Q1: 三张表各有多少记录？(parquet, count) DATASET_PATH = './DatasetToCompleteTheSixSparkExercises' products = spark.read.parquet(f'{DATASET_PATH}/products_parquet') sales = spark.read.parquet(f'{DATASET_PATH}/sales_parquet') sellers = spark.read.parquet(f'{DATASET_PATH}/sellers_parquet') sales.count(), products.count(), sellers.count() # (20000040, 75000000, 10) Q2: 有多少种商品至少被卖出过一次？(distinct) sales.select(['product_id']).distinct().count() # 993429 Q3: 订单中最常见的商品是哪个？(sort, limit) sales.groupby(['product_id']).count().sort('count', ascending=False).limit(1).show() # +----------+--------+ # |product_id| count| # +----------+--------+ # | 0|19000000| # +----------+--------+ Q4: 统计sales中product_id的分布情况 (groupby, groupby) key_stats = sales.groupby('product_id').count().withColumnRenamed('count', 'pid_count')\\ .groupby('pid_count').count().toPandas() key_stats = key_stats.sort_values('pid_count') key_stats['frequency'] = key_stats['count'] / sum(key_stats['count']) key_stats['cum_freq'] = np.cumsum(key_stats['frequency']) key_stats # 先通过groupby得到key size， 再按照小key到大key排列，最后通过groupby统计每个key size的数量 # pid_count count frequency cum_freq # 0 1 986847 0.993374 0.993374 # 2 2 6550 0.006593 0.999968 # 1 3 31 0.000031 0.999999 # 3 19000000 1 0.000001 1.000000 plt.plot(np.log10(key_stats['pid_count']), key_stats['cum_freq']) Q5: 每天各卖多少种商品？(countDistinct) sales.groupby(['date']).agg(F.countDistinct(\"product_id\").alias(\"cnt\")).sort(\"cnt\", ascending=False).show() # +----------+------+ # | date| cnt| # +----------+------+ # |2020-07-06|100765| # |2020-07-09|100501| # |2020-07-01|100337| # |2020-07-03|100017| # |2020-07-02| 99807| # |2020-07-05| 99796| # |2020-07-04| 99791| # |2020-07-07| 99756| # |2020-07-08| 99662| # |2020-07-10| 98973| # +----------+------+ Q6: 求订单盈利（数量x价格）的平均值。(join, skewed data) 由于订单中的商品集中在少数商品ID，使用product_id进行join会造成skewed data,降低并行效率。 df = sales.join(products, on='product_id') df = df.withColumn('revenue', sales['num_pieces_sold'] * products['price']) df.select(F.avg('revenue')).show() # +------------------+ # | avg(revenue)| # +------------------+ # |1246.1338560822878| # +------------------+ 可以对product常见key加盐，可以先join两表加盐的key部分，再join两表未加盐的普通key部分，最后union。这样可以把集中分布的key加盐溶解，提高集群的并行效率。 def skew_join(skew_df, other_df, on, topK, how='inner', SALT_RANGE=100): # STEP1: find topK popular keys in skew_df topKkey = skew_df.groupby(on).agg({'*': 'count'}).withColumnRenamed('count(1)', '_skew_key_cnt')\\ .sort('_skew_key_cnt', ascending=False).limit(topK) # STEP2: split skew_df, other_df into pop and unpop halves skew_df_pop = skew_df.join(F.broadcast(topKkey), on=on).drop('_skew_key_cnt') skew_df_unpop = skew_df.join(F.broadcast(topKkey), on=on, how='left_anti').drop('_skew_key_cnt') other_df_pop = other_df.join(F.broadcast(topKkey), on=on).drop('_skew_key_cnt') other_df_unpop = other_df.join(F.broadcast(topKkey), on=on, how='left_anti').drop('_skew_key_cnt') # STEP3: salt skew_df_pop, replicate other_df_pop skew_df_pop = skew_df_pop.withColumn('_skew_salt', (F.rand() * SALT_RANGE).cast(types.IntegerType())) other_df_pop = other_df_pop.withColumn('_skew_salts', F.array([F.lit(i) for i in range(SALT_RANGE+1)])) other_df_pop = other_df_pop.select('*', F.explode('_skew_salts').alias('_skew_salt')).drop('_skew_salts') # STEP4: join seperately and union res_pop = skew_df_pop.join(other_df_pop, on=on+['_skew_salt'], how=how).drop('_skew_salt') res_unpop = skew_df_unpop.join(other_df_unpop, on=on, how=how) return res_pop.union(res_unpop) df = skew_join(sales, products, on=['product_id'], topK=10) df = df.withColumn('revenue', sales['num_pieces_sold'] * products['price']) df.select(F.avg('revenue')).show() # +------------------+ # | avg(revenue)| # +------------------+ # |1246.1338560822878| # +------------------+ Q7: 对每个销售员，求一个订单对其目标的平均贡献。(broadcast) 注：比如销售员0目标250件总共拥有三笔订单，订单1卖10件，订单2卖8件，订单3卖7件。那么每张订","date":"2020-09-03","objectID":"/spark-practice-101/:3:0","tags":["spark"],"title":"Spark 101: DataFrame基本使用","uri":"/spark-practice-101/"},{"categories":null,"content":"Example 4. UDF Q1: 在sales数据中创建列，根据order_id和bill_raw_text计算每条销售数据bill的hash值，并查看是否有hash冲突。(udf) hash规则： 当order_id为奇数，计算sha256；当order_id为偶数时，迭代计算md5，迭代次数为大写A出现的次数。 import hashlib from pyspark.sql.types import StringType def fancy_hash(order_id, bill_raw_text): res = bill_raw_text.encode('utf-8') # 1) even case if int(order_id) % 2 == 0: cnt_A = bill_raw_text.count('A') for _ in range(cnt_A): res = hashlib.md5(res).hexdigest().encode('utf-8') res = res.decode('utf-8') else: res = hashlib.sha256(res).hexdigest() return res # Convert the fancy_hash python function into its UDF fancy_hash_udf = F.udf(lambda arg1, arg2: fancy_hash(arg1, arg2), StringType()) sales.withColumn('hashed_bill', fancy_hash_udf(sales['order_id'], sales['bill_raw_text']))\\ .groupby('hashed_bill').agg(F.count('*').alias('cnt')).filter(F.col('cnt') \u003e 1).show() # 返回为空，即无哈希冲突 ","date":"2020-09-03","objectID":"/spark-practice-101/:4:0","tags":["spark"],"title":"Spark 101: DataFrame基本使用","uri":"/spark-practice-101/"},{"categories":null,"content":"Example 5. UDF 数据集DataFrame [startDate: timestamp, binaryIds: array\u003cbigint\u003e] 寻找最新的100个binaryId ","date":"2020-09-03","objectID":"/spark-practice-101/:5:0","tags":["spark"],"title":"Spark 101: DataFrame基本使用","uri":"/spark-practice-101/"},{"categories":null,"content":"什么是数据倾斜？ 对于Spark/Hadoop等分布式系统，机器间工作量的不均匀比单纯的工作量大更难处理，因为单纯的工作量大基本通过scale-out就可以解决。假设有100个任务并行处理，若任务间工作量相当，20台机器要比10台机器耗时减半（假设机器性能相当）。然而当任务间工作量相差巨大时（例如，任务中10个大任务，90个小任务，工作量差别1M倍），很难通过scale-out的方式充分利用并行优势，此时，完成总耗时取决于最慢的大任务何时完成（木桶原理）。 对于Spark这种计算引擎，工作量主要在于所需处理的数据量。因此当任务划分时，数据分布不均匀，即发生了数据倾斜。 ","date":"2020-08-30","objectID":"/spark-data-skew/:1:0","tags":["spark"],"title":"Spark: 解决数据倾斜的N种姿势","uri":"/spark-data-skew/"},{"categories":null,"content":"数据是如何倾斜的？ 当Spark产生shuffle操作时，相同key的数据会被放在相同的partition。因此当某一个key的数据量过大（即popular key），会造成partition间工作量巨大差别，造成数据倾斜。这样不仅影响了并行效率，更加容易造成内存不足，产生OOM（Out Of Memory）报错使整个应用崩溃。 常见会触发shuffle的算子：distinct, groupByKey, reduceByKey, aggregateByKey, join, cogroup, repartition。 ","date":"2020-08-30","objectID":"/spark-data-skew/:2:0","tags":["spark"],"title":"Spark: 解决数据倾斜的N种姿势","uri":"/spark-data-skew/"},{"categories":null,"content":"如何识别数据倾斜？ 观察stage进度条，发现大多数task很快执行完，但是剩余task等待时间巨长甚至出现OOM报错。（如上图） 查看Spark Web UI里的Shuffle Read Size/Records，查看任务间数据量分布是否均匀。 计算key的分布。（如下） df.select(\"key\").sample(false, 0.1) // 数据采样 .(k =\u003e (k, 1)).reduceBykey(_ + _) // 统计 key 出现的次数 .map(k =\u003e (k._2, k._1)).sortByKey(false) // 根据 key 出现次数进行排序 .take(10) // 取前 10 个。 ","date":"2020-08-30","objectID":"/spark-data-skew/:3:0","tags":["spark"],"title":"Spark: 解决数据倾斜的N种姿势","uri":"/spark-data-skew/"},{"categories":null,"content":"发生了数据倾斜怎么办？ ","date":"2020-08-30","objectID":"/spark-data-skew/:4:0","tags":["spark"],"title":"Spark: 解决数据倾斜的N种姿势","uri":"/spark-data-skew/"},{"categories":null,"content":"思路1 - 过滤异常数据 如果数据包含大量异常key，过滤掉就好了。 异常key： 空值 Null 无效数据，大量重复的测试数据或是对结果影响不大的有效数据 有效数据，业务导致的正常数据分布 对于情况1\u00262，直接过滤即可。对于3，直接过滤不适用，尝试以下其他方法。 ","date":"2020-08-30","objectID":"/spark-data-skew/:4:1","tags":["spark"],"title":"Spark: 解决数据倾斜的N种姿势","uri":"/spark-data-skew/"},{"categories":null,"content":"思路2 - 提高shuffle并行度 通过增加partition的方法，让每个task执行更少的不同key，把原本被分配到同一task的不同key分配到不同task。 RDD 操作 可在需要 Shuffle 的操作算子上直接设置并行度或者使用 spark.default.parallelism 设置。如果是 Spark SQL，还可通过 SET spark.sql.shuffle.partitions=[num_tasks] 设置并行度。默认参数由不同的 Cluster Manager 控制。 dataFrame 和 sparkSql 可以设置 spark.sql.shuffle.partitions=[num_tasks] 参数控制 shuffle 的并发度，默认为200。 TIPS 可以把数据倾斜类比为 hash 冲突。提高并行度就类似于 提高 hash 表的大小。 ","date":"2020-08-30","objectID":"/spark-data-skew/:4:2","tags":["spark"],"title":"Spark: 解决数据倾斜的N种姿势","uri":"/spark-data-skew/"},{"categories":null,"content":"思路3 - 自定义Partitioner ","date":"2020-08-30","objectID":"/spark-data-skew/:4:3","tags":["spark"],"title":"Spark: 解决数据倾斜的N种姿势","uri":"/spark-data-skew/"},{"categories":null,"content":"思路4 - Broadcast机制 对于Join算子，若一边数据足够小到放入内存，可以通过Broadcast方法广播到Worker中。这样的Broadcast Join完全避免了shuffle，彻底消除了数据倾斜产生的条件。 from pyspark.sql.functions import broadcast result = broadcast(A).join(B, [\"join_col\"], \"left\") ","date":"2020-08-30","objectID":"/spark-data-skew/:4:4","tags":["spark"],"title":"Spark: 解决数据倾斜的N种姿势","uri":"/spark-data-skew/"},{"categories":null,"content":"思路5 - 拆分join再union 对于Join算子，若一边数据倾斜，另一边数据均匀，且无法map端join（broadcast），可以把两边大表各拆分为popular key与unpopular key部分，分别join再union。 join例子： left （数据倾斜）和 right（数据均匀） 采样统计left中Top K popular key，把两表按照key是否popular分拆 left = leftSkew + leftUnskew right = rightSkew + rightUnskew 左加盐，右膨胀 对leftSkew加盐，即key -\u003e (key, rand(N)), 这样大key会被分配到不同partition 对rightSkew做flatMap操作把每条数据转化为N条数据，即key -\u003e (key, 1), (key, 2), ... (key, N) 分别join再union，即Union ( Join(leftSkew, rightSkew), Join(leftUnskew, rightUnskew) ) ","date":"2020-08-30","objectID":"/spark-data-skew/:4:5","tags":["spark"],"title":"Spark: 解决数据倾斜的N种姿势","uri":"/spark-data-skew/"},{"categories":null,"content":"思路6 - 大表key加盐，小表扩大N倍join 对于数据倾斜表中key都很大的情况，分拆popular key与unpopular key意义不大。可直接对大表整体加盐，小表扩大N倍后再join，即此思路为思路5的局部优化Join(leftSkew, rightSkew)。 例子 创建两个表来模拟，其中大表数据倾斜，小表相对均匀 from math import exp from random import randint from datetime import datetime def count_elements(splitIndex, iterator): n = sum(1 for _ in iterator) yield (splitIndex, n) def get_part_index(splitIndex, iterator): for it in iterator: yield (splitIndex, it) num_parts = 18 # create the large skewed rdd skew_rdd = sc.parallelize(range(0,num_parts), num_parts).flatMap(lambda x: range(0, int(exp(x)))) skew_rdd = skew_rdd.mapPartitionsWithIndex(lambda idx, x: get_part_index(idx, x)) skew_df = spark.createDataFrame(skewed_large_rdd,['x','y']) small_rdd = sc.parallelize(range(0,num_parts), num_parts).map(lambda x: (x, x)) small_df = spark.createDataFrame(small_rdd,['a','b']) # skew_df: small_df: # x, y a, b # ==== ==== # 0, 0 0, 0 # 1, 0 1, 1 # 1, 1 2, 2 # 2, 0 3, 3 # 2, 1 4, 4 # 2, 2 5, 5 # 2, 3 6, 6 # 2, 4 7, 7 # 2, 5 8, 8 # 2, 6 9, 9 # ... ... 大表key加盐，小表扩大N（=100）倍 salt_bins = 100 from pyspark.sql import functions as F skew_df_salt = skew_df.withColumn('salt', (F.rand()*salt_bins).cast('int')).cache() small_df_rep = small_df.withColumn('replicate', F.array([F.lit(i) for i in range(salt_bins)])) small_df_rep = small_df_rep.select('*', F.explode('replicate').alias('salt')).drop('replicate').cache() # skew_df: small_df: # x, y, salt a, b, salt # ========== ========== # 0, 0, 24 0, 0, 0 # 1, 0, 53 0, 0, 1 # 1, 1, 24 0, 0, 2 # 2, 0, 37 0, 0, 3 # 2, 1, 99 0, 0, 4 # 2, 2, 87 0, 0, 5 # 2, 3, 14 0, 0, 6 # 2, 4, 94 0, 0, 7 # 2, 5, 12 0, 0, 8 # 2, 6, 5 0, 0, 9 # ... ... 最后join %%time # measure excution time in jupyter notebook res = skew_df_salt.join(small_df_rep, (skew_df_salt['x'] == small_df_rep['a'])\\ \u0026 (skew_df_salt['salt'] == small_df_rep['salt'])) res.count() # res: # x, y, b # ========= # 0, 0, 0 # 1, 0, 1 # 1, 1, 1 # 2, 0, 2 # 2, 1, 3 # 2, 2, 2 # 2, 3, 2 # 2, 4, 2 # 2, 5, 2 # 2, 6, 2 # ... ","date":"2020-08-30","objectID":"/spark-data-skew/:4:6","tags":["spark"],"title":"Spark: 解决数据倾斜的N种姿势","uri":"/spark-data-skew/"},{"categories":null,"content":"思路7 - map端先局部聚合 ","date":"2020-08-30","objectID":"/spark-data-skew/:4:7","tags":["spark"],"title":"Spark: 解决数据倾斜的N种姿势","uri":"/spark-data-skew/"},{"categories":null,"content":"思路8 - 加盐局部聚合 + 去盐全局聚合 ","date":"2020-08-30","objectID":"/spark-data-skew/:4:8","tags":["spark"],"title":"Spark: 解决数据倾斜的N种姿势","uri":"/spark-data-skew/"},{"categories":null,"content":"参考 Arganzheng’s Blog, Spark数据倾斜及其解决方案 ","date":"2020-08-30","objectID":"/spark-data-skew/:5:0","tags":["spark"],"title":"Spark: 解决数据倾斜的N种姿势","uri":"/spark-data-skew/"},{"categories":null,"content":"什么是Job, Stage, Task? Spark数据处理是像流水线一样，通过一系列操作（算子）完成对RDD的处理, 即RDD1 -\u003e RDD2 -\u003e ...。操作分为两类：Transformation和Action。Spark使用lazy evaluation模式，即Transformation操作下达后，实际并不立刻运行，只有当遇到Action时才把之前所有的Transformation和当前Action运行完毕。每当一个Action触发，就会生成一个Job。因此Job以Action划分。Job之间是串行的，只有当前job结束，才会启动下一个job。 一个Job会被划分为一个或多个stage。在一个stage中，任务是可以并行计算的。stage是按照ShuffleDependency来进行划分的。两种依赖方式为窄依赖（narrow dependency）与宽依赖（wide dependency）。区分两种依赖的方法是看：父RDD的partition是否被多个（\u003e1）子RDD的partition使用，若未被多个子RDD的partition使用，则为窄依赖，不需shuffle，不划分stage； 否则为宽依赖，划分stage。上图对比了两种依赖方式的不同。具体划分stage的算法是: 从最后一个RDD开始，从后往前推，找该RDD和父RDD之间的依赖关系，如果是窄依赖，会继续找父RDD的父RDD，如果是宽依赖，就会从该RDD开始到前面所有的RDD划分为一个stage，递归的出口是直到找不到父RDD，最后把所有的RDD划分为一个stage。 一个例子： 一个stage并行的任务称为task，对应一个partition的处理，即task总数为stage的partition总数。 ","date":"2020-08-29","objectID":"/spark-fundamentals/:1:0","tags":["spark"],"title":"Spark FAQ","uri":"/spark-fundamentals/"},{"categories":null,"content":"参考 Wide vs Narrow Dependencies github blog stackoverflow, Does stages in an application run parallel in spark Queirozf Apache Spark Architecture Overview: Jobs, Stages, Tasks, etc cnblogs, qingyunzong csdn, Z_Data Spark by Examples, Spark Repartition vs Coalesce Arganzheng’s Blog, Spark数据倾斜及其解决方案 ","date":"2020-08-29","objectID":"/spark-fundamentals/:2:0","tags":["spark"],"title":"Spark FAQ","uri":"/spark-fundamentals/"},{"categories":null,"content":"目录结构 /bin (/usr/bin, /usr/local/bin): binary,存放最经常使用的命令 /sbin (/usr/sbin, /usr/local/sbin): s: super user, 存放系统管理员使用的系统管理程序 /home: 存放普通用户的主目录，每个用户都有一个自己的目录 /root: 超级权限者的用户主目录(This is not the root (/) filesystem. It is the home directory for the root user.) /lib: 系统开机所需要最基本的动态连接共享库，类似Windows的DLL文件。几乎所有应用程序都需要用到这些共享库 /etc: 系统管理所需要的配置文件和子目录 /usr: 用户的很多应用程序和文件都放在这个目录下，类似Windows的program files目录 /proc,/srv,/sys: 内核相关目录（不要轻易修改） /dev: 硬件以文件的形式存放在该处 /media: U盘，光驱，等等 /mnt: 用户临时挂载的文件系统 /opt: 存放安装软件 /usr/local: 存放安装软件所安装的目录，一般是通过编译源码的方式安装的程序 /var: 存放经常被修改的东西，比如日志文件 ","date":"2020-08-19","objectID":"/linux-intro/:1:0","tags":["linux"],"title":"Linux入门","uri":"/linux-intro/"},{"categories":null,"content":"Vi/Vim快捷键 拷贝当前行yy, 拷贝当前行以下的5行5yy,粘贴p 删除当前行dd, 删除当前行以下的5行5dd 查找关键词/keyword,下一个出现n 显示行号:set nu,隐藏行号:set nonu 阅览最首行gg最末行G 撤销输入动作u 移动光标至第20行20+shift g ","date":"2020-08-19","objectID":"/linux-intro/:2:0","tags":["linux"],"title":"Linux入门","uri":"/linux-intro/"},{"categories":null,"content":"开关重启命令 sync # 把内存数据同步到磁盘，以下操作前先执行该命令 shutdown -h now # 立即关机 shutdown -h 1 # 1min 关机 shutdown -r now # 立即重启 halt # 等同于关机 reboot # 立即重启 ","date":"2020-08-19","objectID":"/linux-intro/:3:0","tags":["linux"],"title":"Linux入门","uri":"/linux-intro/"},{"categories":null,"content":"用户管理 useradd xiaoming # 自动创建home下同名目录 passwd xiaoming # 指定密码 userdel xiaoming # 删除用户xiaoming，home下其目录会保留 userdel -r xiaoming # 删除用户xiaoming，home下其目录不会保留 su - xiaoming # 切换用户登陆， 权限不足会给提示，exit返回到原先用户 groupadd zuming # 创建组 groupdel zuming # 删除组 useradd -g zuming xiaoming # 创建用户时，指定组 id xiaoming # 查询用户信息 usermod -g zuming2 xiaoming # 修改用户所在组 用户配置文件在： /etc/passwd （用户id，组id，家目录，shell） 组配置文件在：/etc/group 口令配置文件（密码，登录信息）：/etc/shadow(加密的) ","date":"2020-08-19","objectID":"/linux-intro/:4:0","tags":["linux"],"title":"Linux入门","uri":"/linux-intro/"},{"categories":null,"content":"实用命令 man ls # 显示ls用法 help cd # 显示cd用法 touch filename # 创建空文件 cat -n filename ｜ more # 打开文件内容（只读方式）, -n 显示行号，more分页显示 more filename # 按页显示文件，空格翻页，Enter下一行，ctrl+f/b less filename # 分页查看，lazy加载，利于显示大文件 \"less is more\" ls -l \u003e filename # 重定向（覆盖） ls -l \u003e\u003e filename # 追加（append到尾部） head -n 5 filename # 只显示文件前5行（默认10行） tail -n 5 filename # 只显示文件后5行（默认10行） -f追踪文件更新，日志监控经常用 date \"+%Y-%m-%d %H:%M:%S\" # 按格式显示当前年月日时分秒，“+”必要， -s设定 cal # 显示当前日历 find [scope] [-name 文件名, -user 用户, -size 文件大小] grep [-n 显示匹配行行号， -i 忽略大小写] 查找内容 源文件 cat hello.txt | grep -ni yes # 在hello.txt中，不区分大小写的查找yes grep -r [keyword] /data/reports zip -r xxx.zip files unzip -d 位置 xxx.zip tar -zcvf a.tar.gz a1.txt a2.txt tar -zxvf a.tar.gz ","date":"2020-08-19","objectID":"/linux-intro/:5:0","tags":["linux"],"title":"Linux入门","uri":"/linux-intro/"},{"categories":null,"content":"组管理，权限管理 在linux中的每个用户必须属于一个组，不能独立于组外。在linux中每个文件有所有者，所在组，其他组的概念。 ","date":"2020-08-19","objectID":"/linux-intro/:6:0","tags":["linux"],"title":"Linux入门","uri":"/linux-intro/"},{"categories":null,"content":"任务调度 crontab -e crontab -l crontab -r 45 22 * * * 在22点45分执行 0 17 * * 1 每周一17点0分执行 0 5 1,15 * * 每月1号15号凌晨5点执行 40 4 * * 1-5 每周一到周五凌晨4点40分执行 */10 4 * * * 每天凌晨4点每隔10分执行一次 0 0 1,15 * 1 每月1号和15号，每周一的0点0分执行。星期几和几号最好不要同时出现，容易混乱 ","date":"2020-08-19","objectID":"/linux-intro/:7:0","tags":["linux"],"title":"Linux入门","uri":"/linux-intro/"},{"categories":null,"content":"进程管理 ps -a/u/x | more ps -ef | grep sshd # 查看sshd的父进程ID kill [pid] pstree -p top netstat -anp | more # 查看网络服务 USER 用户名称 PID 进程号 %CPU 进程占用CPU的百分比 %MEM 进程占用物理内存的百分比 VSZ 进程占用的虚拟内存大小（KB） RSS 进程占用的物理内存大小（KB） TT 终端名称 STAT 进程状态 S-睡眠 R-正在运行 Z-僵死 STARTED 进程的启动时间 TIME 使用CPU总时间 COMMAND 启动进程的命令和参数 ","date":"2020-08-19","objectID":"/linux-intro/:8:0","tags":["linux"],"title":"Linux入门","uri":"/linux-intro/"},{"categories":null,"content":"服务管理 开机流程： 开机 -\u003e BIOS -\u003e /boot -\u003e init process (1) -\u003e 运行级别 -\u003e 运行级别对应的服务 service [service name] start|stop|restart|reload|status ls -l /etc/init.d chkconfig --list 服务的运行级别(runlevel)： 运行级别0: 系统停机状态，系统默认运行级别不能设为0，否则不能正常启动 运行级别1: 单用户工作状态，root权限，用于系统维护，禁止远程登录 运行级别2: 多用户状态（没有NFS），不支持网络 运行级别3: 完全的多用户状态（有NFS），登陆后进入控制台命令行模式 运行级别4: 系统未使用，保留 运行级别5: X11控制台，登陆后进入图形GUI模式 运行级别6: 系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动 ","date":"2020-08-19","objectID":"/linux-intro/:9:0","tags":["linux"],"title":"Linux入门","uri":"/linux-intro/"},{"categories":null,"content":"Ubuntu su root # 切换root用户，因为初始root未设置密码，提示错误 sudo passwd # 设置root密码 su root # 切换root用户，设置root密码后可以成功切换 ","date":"2020-08-19","objectID":"/linux-intro/:10:0","tags":["linux"],"title":"Linux入门","uri":"/linux-intro/"},{"categories":null,"content":"什么是精确率（precision）与召回率（recall）？ Precision和Recall是衡量模型预测能力的指标。在简单的分类问题（种类数=2）中，根据实际答案与模型预测，可分为如下4种情况： True Positive (TP) - 正确预测了阳类 True Negative (TN) - 正确预测了阴类 False Positive (FP) - 错误预测了阳类（实际为阴类） False Negative (FN) - 错误预测了阴类（实际为阳类） 注：True和False表示预测是否正确，Positive和Negative表示预测结果 精准率和召回率定义： Precision = TP / (TP + FP) Recall = TP / (TP + FN) 他们区别在分母不同，所取值范围均为0～1 ","date":"2020-08-12","objectID":"/precision-recall/:1:0","tags":["Machine Learning"],"title":"Precision和Recall","uri":"/precision-recall/"},{"categories":null,"content":"如何理解Precision和Recall？ 信息检索中，Precision又叫查准率（找得对），Recall又叫查全率（找得全）。 举个例子，池塘有大龙虾30只，小龙虾70只。我们发明了一只捕大龙虾神器专捕大龙虾。神器一网下去，捕到大龙虾20只，小龙虾5只。那么： 精准率 = 20 /（20 + 5） = 0.80 召回率 = 20 / 30 = 0.67 我们来看3个极端神器的Precision和Recall。 神器谨慎版：只捕了一只，且为大龙虾。Precision = 1/1 = 1.0, Recall = 1/30 = 0.033 神器电鱼版：捕了全池塘的100只。Precision = 30/100 = 0.3, Recall = 30/30 = 1.0 神器专业版：补了30只，且全为大龙虾。Precision = 30/30 = 1.0, Recall = 30/30 = 1.0 实际应用中，Precision和Recall往往不能兼得。有时我们更在意Precision，而有时我们更在意Recall。比如判断视频是否适合儿童观看（适合-正，不适合-负），我们更青睐high precision - low recall的分类器（声称安全的视频真是安全的，但可能也拦截了其他安全的视频）。再比如报警器判断是否有小偷（有小偷-正，无小偷-负），我们更青睐low precision - high recall的警报器（声称有小偷的时候可能是误报，但是真有小偷的时候它通常会响）。 ","date":"2020-08-12","objectID":"/precision-recall/:2:0","tags":["Machine Learning"],"title":"Precision和Recall","uri":"/precision-recall/"},{"categories":null,"content":"PR曲线 机器学习模型往往先预测概率（scoring），再根据概率决策分类（label）。比如score高于threshold输出positive，低于输出negative。这样Precision与Recall将是Threshold的函数，即P(t)和R(t)。如果把P(t)和R(t)作为坐标画在坐标中,就形成了PR曲线，其中(1,1)为理想点。我们可以用PR曲线下的面积（AUPR）来衡量模型表现。 相比于ROC曲线，PR曲线对不平衡数据集的性能描述更为准确。 ","date":"2020-08-12","objectID":"/precision-recall/:3:0","tags":["Machine Learning"],"title":"Precision和Recall","uri":"/precision-recall/"},{"categories":null,"content":"参考 如何解释召回率与精确率？ - 知乎 推荐系统评测指标—准确率(Precision)、召回率(Recall)、F值(F-Measure) ","date":"2020-08-12","objectID":"/precision-recall/:4:0","tags":["Machine Learning"],"title":"Precision和Recall","uri":"/precision-recall/"},{"categories":null,"content":"什么是Cookie ","date":"2020-08-09","objectID":"/cookie-track-user/:1:0","tags":["AdTech"],"title":"网络广告是如何用cookie来追踪用户的？","uri":"/cookie-track-user/"},{"categories":null,"content":"参考 Web客户端追踪(上)-Cookie追踪 网络广告代理商是如何通过 cookie 收集用户信息的？ - LO的回答 - 知乎 RTB广告竞价系统的算法介绍 你是如何被广告跟踪的？ - 巴伐利亚啤酒馆的文章 - 知乎 第一方Cookie和第三方Cookie 第一方Cookie与第三方Cookie的区别 第一方和第三方cookie是什么？ ETP,ITP,NO-TP,是时候把第三方Cookie讲清楚了 ","date":"2020-08-09","objectID":"/cookie-track-user/:2:0","tags":["AdTech"],"title":"网络广告是如何用cookie来追踪用户的？","uri":"/cookie-track-user/"},{"categories":null,"content":"PySpark的特性 Immutable Changes create new object references Old versions are unchanged Lazy Compute does not happen until output is requested ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:1:0","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"Pandas VS PySpark ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:2:0","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"Load CSV # Pandas df = pd.read_csv(\"datafile.csv\") # PySpark df = spark.read.options(header=True, inferSchema=True).csv(\"datafile.csv\") ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:2:1","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"View Dataframe # Pandas df # PySpark df.show() ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:2:2","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"Columns \u0026 Data Types # Pandas df.columns df.dtypes # PySpark df.columns df.dtypes ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:2:3","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"Rename Columns # Pandas df.columns = ['a', 'b', 'c'] df.rename(columns = {'old': 'new'}) # PySpark df.toDF('a', 'b', 'c') df.withColumnRenamed('old', 'new') ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:2:4","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"Drop Columns # Pandas df.drop('colx', axis=1) # PySpark df.drop('colx') ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:2:5","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"Filtering # Pandas df[df.col1 \u003c 20] df[(df.col1 \u003c 20) \u0026 (df.col2 == 6)] # 注意括号 # PySpark df[df.col1 \u003c 20] df[(df.col1 \u003c 20) \u0026 (df.col2 == 6)] # 注意括号 ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:2:6","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"Add Column # Pandas df['col3'] = 1 / df.col1 # 除以0得infty # PySpark df.withColumn('col3', 1 / df.col1) # 除以0得Null ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:2:7","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"Fill Nulls # Pandas df.fillna(0) # more options # PySpark df.fillna(0) ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:2:8","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"Aggregation # Pandas df.groupby(['col1', 'col2']).agg({'col3': 'mean', 'col4': 'min'}) # PySpark df.groupby(['col1', 'col2']).agg({'col3': 'mean', 'col4': 'min'}) ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:2:9","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"标准的转化 # Pandas import numpy as np df['logCol'] = np.log(df.col) # PySpark import pyspark.sql.functions as F df.withColumn('logCol', F.log(df.col)) 使用pyspark.sql.functions里的函数，可以直接调用JVM，即Java引擎，而非使用较慢的python。 例子Row Conditional Statements # Pandas df['status'] = df.apply(lambda r: 1 if r.col1 \u003e 20 else 2 if r.col2 == 6 else 3, axis=1) # PySpark import pyspark.sql.functions as F df.withColumn('status', \\ F.when(df.col1 \u003e 20, 1) \\ .when(df.col2 == 6, 2) \\ .otherwise(3)) ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:3:0","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"更复杂的转化，python必要时 # Pandas df['col5'] = df.col1.apply(lambda x : x + 1) # PySpark import pyspark.sql.functions as F from pyspark.sql.types import DoubleType # udf必须deterministic，pyspark优化默认相同运算结果相同 fn = F.udf(lambda x : x + 1, DoubleType()) df.withColumn('col5', fn(df.col1)) ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:4:0","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"Join # Pandas leftDF.merge(rightDF, on='key') leftDF.merge(rightDF, left_on='a', right_on='b') # PySpark leftDF.join(rightDF, on='key') leftDF.join(rightDF, leftDF.a == rightDF.b) 默认为inner join ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:5:0","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"统计 # Pandas df.describe() # PySpark df.describe().show() df.selectExpr(\"percentile_approx(col1, array(.25, .5, .75)) as col1\").show() ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:6:0","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"统计图 # Pandas df.hist() # PySpark df.sample(False, 0.1).toPandas().hist() ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:7:0","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"SQL # Pandas NA # PySpark df.createOrReplaceTempView('foo') df2 = spark.sql('select * from foo') ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:8:0","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":"使用习惯 使用pyspark.sql.functions内置函数。 在cluster中保持和driver相同的版本和库。 观测状态http://localhost:4040/ Learn about SSH port forwarding 不要： Try to iterate through rows Hard code a master in your dirver Use spark-submit for that df.toPandas().head() instead do: df.limit(5).toPandas() 参考 Spark Submit 2017 ","date":"2020-08-09","objectID":"/from-pandas-to-pyspark/:9:0","tags":["spark"],"title":"从Pandas到PySpark","uri":"/from-pandas-to-pyspark/"},{"categories":null,"content":" The git directory acts as a database for all the changes tracked in Git and the working tree acts as a sandbox where we can edit the current versions of the files. ","date":"2020-07-28","objectID":"/git-github/:0:0","tags":["git"],"title":"Git与Github使用","uri":"/git-github/"},{"categories":null,"content":"1. 基本操作 git init # 创建仓库 # 登陆当前操作系统的用户范围 (否则为项目级别) git config --global user.name \"My Name\" git config --global user.email \"me@example.com\" git status # 显示 working tree, staging area # 创建文件new-file.py git add new-file.py git commit -m \"[message]\" git status # 修改new-file.py git commit -a -m \"[messsage]\" # -a: shortcut of \"git add, git commit\" for the modified git log # 查看提交(当前分支) git log --oneline # 查看提交（简洁显示） git reflog # 查看HEAD曾经经过的commit # throws away unstaged changes, younger commits becomes dangling (can be retrieved via reflog if within days) git reset --hard [commitID] git reset --hard HEAD^^^ # back 3 commits git reset --hard HEAD~[n] # back n commits git diff file.py # compare file.py between work tree and staging area git diff HEAD file.py # compare between work tree and HEAD commit git show commitID # show details (+-) for one specific commit git mv file.py newname.py # rename a file git rm newname.py # remove a file ","date":"2020-07-28","objectID":"/git-github/:1:0","tags":["git"],"title":"Git与Github使用","uri":"/git-github/"},{"categories":null,"content":"2. 分支合并 git branch -v # 查看分支 git branch feature # 创建分支feature git checkout feature # 切换分支feature git checkout -b feature # 创建并切换分支feature git branch -d feature # 删除分支feature # 合并： 切换到接受修改的分支（e.g. master）增加新内容(e.g. feature上的新内容) git checkout master git merge feature # 冲突 # \u003c\u003c\u003c\u003c\u003c\u003c\u003c HEAD # abc (当前分支修改) # ======= # def (并入分支修改) # \u003e\u003e\u003e\u003e\u003e\u003e\u003e feature git add files git commit -m \"conflict resolved, merging -\u003e merged\" ","date":"2020-07-28","objectID":"/git-github/:2:0","tags":["git"],"title":"Git与Github使用","uri":"/git-github/"},{"categories":null,"content":"3. 远程合作 git remote -v # 查看本地保存的远程库地址 git remote add origin https://github.com/[username]/[reponame].git git push origin master git clone https://github.com/[username]/[reponame].git # pull = fetch + merge git fetch origin master git checkout origin/master git merge origin/master git pull origin master # 如果不是基于Github远程库的最新版所做的修改，不能推送，必须先pull # pull后如果进入冲突状态，则解决冲突后即可再推送(git commit, git push) # 跨团队协作 1) fork 2) clone 3) modified 4) pull request ","date":"2020-07-28","objectID":"/git-github/:3:0","tags":["git"],"title":"Git与Github使用","uri":"/git-github/"},{"categories":null,"content":"4. 工作流 Steps: (junior)创建分支feature (junior)推送feature分支 (senior)切换分支，审查代码 (senior)切换master，合并feature (senior)推送master分支 TODO ","date":"2020-07-28","objectID":"/git-github/:4:0","tags":["git"],"title":"Git与Github使用","uri":"/git-github/"},{"categories":null,"content":"撤销 git checkout unstaged.py # revert unstaged changes git reset HEAD staged.py # revert staged changes # overwrite the previous commit with staged changes. # ONLY LOCAL: avoid amending commits that have already been made public git commit --amend git revert HEAD # roll back to previous commit git revert commitID # roll back ","date":"2020-07-28","objectID":"/git-github/:5:0","tags":["git"],"title":"Git与Github使用","uri":"/git-github/"},{"categories":null,"content":"远程 git push # push changes to remote repo “origin” is the default name for the remote repo git remote -v # list remote repos verbosely git remote show origin # describe a single remote repo git branch -r # list remote branches What’s the main difference between git fetch and git pull? git fetch fetches remote updates but doesn’t merge; git pull fetches remote updates and merges. git fetch git log origin/master git merge origin/master # merge into local git remote update will update all of your branches set to track remote ones, but not merge any changes in. git fetch will update only the branch you’re on, but not merge any changes in. git pull will update and merge any remote changes of the current branch you’re on. This would be the one you use to update a local branch. git log --graph --oneline --all git log -p origin/master git push -u origin new-feature # push to \"origin\" remote repo, with \"new-feature\" branch Rebasing instead of merging rewrites history and maintains linearity, making for cleaner code. git checkout new-feature git rebase master git log --graph --oneline git checkout master git merge new-feature # fast forward merge, linear history git push --delete origin new-feature # delete remote branch git branch -d new-feature # delete local branch git fetch git rebase origin/master git add health_checks.py git rebase --continue ","date":"2020-07-28","objectID":"/git-github/:6:0","tags":["git"],"title":"Git与Github使用","uri":"/git-github/"},{"categories":null,"content":"参考 Git scm official Understanding branches in Git CS Visualized: Useful Git Commands - Lydia Hallie What is the difference between ‘git remote update’, ‘git fetch’ and ‘git pull’? Listing and deleting Git commits that are under no branch (dangling?) How can I undo git reset –hard HEAD~1? How do I check out a remote Git branch? ","date":"2020-07-28","objectID":"/git-github/:7:0","tags":["git"],"title":"Git与Github使用","uri":"/git-github/"},{"categories":null,"content":" while位 ","date":"2020-07-26","objectID":"/leetcode-bit-manipulation/:0:0","tags":["leetcode"],"title":"Leetcode：位运算","uri":"/leetcode-bit-manipulation/"},{"categories":null,"content":"342. Power of Four (easy) 简述：判断是否为4的幂 思路：mask挪位置 联系：出自693 # class Solution(object): # def isPowerOfFour(self, num): # \"\"\" # :type num: int # :rtype: bool # \"\"\" # base = 1 while base \u003c= num: # if base == num: # return True # 要点1-1: 偶数位为1 base \u003c\u003c= 2 # return False ","date":"2020-07-26","objectID":"/leetcode-bit-manipulation/:1:0","tags":["leetcode"],"title":"Leetcode：位运算","uri":"/leetcode-bit-manipulation/"},{"categories":null,"content":"476. Number Complement (easy) 简述：将所给数二进制取反输出对应十进制 思路：利用stack 联系：出自342 # class Solution(object): # def findComplement(self, num): # \"\"\" # :type num: int # :rtype: int # \"\"\" # stack = [] # while num: # stack.append(1 ^ (num \u0026 1)) # num = num \u003e\u003e 1 # res = 0 # while stack: res = (res \u003c\u003c 1) + stack.pop() # return res ","date":"2020-07-26","objectID":"/leetcode-bit-manipulation/:2:0","tags":["leetcode"],"title":"Leetcode：位运算","uri":"/leetcode-bit-manipulation/"},{"categories":null,"content":"693. Binary Number with Alternating Bits (easy) 简述：判断所给数二进制是否间隔均不同，即...0101...或者...1010... 思路：while异常退出，逐位判断 联系：342 # class Solution(object): # def hasAlternatingBits(self, n): # \"\"\" # :type n: int # :rtype: bool # \"\"\" # state = n \u0026 1 # while n: # n = n \u003e\u003e 1 # 要点1-1: python位与，位xor if state ^ (n \u0026 1) != 1: # return False # state ^= 1 # return True ","date":"2020-07-26","objectID":"/leetcode-bit-manipulation/:3:0","tags":["leetcode"],"title":"Leetcode：位运算","uri":"/leetcode-bit-manipulation/"},{"categories":null,"content":"477. Total Hamming Distance (medium) 简述：求所有数对hamming距离之和 思路：找出每一位位置上，多少个数为1或为0 联系：342 # class Solution(object): # def totalHammingDistance(self, nums): # \"\"\" # :type nums: List[int] # :rtype: int # \"\"\" # res = 0 # for i in range(32): countZeros = sum([x \u0026 (1\u003c\u003ci) == 0 for x in nums]) res += countZeros * (len(nums) - countZeros) # return res ","date":"2020-07-26","objectID":"/leetcode-bit-manipulation/:4:0","tags":["leetcode"],"title":"Leetcode：位运算","uri":"/leetcode-bit-manipulation/"},{"categories":null,"content":"201. Bitwise AND of Numbers Range (medium) 简述：求区间内所有数位AND值 思路：只要区间跨过1，末位AND值为0，递归求解 联系： # class Solution(object): # def rangeBitwiseAnd(self, m, n): # \"\"\" # :type m: int # :type n: int # :rtype: int # \"\"\" # if m == n: # return m # if n == m + 1: # return m \u0026 n # 要点1-1: 区间跨过1，末位AND值为0，递归 return self.rangeBitwiseAnd(m \u003e\u003e 1, n \u003e\u003e 1) \u003c\u003c 1 与关系 ","date":"2020-07-26","objectID":"/leetcode-bit-manipulation/:5:0","tags":["leetcode"],"title":"Leetcode：位运算","uri":"/leetcode-bit-manipulation/"},{"categories":null,"content":"191. Number of 1 Bits (easy) 简述：求所给数二进制里多少位是1 思路：n \u0026 (n-1)去掉最后一位1 联系： # class Solution(object): # def hammingWeight(self, n): # \"\"\" # :type n: int # :rtype: int # \"\"\" # res = 0 # while n: # n \u0026 (n-1) 去掉最后一位1 n = n \u0026 (n - 1) # res += 1 # return res ","date":"2020-07-26","objectID":"/leetcode-bit-manipulation/:6:0","tags":["leetcode"],"title":"Leetcode：位运算","uri":"/leetcode-bit-manipulation/"},{"categories":null,"content":"231. Power of Two (easy) 简述：判断是否为2的幂 思路：二进制中有且仅有1个1 联系：出自191 # class Solution(object): # def isPowerOfTwo(self, n): # \"\"\" # :type n: int # :rtype: bool # \"\"\" # return n \u0026 (n-1) == 0 and n != 0 ","date":"2020-07-26","objectID":"/leetcode-bit-manipulation/:7:0","tags":["leetcode"],"title":"Leetcode：位运算","uri":"/leetcode-bit-manipulation/"},{"categories":null,"content":"461. Hamming Distance (easy) 简述：求所给数对的hamming distance 思路：先亦或，再数多少个1 联系：出自191 # class Solution(object): # def hammingDistance(self, x, y): # \"\"\" # :type x: int # :type y: int # :rtype: int # \"\"\" num = x ^ y # res = 0 # while num: num = num \u0026 (num - 1) # res += 1 # return res 异或关系 ","date":"2020-07-26","objectID":"/leetcode-bit-manipulation/:8:0","tags":["leetcode"],"title":"Leetcode：位运算","uri":"/leetcode-bit-manipulation/"},{"categories":null,"content":"136. Single Number (easy) 简述：数组中除某元素外每个元素出现两次，找出该元素 思路：碰碰对 联系： # class Solution(object): # def singleNumber(self, nums): # \"\"\" # :type nums: List[int] # :rtype: int # \"\"\" res = 0 # for num in nums: # res ^= num # return res ","date":"2020-07-26","objectID":"/leetcode-bit-manipulation/:9:0","tags":["leetcode"],"title":"Leetcode：位运算","uri":"/leetcode-bit-manipulation/"},{"categories":null,"content":"389. Find the Difference (easy) 简述：字符串shuffle后添加一个字符，找出该字符 思路：碰碰对 联系：出自136 # class Solution(object): # def findTheDifference(self, s, t): # \"\"\" # :type s: str # :type t: str # :rtype: str # \"\"\" # res = 0 # # 要点1-1: python中ord与chr的使用 # for c in s: # res = res ^ ord(c) # for c in t: # res = res ^ ord(c) # return chr(res) ","date":"2020-07-26","objectID":"/leetcode-bit-manipulation/:10:0","tags":["leetcode"],"title":"Leetcode：位运算","uri":"/leetcode-bit-manipulation/"},{"categories":null,"content":" In-Order ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:0:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"230. Kth Smallest Element in a BST (medium) 简述：在BST中，求第k小的值 思路：inorder，记录遍历idx 联系：模板题 # class Solution(object): # def kthSmallest(self, root, k): # \"\"\" # :type root: TreeNode # :type k: int # :rtype: int # \"\"\" # self.idx, self.res = 0, None # self.k = k # self.inorder(root) # return self.res # def inorder(self, root): # if root is None or self.res is not None: # return # if self.res is not None: # return # self.inorder(root.left) # self.idx += 1 # if self.idx == self.k: # self.res = root.val # self.inorder(root.right) ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:1:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"938. Range Sum of BST (easy) 简述：求BST中值介于[L,R]的节点值的和 思路：inorder + 短路判断 联系：出自230 # class Solution(object): # def rangeSumBST(self, root, L, R): # \"\"\" # :type root: TreeNode # :type L: int # :type R: int # :rtype: int # \"\"\" # self.res = 0 # self.L, self.R = L, R # self.inorder(root) # return self.res # def inorder(self, root): # if root is None: # return # self.inorder(root.left) # if self.L \u003c= root.val \u003c= self.R: # self.res += root.val if root.val \u003e self.R: return # self.inorder(root.right) ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:2:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"538. Convert BST to Greater Tree (easy) 简述：改变BST各节点值，使得节点值为后缀和 思路：inorder从后到前遍历 联系：出自230 # class Solution(object): # def convertBST(self, root): # \"\"\" # :type root: TreeNode # :rtype: TreeNode # \"\"\" # self.running_total = 0 # self.inorder(root) # return root # def inorder(self, root): # if root is None: # return None # self.inorder(root.right) root.val += self.running_total self.running_total = root.val # self.inorder(root.left) ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:3:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"501. Find Mode in Binary Search Tree (easy) 简述：求BST中出现最多的值 思路：inorder建立字典 联系：出自230 # class Solution(object): # def findMode(self, root): # \"\"\" # :type root: TreeNode # :rtype: List[int] # \"\"\" # if root is None: # return [] # self.memo = dict() # self.inorder(root) # 要点2-1: python语法，总结value mode = max(self.memo.values()) res = [key for key in self.memo if self.memo[key] == mode] # return res # def inorder(self, root): # if root is None: # return # self.inorder(root.left) # 要点2-2: 异常if用来，初始化key不在字典中的情况 if root.val not in self.memo: self.memo[root.val] = 0 # self.memo[root.val] += 1 # self.inorder(root.right) ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:4:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"530. Minimum Absolute Difference in BST (easy) 简述：在BST节点对中，求最小的相差绝对值 思路：BST的in-order将返回排序数组 联系：出自230 # class Solution(object): # def getMinimumDifference(self, root): # \"\"\" # :type root: TreeNode # :rtype: int # \"\"\" # self.res = sys.maxsize self.prev = None # self.inorder(root) # return self.res # def inorder(self, root): # if root is None: # return # self.inorder(root.left) # if self.prev is not None: # self.res = min(self.res, abs(root.val - self.prev)) # self.prev = root.val # self.inorder(root.right) ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:5:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"783. Minimum Distance Between BST Nodes (easy) 简述：在BST节点对中，求最小的距离（相差） 思路：inorder，记录历史 联系：出自530 # class Solution(object): # def minDiffInBST(self, root): # \"\"\" # :type root: TreeNode # :rtype: int # \"\"\" # self.prev, self.res = None, sys.maxsize # self.inorder(root) # return self.res # def inorder(self, root): # if root is None: # return None # self.inorder(root.left) # if self.prev is not None: # self.res = min(self.res, root.val - self.prev) # self.prev = root.val # self.inorder(root.right) ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:6:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"897. Increasing Order Search Tree (easy) 简述：把BST变为单向链表 思路：记录遍历前的node 联系：出自530 # class Solution(object): # def increasingBST(self, root): # \"\"\" # :type root: TreeNode # :rtype: TreeNode # \"\"\" # self.dummy = TreeNode(0) # self.p = self.dummy # self.inorder(root) # return self.dummy.right # def inorder(self, root): # if root is None: # return # self.inorder(root.left) root.left, self.p.right, self.p.left = None, root, None self.p = self.p.right # self.inorder(root.right) Pre-Order ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:7:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"144. Binary Tree Preorder Traversal (medium) 简述：二叉树pre-order遍历 思路：recursive简单，主要尝试iterative 联系： # class Solution(object): # def preorderTraversal(self, root): # \"\"\" # :type root: TreeNode # :rtype: List[int] # \"\"\" # if root is None: # return [] # 要点1-1: 用stack存待搜索树 stack = [root] # res = [] # while stack: # node = stack.pop() # res.append(node.val) # if node.right is not None: # stack.append(node.right) # if node.left is not None: # stack.append(node.left) # return res ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:8:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"965. Univalued Binary Tree (easy) 简述：判断树中节点值是否单一 思路：遍历时，维护全局变量 联系： # class Solution(object): # def isUnivalTree(self, root): # \"\"\" # :type root: TreeNode # :rtype: bool # \"\"\" # if root.left is None and root.right is None: # return True # self.rootval, self.res = root.val, True # self.preOrder(root) # return self.res # def preOrder(self, root): # \"\"\" # :type root: TreeNode # :rtype: bool # \"\"\" # if root is None: # return # if root.val != self.rootval: # self.res = False # self.preOrder(root.left) # self.preOrder(root.right) Post-Order backtrack ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:9:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"404. Sum of Left Leaves (easy) 简述：求二叉树中，所有左叶节点和 思路：左转向下时标注“左”，右转向下时标注“右” 联系： # class Solution(object): # def sumOfLeftLeaves(self, root): # \"\"\" # :type root: TreeNode # :rtype: int # \"\"\" # self.res = 0 self.inorder(root, False) # return self.res # def inorder(self, root, isLeft): # if root is None: # return # self.inorder(root.left, True) # if root.left is None and root.right is None and isLeft: # self.res += root.val # self.inorder(root.right, False) Non-recursive ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:10:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"510. Inorder Successor in BST II (medium) 简述：给二叉树中某个节点，树中找in-order顺序中的下一个节点（此题节点额外含有：子-\u003e父） 思路：while 联系： # class Solution(object): # def inorderSuccessor(self, node): # \"\"\" # :type node: Node # :rtype: Node # \"\"\" # if node is None: # return None # if node.right: # curr = node.right # while curr.left: # curr = curr.left # return curr # else: # curr = node # while curr.parent and curr == curr.parent.right: # curr = curr.parent # return curr.parent ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:11:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"222. Count Complete Tree Nodes (medium) 简述：complete二叉树 （complete指从上到下，从左到右尽量排满），求树中节点个数 思路：最优复杂度O(logN*logN) 联系：树与二分法很漂亮的结合题 # class Solution(object): # def countNodes(self, root): # \"\"\" # :type root: TreeNode # :rtype: int # \"\"\" # if root is None: # return 0 # height = self.findHeight(root) # res_full = 2**height - 1 # 要点3-1: 二分法模板 # left, right = 1, 2**height # while left + 1 \u003c right: # mid = (left + right) // 2 # if self.pathHasNode(root, height, mid - 1): # left = mid # else: # right = mid # if self.pathHasNode(root, height, right - 1): # return res_full + right # else: # return res_full + left # def findHeight(self, root): # res, p = 0, root # while p.left: # res += 1 # p = p.left # return res # 要点3-2: path encoding def pathHasNode(self, root, height, encoding_int): # p = root # 要点3-3: 构造mask，将encoded path从高位到地位二进制扫描出来 # mask = 2**(height-1) # for _ in range(height): if encoding_int \u0026 mask == 0: # if p.left is None: # return False # p = p.left # else: # if p.right is None: # return False # p = p.right mask \u003e\u003e= 1 # return True ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:12:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"701. Insert into a Binary Search Tree (medium) 简述：将所给值插入BST（假设原BST不含所给值） 思路：用BST性质 联系： # class Solution(object): # def insertIntoBST(self, root, val): # \"\"\" # :type root: TreeNode # :type val: int # :rtype: TreeNode # \"\"\" # 要点1-1：边界情况 if root is None: return TreeNode(val) # p = root # while True: # if val \u003e p.val: # if p.right is None: # p.right = TreeNode(val) # return root # else: # p = p.right # else: # if p.left is None: # p.left = TreeNode(val) # return root # else: # p = p.left ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:13:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":"94. Binary Tree Inorder Traversal (medium) 简述：不用递归，in-order遍历二叉树 思路：左子树为优先级 联系：出自510 # class Solution(object): # def inorderTraversal(self, root): # \"\"\" # :type root: TreeNode # :rtype: List[int] # \"\"\" if root is None: return [] dummy = TreeNode(0) dummy.right = root stack = [dummy] inorder = [] while stack: node = stack.pop() if node.right: # 想处理此节点，先把此节点的右子树加入优先级栈 node = node.right while node: stack.append(node) node = node.left if stack: inorder.append(stack[-1].val) return inorder ","date":"2020-07-16","objectID":"/leetcode-tree-traversal/:14:0","tags":["leetcode"],"title":"Leetcode：树的Traversal","uri":"/leetcode-tree-traversal/"},{"categories":null,"content":" Title -- ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:0:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"100. Same Tree (easy) 简述：判断两棵二叉树是否相同 思路：分治法 联系：模板题 # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None # class Solution(object): # def isSameTree(self, p, q): # \"\"\" # :type p: TreeNode # :type q: TreeNode # :rtype: bool # \"\"\" # if p is None and q is None: # return True # if p is None or q is None: # return False return p.val == q.val and \\ self.isSameTree(p.left, q.left) and \\ self.isSameTree(p.right, q.right) ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:1:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"572. Subtree of Another Tree (easy) 简述：判断t是否为s的子树（相同也算子树） 思路：构造isSame()辅助 联系：出自100 # class Solution(object): # def isSubtree(self, s, t): # \"\"\" # :type s: TreeNode # :type t: TreeNode # :rtype: bool # \"\"\" # if s is None: # return False return self.isSame(s, t) or self.isSubtree(s.left, t) or self.isSubtree(s.right, t) # def isSame(self, s, t): # if s is None and t is None: # return True # if s is None or t is None: # return False # return s.val == t.val and \\ # self.isSame(s.left, t.left) and \\ # self.isSame(s.right, t.right) ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:2:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"101. Symmetric Tree (easy) 简述：判断二叉树是否对称 思路：改造为判断两棵树是否对称 联系：出自100 # class Solution(object): # def isSymmetric(self, root): # \"\"\" # :type root: TreeNode # :rtype: bool # \"\"\" # if root is None: # return True # return self._isSymmetric(root.left, root.right) # 要点1-1: 下划线命名helper函数，添加参数 def _isSymmetric(self, r1, r2): # if r1 is None and r2 is None: # return True # if r1 is None or r2 is None: # return False # return r1.val == r2.val and \\ # self._isSymmetric(r1.left, r2.right) and \\ # self._isSymmetric(r1.right, r2.left) ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:3:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"270. Closest Binary Search Tree Value (easy) 简述：在BST里找最接近目标的值 思路：分治 联系：出自100 # class Solution(object): # def closestValue(self, root, target): # \"\"\" # :type root: TreeNode # :type target: float # :rtype: int # \"\"\" # if root.left is None and root.right is None: # return root.val # if target == root.val: # return root.val # if target \u003e root.val: # if root.right is None: # return root.val # tmp_res = self.closestValue(root.right, target) if abs(root.val - target) \u003c= abs(tmp_res - target): # return root.val # else: # return tmp_res # else: # if root.left is None: # return root.val # tmp_res = self.closestValue(root.left, target) if abs(root.val - target) \u003c= abs(tmp_res - target): # return root.val # else: # return tmp_res ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:4:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"104. Maximum Depth of Binary Tree (easy) 简述：求二叉树最大深度, 通常定义如下 （此题按节点数量算深度） I learned that depth and height are properties of a node: The depth of a node is the number of edges from the node to the tree’s root node. A root node will have a depth of 0. The height of a node is the number of edges on the longest path from the node to a leaf. A leaf node will have a height of 0. Properties of a tree: The height of a tree would be the height of its root node, or equivalently, the depth of its deepest node. The diameter (or width) of a tree is the number of nodes on the longest path between any two leaf nodes. The tree below has a diameter of 6 nodes. depth往根（上）数，height往最远的叶（下）数，height等于maxDepth 思路：分治法，也可以遍历法 联系：出自100 # class Solution(object): # def maxDepth(self, root): # \"\"\" # :type root: TreeNode # :rtype: int # \"\"\" # if root is None: # return 0 # return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1 ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:5:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"111. Minimum Depth of Binary Tree (easy) 简述：求二叉树最小深度 思路：分治法 联系：出自104 # class Solution(object): # def minDepth(self, root): # \"\"\" # :type root: TreeNode # :rtype: int # \"\"\" # if root is None: # return 0 if root.left is None and root.right is None: return 1 if root.left is None: return self.minDepth(root.right) + 1 if root.right is None: return self.minDepth(root.left) + 1 # return min(self.minDepth(root.left), self.minDepth(root.right)) + 1 ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:6:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"226. Invert Binary Tree (easy) 简述：左右反转二叉树 思路：分治 联系：出自100 # class Solution(object): # def invertTree(self, root): # \"\"\" # :type root: TreeNode # :rtype: TreeNode # \"\"\" # if root is None: # return None # if root.left is None and root.right is None: # return root root.left, root.right = self.invertTree(root.right), self.invertTree(root.left) # return root ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:7:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"669. Trim a Binary Search Tree (easy) 简述：裁剪BST，使得裁剪后元素位于区间[L, R](R\u003e=L)内 思路：根节点三种情况：\u003cL, \u003eR, LR之间 联系：出自100 # class Solution(object): # def trimBST(self, root, L, R): # \"\"\" # :type root: TreeNode # :type L: int # :type R: int # :rtype: TreeNode # \"\"\" # if root is None: # return None # if root.val \u003c L: # return self.trimBST(root.right, L, R) # if root.val \u003e R: # return self.trimBST(root.left, L, R) root.left, root.right = self.trimBST(root.left, L, R), self.trimBST(root.right, L, R) # return root ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:8:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"110. Balanced Binary Tree (easy) 简述：判断二叉树是否平衡，即每个节点左右子树高度差不超过1 思路：分治+全局变量 联系：出自104 # class Solution(object): # def isBalanced(self, root): # \"\"\" # :type root: TreeNode # :rtype: bool # \"\"\" # 要点2-1: 添加全局变量 self._isBalanced = True # height = self.findHeight(root) # return self._isBalanced # def findHeight(self, root): # 要点2-2: 添加短路判断 if root is None or not self._isBalanced: return 0 # left_height = self.findHeight(root.left) # right_height = self.findHeight(root.right) # if abs(left_height - right_height) \u003e 1: # self._isBalanced = False # return max(left_height, right_height) + 1 ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:9:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"543. Diameter of Binary Tree (easy) 简述：求二叉树的直径，即节点间的最长路径（可不经过根节点） 思路：分治+全局变量 联系：出自110 # class Solution(object): # def diameterOfBinaryTree(self, root): # \"\"\" # :type root: TreeNode # :rtype: int # \"\"\" # 要点1-1: 添加全局变量 self.res = 0 # self.findDepth(root) # return self.res # def findDepth(self, root): # if root is None: # return 0 # left_depth = self.findDepth(root.left) # right_depth = self.findDepth(root.right) self.res = max(self.res, left_depth + right_depth) # return max(left_depth, right_depth) + 1 ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:10:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"124. Binary Tree Maximum Path Sum (hard) 简述：求二叉树中路径最大和（任意节点到任意节点，不必经过根节点） 思路：分治+全局变量 联系：出自110 # class Solution(object): # def maxPathSum(self, root): # \"\"\" # :type root: TreeNode # :rtype: int # \"\"\" # 要点1-1: python最小整数 self.res = -sys.maxsize - 1 # self.maxSumFromRoot(root) # return self.res # def maxSumFromRoot(self, root): # if root is None: # return 0 # if root.left is None and root.right is None: # self.res = max(self.res, root.val) # return root.val # left_max = self.maxSumFromRoot(root.left) # right_max = self.maxSumFromRoot(root.right) self.res = max(self.res, root.val + \\ max(0, left_max, right_max, left_max + right_max)) # return max(root.val, root.val + left_max, root.val + right_max) ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:11:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"257. Binary Tree Paths (easy) 简述：打印二叉树所有根到叶路径 思路：分治 联系：出自100 # class Solution(object): # def binaryTreePaths(self, root): # \"\"\" # :type root: TreeNode # :rtype: List[str] # \"\"\" # if root is None: # return [] # if root.left is None and root.right is None: # return [str(root.val)] # left_paths = self.binaryTreePaths(root.left) # right_paths = self.binaryTreePaths(root.right) # res = [] # res += [str(root.val) + '-\u003e' + p for p in left_paths] # res += [str(root.val) + '-\u003e' + p for p in right_paths] # return res ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:12:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"654. Maximum Binary Tree (medium) 简述：给数组，按规则构造树，规则：数组最大值为根，最大值左边为左子树，最大值右边为右子树，左右子树继续符合规则 思路：递归定义，分治 联系：出自100 # class Solution(object): # def constructMaximumBinaryTree(self, nums): # \"\"\" # :type nums: List[int] # :rtype: TreeNode # \"\"\" # if not nums: # return None # root = TreeNode(max(nums)) # root.left = self.constructMaximumBinaryTree(nums[0:nums.index(max(nums))]) # root.right = self.constructMaximumBinaryTree(nums[nums.index(max(nums))+1:]) # return root ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:13:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"108. Convert Sorted Array to Binary Search Tree (easy) 简述：给已排序的数组，构造相应的平衡BST 思路：中点作为pivot 联系：出自654 # class Solution(object): # def sortedArrayToBST(self, nums): # \"\"\" # :type nums: List[int] # :rtype: TreeNode # \"\"\" # if not nums: # return None # mid = len(nums) // 2 # root = TreeNode(nums[mid]) # root.left = self.sortedArrayToBST(nums[0: mid]) # root.right = self.sortedArrayToBST(nums[mid + 1:]) # return root ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:14:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"606. Construct String from Binary Tree (easy) 简述：按preorder规则通过添加括号把二叉树转为字符串，以保证树与字符串的一一对应。 思路：如果左子树为空，可添加一对空括号 联系：出自654 # class Solution(object): # def tree2str(self, t): # \"\"\" # :type t: TreeNode # :rtype: str # \"\"\" # if t is None: # return \"\" # if t.left is None and t.right is None: # return str(t.val) if t.left is None: return str(t.val) + '()(' + self.tree2str(t.right) + ')' if t.right is None: return str(t.val) + '(' + self.tree2str(t.left) + ')' # return str(t.val) + '(' + self.tree2str(t.left) + ')(' + self.tree2str(t.right) + ')' ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:15:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"1120. Maximum Average Subtree (medium) 简述：求子树中最大平均值 思路：维护平均值，辅助函数返回树的总和与总节点个数 联系：出自110 # class Solution(object): # def maximumAverageSubtree(self, root): # \"\"\" # :type root: TreeNode # :rtype: float # \"\"\" # 要点1-1: 初始为最小浮点数 self.res = float('-inf') # res_cnt, res_sum = self.findSum(root) # return self.res # def findSum(self, root): # if root is None: # return 0, 0 # if root.left is None and root.right is None: # self.res = max(self.res, root.val) # return 1, root.val # left_cnt, left_sum = self.findSum(root.left) # right_cnt, right_sum = self.findSum(root.right) # res_cnt = left_cnt + right_cnt + 1 # res_sum = left_sum + right_sum + root.val # self.res = max(self.res, res_sum * 1.0 / res_cnt) # return res_cnt, res_sum ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:16:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"563. Binary Tree Tilt (easy) 简述：按定义求树的tilt，定义：节点tilt-左子树节点和与右子树节点和差值的绝对值，树的tilt-所有节点tilt的和 思路：辅助函数findSum(), 维护全局变量 联系：出自110 # class Solution(object): # def findTilt(self, root): # \"\"\" # :type root: TreeNode # :rtype: int # \"\"\" # self.res = 0 # total_sum = self.findSum(root) # return self.res # def findSum(self, root): # if root is None: # return 0 # if root.left is None and root.right is None: # return root.val # left_sum, right_sum = self.findSum(root.left), self.findSum(root.right) self.res += abs(left_sum - right_sum) return left_sum + right_sum + root.val ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:17:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"366. Find Leaves of Binary Tree (medium) 简述：二叉树剥洋葱，返回最外层（叶节点），然后次外层（倒数第二层节点），以此类推 思路：标注节点高度，构造节点-\u003e高度映射，再返回反向索引 联系：出自110 # class Solution(object): # def findLeaves(self, root): # \"\"\" # :type root: TreeNode # :rtype: List[List[int]] # \"\"\" # 要点2-1: 全局变量，映射 height_memo = dict() # self.label_height(root, height_memo) # # 要点2-2: 反向索引inverted index return self.convert_memo(height_memo) # def label_height(self, root, height_memo): # if root is None: # return 0 # if root.left is None and root.right is None: # height_memo[root] = 1 # return 1 # left_height = self.label_height(root.left, height_memo) # right_height = self.label_height(root.right, height_memo) # res_height = max(left_height, right_height) + 1 # height_memo[root] = res_height # return res_height # def convert_memo(self, height_memo): # res = dict() # for k, v in height_memo.items(): # if v not in res: # res[v] = list() # res[v].append(k.val) # ans = [] # for i in range(len(res.keys())): # ans.append(res[i + 1]) # return ans ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:18:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"617. Merge Two Binary Trees (easy) 简述：合并两棵二叉树，合并后节点为两棵对应节点之和 思路：分治 联系：出自669 # class Solution(object): # def mergeTrees(self, t1, t2): # \"\"\" # :type t1: TreeNode # :type t2: TreeNode # :rtype: TreeNode # \"\"\" # if t1 is None: # return t2 # if t2 is None: # return t1 # root = TreeNode(t1.val + t2.val) # root.left = self.mergeTrees(t1.left, t2.left) # root.right = self.mergeTrees(t1.right, t2.right) # return root ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:19:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"1490. Clone N-ary Tree (medium) 简述：深拷贝N元树 思路：递归定义，分治 联系：出自100 # class Solution(object): # def cloneTree(self, root): # \"\"\" # :type root: Node # :rtype: Node # \"\"\" # if root is None: # return None # root_copy = Node(val=root.val) # for el in root.children: # root_copy.children.append(self.cloneTree(el)) # return root_copy ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:20:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"814. Binary Tree Pruning (medium) 简述：二叉树树中节点只能为0或1，裁剪二叉树，使得最后没有全为0的子树 思路：分治 联系：出自100 # class Solution(object): # def pruneTree(self, root): # \"\"\" # :type root: TreeNode # :rtype: TreeNode # \"\"\" # if root is None: # return None # if root.left is None and root.right is None: # if root.val == 0: # return None # else: # return root # left_pruned = self.pruneTree(root.left) # right_pruned = self.pruneTree(root.right) if left_pruned is None and right_pruned is None and root.val == 0: return None # root.left, root.right = left_pruned, right_pruned # return root ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:21:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"236. Lowest Common Ancestor of a Binary Tree (medium) 简述：求两节点在二叉树里的LCA（假设两节点都在树中） 思路：分治 联系：出自100 # class Solution(object): # 要点1-1: 三种情况：1）两个节点都在树中返回lca， 2）一个在树中返回该节点，3）两个都不在返回None def lowestCommonAncestor(self, root, p, q): # \"\"\" # :type root: TreeNode # :type p: TreeNode # :type q: TreeNode # :rtype: TreeNode # \"\"\" # if root is None: # return None # if root == p or root == q: # return root # left_lca = self.lowestCommonAncestor(root.left, p, q) # right_lca = self.lowestCommonAncestor(root.right, p, q) # if left_lca and right_lca: # return root # if left_lca: # return left_lca # if right_lca: # return right_lca # return None ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:22:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"235. Lowest Common Ancestor of a Binary Search Tree (easy) 简述：求两节点在BST里的LCA（假设两节点都在树中） 思路：分治，根据情况走一边子树 联系：出自236 # class Solution(object): # def lowestCommonAncestor(self, root, p, q): # \"\"\" # :type root: TreeNode # :type p: TreeNode # :type q: TreeNode # :rtype: TreeNode # \"\"\" # if root is None: # return None # if root == p or root == q: # return root # if p.val \u003c root.val \u003c q.val or q.val \u003c root.val \u003c p.val: # return root # if root.val \u003c p.val: # return self.lowestCommonAncestor(root.right, p, q) # else: # return self.lowestCommonAncestor(root.left, p, q) ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:23:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"156. Binary Tree Upside Down (medium) 简述：上下翻转二叉树，所给二叉树的性质：右节点是空或是有兄弟节点的叶节点 思路：画图按例子翻转 联系：出自226 # class Solution(object): # def upsideDownBinaryTree(self, root): # \"\"\" # :type root: TreeNode # :rtype: TreeNode # \"\"\" # if root is None: # return None # if root.left is None and root.right is None: # return root # res = self.upsideDownBinaryTree(root.left) root.left.left, root.left.right = root.right, root # root.left, root.right = None, None # return res ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:24:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"114. Flatten Binary Tree to Linked List (medium) 简述：in-place转化二叉树成链表结构 思路：分治 联系：出自226 # class Solution(object): # def flatten(self, root): # \"\"\" # :type root: TreeNode # :rtype: None Do not return anything, modify root in-place instead. # \"\"\" # tail = self.flatten_tail(root) # def flatten_tail(self, root): # if root is None: # return None # if root.left is None and root.right is None: # return root # if root.left is None: # return self.flatten_tail(root.right) # if root.right is None: # left_tail = self.flatten_tail(root.left) # root.left, root.right = None, root.left # return left_tail # left_tail = self.flatten_tail(root.left) # right_tail = self.flatten_tail(root.right) # root.left, root.right, left_tail.right = None, root.left, root.right # return right_tail VERSION II (from girikuncoro’s post) # class Solution(object): # def __init__(self): self.prev = None # def flatten(self, root): # \"\"\" # :type root: TreeNode # :rtype: None Do not return anything, modify root in-place instead. # \"\"\" # if root is None: # return # self.flatten(root.right) # self.flatten(root.left) # # 要点1-1: 先右子树再左子树，这样会把右子树通过prev移花接木到左子树尾部 root.right = self.prev # root.left = None # self.prev = root ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:25:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"298. Binary Tree Longest Consecutive Sequence (medium) 简述：在二叉树中找连续值路径（路径这里指从父节点向下） 思路：分治，维护全局变量 联系：出自110 # class Solution(object): # def longestConsecutive(self, root): # \"\"\" # :type root: TreeNode # :rtype: int # \"\"\" # self.res = 0 # self.longest_from_root(root) # return self.res # def longest_from_root(self, root): # if root is None: # return 0 # if root.left is None and root.right is None: # self.res = max(self.res, 1) # return 1 # 要点1-1: 无论当前节点与左右子节点是否差1，都要执行搜索 left_longest = self.longest_from_root(root.left) right_longest = self.longest_from_root(root.right) # curr = 1 # if root.left and root.val + 1 == root.left.val: # curr = max(curr, left_longest + 1) # if root.right and root.val + 1 == root.right.val: # curr = max(curr, right_longest + 1) # self.res = max(self.res, curr) # return curr ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:26:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"285. Inorder Successor in BST (medium) 简述：BST中找所给节点的下一个按序节点，即比所给节点大的最小节点 思路：分治 联系：出自100 # class Solution(object): # def inorderSuccessor(self, root, p): # \"\"\" # :type root: TreeNode # :type p: TreeNode # :rtype: TreeNode # \"\"\" # if root is None: # return None # if p.val \u003e= root.val: # return self.inorderSuccessor(root.right, p) # left_res = self.inorderSuccessor(root.left, p) # if left_res is None: # return root # return left_res ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:27:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"671. Second Minimum Node In a Binary Tree (easy) 简述：二叉树满足：每个节点有0或2个子节点，当2个子节点时，root.val = min(root.left.val, root.right.val)，求树中第二小的节点值 思路：分治，注意比较时的初始化 联系：出自100 # class Solution(object): # def findSecondMinimumValue(self, root): # \"\"\" # :type root: TreeNode # :rtype: int # \"\"\" # if root is None: # return -1 # if root.left is None and root.right is None: # return -1 # left_res = self.findSecondMinimumValue(root.left) # right_res = self.findSecondMinimumValue(root.right) # 要点1-1: 初始化比较值，题目要求无第二最小值，返回-1 if left_res == -1: left_res = sys.maxsize if right_res == -1: right_res = sys.maxsize # if root.val == root.left.val == root.right.val: res = min(left_res, right_res) return res if res != sys.maxsize else -1 # else: # if root.val == root.left.val: # return min(left_res, root.right.val) # else: # return min(right_res, root.left.val) ","date":"2020-07-10","objectID":"/leetcode-divide-conquer/:28:0","tags":["leetcode"],"title":"Leetcode：树的Divide \u0026 Conquer","uri":"/leetcode-divide-conquer/"},{"categories":null,"content":"模板 # def binarySearch(nums, target): # if len(nums) == 0: # return -1 # start, end = 0, len(nums) - 1 while start + 1 \u003c end: # 要点3-1 mid = (start + end) // 2 # 要点3-2: python动态数据类型 # if nums[start] \u003c target: start = mid # 要点3-3: mid不+-1 # else: # end = mid # if nums[start] == target: # return start # if nums[end] == target: # return end # return -1 找位置 ","date":"2020-07-07","objectID":"/leetcode-binary-search/:0:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"34. Find First and Last Position of Element in Sorted Array (medium) 简述：已排序数组，求目标值第一次和最后一次出现的位置 思路：拆解为两个子函数，findFirst()和findLast() 联系：基础模板题 # class Solution(object): # def searchRange(self, nums, target): # \"\"\" # :type nums: List[int] # :type target: int # :rtype: List[int] # \"\"\" # first, last = self.findFirst(nums, target), self.findLast(nums, target) # return [first, last] # def findFirst(self, nums, target): # if len(nums) == 0: # return -1 # left, right = 0, len(nums) - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 if nums[mid] \u003c target: # 要点2-1 # left = mid # else: # right = mid # if nums[left] == target: # return left # if nums[right] == target: # return right # return -1 # def findLast(self, nums, target): # if len(nums) == 0: # return -1 # left, right = 0, len(nums) - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 if nums[mid] \u003e target: # 要点2-2 # right = mid # else: # left = mid # if nums[right] == target: # return right # if nums[left] == target: # return left # return -1 ","date":"2020-07-07","objectID":"/leetcode-binary-search/:1:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"35. Search Insert Position (easy) 简述：已排序数组，求插入位置保证插入后依然排序 思路：类似findFirst() 联系：出自34 # class Solution(object): # def searchInsert(self, nums, target): # \"\"\" # :type nums: List[int] # :type target: int # :rtype: int # \"\"\" # # 要点1-1: 注意输入边界情况 if target \u003c nums[0]: return 0 if target \u003e nums[-1]: return len(nums) # left, right = 0, len(nums) - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 # if nums[mid] \u003c target: # left = mid # else: # right = mid # if nums[left] \u003e= target: # return left # return right ","date":"2020-07-07","objectID":"/leetcode-binary-search/:2:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"744. Find Smallest Letter Greater Than Target (easy) 简述：已排序的数组，求大于目标的最前位置 思路：类似findFirst() 联系：出自34 # class Solution(object): # def nextGreatestLetter(self, letters, target): # \"\"\" # :type letters: List[str] # :type target: str # :rtype: str # \"\"\" # left, right = 0, len(letters) - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 # if letters[mid] \u003c= target: # left = mid # else: # right = mid # if letters[left] \u003e target: # return letters[left] # if letters[right] \u003e target: # return letters[right] # return letters[0] ","date":"2020-07-07","objectID":"/leetcode-binary-search/:3:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"702. Search in a Sorted Array of Unknown Size (medium) 简述：已排序数组，但不知size，求目标值位置 思路：扩右边直到包含目标值，再二分 联系：出自34 # class Solution(object): # def search(self, reader, target): # \"\"\" # :type reader: ArrayReader # :type target: int # :rtype: int # \"\"\" # # 要点1-1: 倍增右边界 right = 1 while reader.get(right) \u003c target: right *= 2 left = right // 2 # while left + 1 \u003c right: # mid = (left + right) // 2 # if reader.get(mid) == target: # return mid # if reader.get(mid) \u003c target: # left = mid # else: # right = mid # if reader.get(left) == target: # return left # if reader.get(right) == target: # return right # return -1 ","date":"2020-07-07","objectID":"/leetcode-binary-search/:4:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"74. Search a 2D Matrix (medium) 简述：已排序的2D数组(每行排序，一行最后元素小于下行最前元素)，求目标值是否存在 思路：只是1D数组layout变化，模板不变 联系：出自34 # class Solution(object): # def searchMatrix(self, matrix, target): # \"\"\" # :type matrix: List[List[int]] # :type target: int # :rtype: bool # \"\"\" # if not matrix or not matrix[0]: # return False # M, N = len(matrix), len(matrix[0]) # left, right = 0, M * N - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 # row, col = mid // N, mid % N # if matrix[row][col] == target: # return True # if matrix[row][col] \u003c target: # left = mid # else: # right = mid # return matrix[left//N][left%N] == target or matrix[right//N][right%N] == target ","date":"2020-07-07","objectID":"/leetcode-binary-search/:5:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"240. Search a 2D Matrix II (medium) 简述：已排序的2D数组(每行排序，每列排序)，求目标值是否存在 思路：斜对角线一个个坐标走，不是二分题 联系：出自74，不是二分 # class Solution(object): # def searchMatrix(self, matrix, target): # \"\"\" # :type matrix: List[List[int]] # :type target: int # :rtype: bool # \"\"\" # if not matrix or not matrix[0]: # return False # M, N = len(matrix), len(matrix[0]) # x, y = M - 1, 0 # while True: # if not (0 \u003c= x \u003c M and 0 \u003c= y \u003c N): # return False # if matrix[x][y] == target: # return True # # 要点1-1: 不是二分，走坐标 if matrix[x][y] \u003e target: x -= 1 else: y += 1 # return False ","date":"2020-07-07","objectID":"/leetcode-binary-search/:6:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"658. Find K Closest Elements (medium) 简述：已排序数组，求k个最邻近目标的元素们 思路：先找到最邻近目标的元素，再往两边扩展 联系：出自34 # class Solution(object): # def findClosestElements(self, arr, k, x): # \"\"\" # :type arr: List[int] # :type k: int # :type x: int # :rtype: List[int] # \"\"\" # left, right = 0, len(arr) - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 # if arr[mid] \u003c x: # left = mid # else: # right = mid # # 要点1-1: 最后的范围左右开区间(left, right) return self.expand(arr, left, right, k, x) # def expand(self, arr, left, right, k, x): # cnt = 0 # while cnt \u003c k: # if right \u003e= len(arr) or abs(arr[left] - x) \u003c= abs(arr[right] - x): # left -= 1 # else: # right += 1 # cnt += 1 return arr[left + 1 : left + 1 + k] 非单调 ","date":"2020-07-07","objectID":"/leetcode-binary-search/:7:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"153. Find Minimum in Rotated Sorted Array (medium) 简述：rotate过的排序数组(无重复元素)，求最小值 思路：pivot出现在前半段，经过顺序为 中\u003c右\u003c左，pivot出现在后半段，经过顺序为 右\u003c左\u003c中 联系：左右关系无法判断, 应判断中右关系 # class Solution(object): # def findMin(self, nums): # \"\"\" # :type nums: List[int] # :rtype: int # \"\"\" # left, right = 0, len(nums) - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 if nums[mid] \u003e nums[right]: # left = mid # else: # right = mid # return min(nums[left], nums[right]) ","date":"2020-07-07","objectID":"/leetcode-binary-search/:8:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"33. Search in Rotated Sorted Array (medium) 简述：rotate过的排序数组(无重复元素)，求目标值位置 思路：先找pivot，再传统二分 联系：出自153 # class Solution(object): # def search(self, nums, target): # \"\"\" # :type nums: List[int] # :type target: int # :rtype: int # \"\"\" # if len(nums) == 0: # return -1 # pivot = self.findPivot(nums) # L = len(nums) # left, right = 0, L - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 # # 要点1-1: 访问排序数组时转化坐标 if nums[(mid + pivot) % L] \u003e target: # right = mid # else: # left = mid # if nums[(left + pivot) % L] == target: # return (left + pivot) % L # if nums[(right + pivot) % L] == target: # return (right + pivot) % L # return -1 def findPivot(self, nums): # left, right = 0, len(nums) - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 # if nums[mid] \u003e nums[right]: # left = mid # else: # right = mid # if nums[left] \u003c nums[right]: # return left # else: # return right ","date":"2020-07-07","objectID":"/leetcode-binary-search/:9:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"154. Find Minimum in Rotated Sorted Array II (hard) 简述：rotate过的排序数组(有重复元素)，求最小元素 思路：11111011 (最坏情况linear查找) 联系：出自33 # class Solution(object): # def findMin(self, nums): # \"\"\" # :type nums: List[int] # :rtype: int # \"\"\" # left, right = 0, len(nums) - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 # if nums[right] \u003e nums[mid]: # right = mid # elif nums[right] \u003c nums[mid]: # left = mid else: # 要点1-1: 如何把线性查找与二分查找合并 right = right - 1 # return min(nums[left], nums[right]) ","date":"2020-07-07","objectID":"/leetcode-binary-search/:10:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"852. Peak Index in a Mountain Array (easy) 简述：山形数组，求山峰位置 思路：思考山峰若在前半段发生什么(A[mid-1] \u003e A[mid] \u003e A[mid+1])，若在后半段发生什么(A[mid-1] \u003c A[mid] \u003c A[mid+1]) 联系：思考方式出自153，都是在想目标出现前后半段的性质差别，二分保证充要 # class Solution(object): # def peakIndexInMountainArray(self, A): # \"\"\" # :type A: List[int] # :rtype: int # \"\"\" # left, right = 0, len(A) - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 # if A[mid] \u003e A[mid+1] and A[mid] \u003e A[mid-1]: # return mid # if A[mid] \u003e A[mid+1] and A[mid] \u003c A[mid-1]: # right = mid # else: # left = mid # if A[left] \u003e A[right]: # return left # else: # return right ","date":"2020-07-07","objectID":"/leetcode-binary-search/:11:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"162. Find Peak Element (medium) 简述：重峦叠嶂数组(相邻不等)，求任意一个山峰位置 思路：类似852，但并不充要 # class Solution(object): # def findPeakElement(self, nums): # \"\"\" # :type nums: List[int] # :rtype: int # \"\"\" # left, right = 0, len(nums) - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 # if nums[mid] \u003e nums[mid - 1] and nums[mid] \u003e nums[mid + 1]: # return mid # if nums[mid] \u003e nums[mid - 1] and nums[mid] \u003c nums[mid + 1]: # left = mid # else: # right = mid # if nums[left] \u003e nums[right]: # return left # else: # return right 找状态 ","date":"2020-07-07","objectID":"/leetcode-binary-search/:12:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"278. First Bad Version (easy) 简述：OOOOXXX, 求第一个失败版本idx 思路：目标出现前后半段导致mid状态差别 联系： # # The isBadVersion API is already defined for you. # # @param version, an integer # # @return a bool # # def isBadVersion(version): # class Solution(object): # def firstBadVersion(self, n): # \"\"\" # :type n: int # :rtype: int # \"\"\" # left, right = 1, n # while left + 1 \u003c right: # mid = (left + right) // 2 # if isBadVersion(mid): # right = mid # else: # left = mid # if isBadVersion(left): # return left # return right ","date":"2020-07-07","objectID":"/leetcode-binary-search/:13:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"374. Guess Number Higher or Lower (easy) 简述：1-n猜数字，api回答高低，求目标数字 思路：从目标开始后面都会猜高 联系：出自278 # # The guess API is already defined for you. # # @param num, your guess # # @return -1 if my number is lower, 1 if my number is higher, otherwise return 0 # # def guess(num): # class Solution(object): # def guessNumber(self, n): # \"\"\" # :type n: int # :rtype: int # \"\"\" # left, right = 1, n # while left + 1 \u003c right: # mid = (left + right) // 2 # api_res = guess(mid) # if api_res == 0: # return mid # if api_res == 1: # left = mid # else: # right = mid # return left if guess(left) == 0 else right ","date":"2020-07-07","objectID":"/leetcode-binary-search/:14:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"69. Sqrt(x) (easy) 简述：求根号x，取整 思路：从正确答案后，平方大于x 联系：出自278 # class Solution(object): # def mySqrt(self, x): # \"\"\" # :type x: int # :rtype: int # \"\"\" # left, right = 1, x # while left + 1 \u003c right: # mid = (left + right) // 2 # if mid * mid == x: # return mid # if mid * mid \u003e x: # right = mid # else: # left = mid # return right if right * right \u003c= x else left ","date":"2020-07-07","objectID":"/leetcode-binary-search/:15:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"302. Smallest Rectangle Enclosing Black Pixels (hard) 简述：二值化图片，黑色像素相连，给一个黑色像素坐标，求包围黑色区域的最小矩形面积 思路：从黑色坐标向上下左右找边界，一旦超过边界将再无黑色行列 联系：出自278 # class Solution(object): # def minArea(self, image, x, y): # \"\"\" # :type image: List[List[str]] # :type x: int # :type y: int # :rtype: int # \"\"\" # m, n = len(image), len(image[0]) # def row_has_black(row): # for j in range(n): # if image[row][j] == '1': # return True # return False # def col_has_black(col): # for i in range(m): # if image[i][col] == '1': # return True # return False def find_upper(): # left, right = 0, x # while left + 1 \u003c right: # mid = (left + right) // 2 # if row_has_black(mid): # right = mid # else: # left = mid # if row_has_black(left): # return left # return right def find_lower(): # left, right = x, m - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 # if row_has_black(mid): # left = mid # else: # right = mid # if row_has_black(right): # return right # return left def find_left(): # left, right = 0, y # while left + 1 \u003c right: # mid = (left + right) // 2 # if col_has_black(mid): # right = mid # else: # left = mid # if col_has_black(left): # return left # return right def find_right(): # left, right = y, n - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 # if col_has_black(mid): # left = mid # else: # right = mid # if col_has_black(right): # return right # return left # upper, lower, left, right = find_upper(), find_lower(), find_left(), find_right() return (lower - upper + 1) * (right - left + 1) 二分答案 ","date":"2020-07-07","objectID":"/leetcode-binary-search/:16:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"274. H-Index (medium) 简述：引用数组，求hIndex–h篇每篇至少h引用，其余每篇不超过h引用 思路：二分答案，答案经过一次状态改变 联系： # class Solution(object): # def hIndex(self, citations): # \"\"\" # :type citations: List[int] # :rtype: int # \"\"\" # if not citations: # return 0 # left, right = 0, len(citations) # while left + 1 \u003c right: # h = (left + right) // 2 cnt = sum([x \u003e= h for x in citations]) # if cnt == h: # return h # if cnt \u003e h: # left = h # else: # right = h # cnt = sum([x \u003e= right for x in citations]) # if cnt \u003e= right: # return right # return left ","date":"2020-07-07","objectID":"/leetcode-binary-search/:17:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"275. H-Index II (hard) 简述：引用数组(已排序)，求hIndex–h篇每篇至少h引用，其余每篇不超过h引用 思路：不是二分答案，注意结尾情况 联系：出自274，但不属于二分答案 # class Solution(object): # def hIndex(self, citations): # \"\"\" # :type citations: List[int] # :rtype: int # \"\"\" # if not citations: # return 0 # N = len(citations) # left, right = 0, N - 1 # while left + 1 \u003c right: # mid = (left + right) // 2 # if N - mid \u003e= citations[mid]: # left = mid # else: # right = mid # 要点1-1: 结尾情况很难想全 if N - right \u003e= citations[right]: return citations[right] if N - right \u003e= citations[left]: return N - right if N - left \u003e= citations[left]: return citations[left] return N - left ","date":"2020-07-07","objectID":"/leetcode-binary-search/:18:0","tags":["leetcode"],"title":"Leetcode：二分查找","uri":"/leetcode-binary-search/"},{"categories":null,"content":"Coursera specializations offered by UM Course I Time Value of Money ","date":"2020-07-06","objectID":"/coursera-umich-fffsdm/:0:0","tags":null,"title":"Foundational Finance for Strategic Decision Making","uri":"/coursera-umich-fffsdm/"},{"categories":null,"content":"Simple Future Value (FV) PV = Present Value (unit: $) FV = Present Value (unit: $) n = # of Periods (#) r = Interest Rate (%, not $) \u003e 0 (assumption) Insight: A dollar today is worth more than a dollar tomorrow. You cannot compare money across time. Example: Power of Compounding! Peter Minuit bought the Manhattan Island from Native Americans for $24 in 1626. Suppose that Native Americans could have earned 6% on their investments all these years. How much would they have today (year 2020)? $224,244,683,837.58 Some Important Formulae Future Value of a Single Cash Flow Invested for n Periods $$F = P(1+r)^n$$ Present Value of a Single Cash Flow Received n Periods from Now $$P = F\\frac{1}{(1+r)^n}$$ Future Value of a Stream of Cash Flows as of n Periods from Now $$F = C_1(1+r)^{n-1} + C_2(1+r)^{n-2} + \\cdots + C_{n-1}(1+r) + C_n$$ Present Value of a Stream of Cash Flows $$P = \\frac{C_1}{1+r} + \\frac{C_2}{(1+r)^2} + \\cdots + \\frac{C_n}{(1+r)^n}$$ ","date":"2020-07-06","objectID":"/coursera-umich-fffsdm/:1:0","tags":null,"title":"Foundational Finance for Strategic Decision Making","uri":"/coursera-umich-fffsdm/"},{"categories":null,"content":"Hugo: 一个静态网页生成器，将markdown格式的博文编译为HTML，CSS，JavaScript Github Pages: 静态网页托管服务，将hugo转化后的博客公开给读者访问 reference: Mogeko博客《使用 Hugo + GitHub Pages 搭建个人博客》 ","date":"2020-07-03","objectID":"/hugo-blog-site/:0:0","tags":null,"title":"使用 Hugo + Github Pages 搭建个人博客","uri":"/hugo-blog-site/"},{"categories":null,"content":"Step 1 - 创建Github Pages对应的repo repo name: [username].github.io reference: Github Pages official page ","date":"2020-07-03","objectID":"/hugo-blog-site/:1:0","tags":null,"title":"使用 Hugo + Github Pages 搭建个人博客","uri":"/hugo-blog-site/"},{"categories":null,"content":"Step 2 - 安装Hugo (Mac系统) brew install hugo reference: Hugo official quickstart ","date":"2020-07-03","objectID":"/hugo-blog-site/:2:0","tags":null,"title":"使用 Hugo + Github Pages 搭建个人博客","uri":"/hugo-blog-site/"},{"categories":null,"content":"Step 3 - 使用Hugo创建本地博客文件夹 hugo new site myBlog cd myBlog 创建myBlog文件夹来存放博客站点。其中： content存放markdown博文 themes存放皮肤主题 config.toml配置站点 ","date":"2020-07-03","objectID":"/hugo-blog-site/:3:0","tags":null,"title":"使用 Hugo + Github Pages 搭建个人博客","uri":"/hugo-blog-site/"},{"categories":null,"content":"Step 4 - 安装皮肤主题 此博客使用mogege主题，原repo 安装主题至themes下 git clone https://github.com/Mogeko/mogege.git themes/mogege ","date":"2020-07-03","objectID":"/hugo-blog-site/:4:0","tags":null,"title":"使用 Hugo + Github Pages 搭建个人博客","uri":"/hugo-blog-site/"},{"categories":null,"content":"Step 5 - 创建页面 hugo new about.md hugo new posts/my-first-post.md 在content下自动生成页面，meta data包括： title: 页面标题 date: 创建时间 draft: 是否为草稿。建立server时，草稿需要加上--buildDrafts参数才能在public正确显示 description: 描述 (optional) tags:: 标签，用于文章分类 (optional) ","date":"2020-07-03","objectID":"/hugo-blog-site/:5:0","tags":null,"title":"使用 Hugo + Github Pages 搭建个人博客","uri":"/hugo-blog-site/"},{"categories":null,"content":"Step 6 - 配置网站 修改配置文件config.toml baseURL = \"https://xuwenzhe.github.io\" # \u003chead\u003e 里面的 baseurl 信息，填你的博客地址 title = \"Wenzhe's Blog\" # 浏览器的标题 languageCode = \"zh-cn\" # 语言 hasCJKLanguage = true # 开启可以让「字数统计」统计汉字 theme = \"mogege\" # 主题 (需要自己下载) paginate = 11 # 每页的文章数 enableEmoji = true # 支持 Emoji enableRobotsTXT = true # 支持 robots.txt googleAnalytics = \"\" # Google 统计 id preserveTaxonomyNames = true [blackfriday] hrefTargetBlank = true nofollowLinks = true noreferrerLinks = true [Permalinks] posts = \"/:year/:filename/\" [menu] [[menu.main]] name = \"Blog\" url = \"/posts/\" weight = 1 [[menu.main]] name = \"Categories\" url = \"/categories/\" weight = 2 [[menu.main]] name = \"Tags\" url = \"/tags/\" weight = 3 [[menu.main]] name = \"About\" url = \"/about/\" weight = 4 [params] since = 2020 author = \"Wenzhe\" # Author's name avatar = \"/images/me/avatar.png\" # Author's avatar subtitle = \"Just for Fun\" # Subtitle cdn_url = \"\" # Base CDN URL home_mode = \"\" # post or other enableGitalk = true # gitalk 评论系统 google_verification = \"\" description = \"\" # (Meta) 描述 keywords = \"\" # site keywords beian = \"\" baiduAnalytics = \"\" license= '本文采用\u003ca rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003e知识共享署名-非商业性使用 4.0 国际许可协议\u003c/a\u003e进行许可' [params.social] GitHub = \"https://github.com/xuwenzhe\" Twitter = \"xxoo\" Email = \"xxoo\" Instagram = \"xxoo\" Wechat = \"/images/me/wechat.png\" # Wechat QRcode image Facebook = \"xxoo\" Telegram = \"xxoo\" Dribbble = \"xxoo\" Medium = \"xxoo\" [params.gitalk] # Github: https://github.com/gitalk/gitalk clientID = \"\" # Your client ID clientSecret = \"\" # Your client secret repo = \"\" # The repo to store comments owner = \"\" # Your GitHub ID admin= \"\" # Required. Github repository owner and collaborators. (Users who having write access to this repository) id= \"location.pathname\" # The unique id of the page. labels= \"gitalk\" # Github issue labels. If you used to use Gitment, you can change it perPage= 15 # Pagination size, with maximum 100. pagerDirection= \"last\" # Comment sorting direction, available values are 'last' and 'first'. createIssueManually= false # If it is 'false', it is auto to make a Github issue when the administrators login. distractionFreeMode= false # Enable hot key (cmd|ctrl + enter) submit comment. ","date":"2020-07-03","objectID":"/hugo-blog-site/:6:0","tags":null,"title":"使用 Hugo + Github Pages 搭建个人博客","uri":"/hugo-blog-site/"},{"categories":null,"content":"Step 7 - 本地预览 hugo server --buildDrafts -w --buildDrafts: 生成draft博文 -w: 监控修改，自动更新修改过的站点 此时，在http://localhost:1313已经可以访问到博客啦 ","date":"2020-07-03","objectID":"/hugo-blog-site/:7:0","tags":null,"title":"使用 Hugo + Github Pages 搭建个人博客","uri":"/hugo-blog-site/"},{"categories":null,"content":"Step 8 - 编译发布 在myBlog文件夹中编译 hugo 此时，编译后的静态文件会存放在public文件夹 cd public # 进入public文件夹 git init # 建立本地git仓库 git remote add origin https://github.com/[username]/[username].github.io.git # 关联 git add . # add git commit -m \"[commit message]\" # commit git push -u origin master # push 之后发布新博文可以在public直接执行后三条命令add,commit,push即可。 记得draft改为false ","date":"2020-07-03","objectID":"/hugo-blog-site/:8:0","tags":null,"title":"使用 Hugo + Github Pages 搭建个人博客","uri":"/hugo-blog-site/"},{"categories":null,"content":"this is wenzhe’s about ","date":"2020-07-02","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"}]