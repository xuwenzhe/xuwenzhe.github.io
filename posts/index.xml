<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>All Posts - Wenzhe&#39;s Blog</title>
        <link>https://xuwenzhe.github.io/posts/</link>
        <description>All Posts | Wenzhe&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sat, 10 Apr 2021 12:21:34 -0700</lastBuildDate><atom:link href="https://xuwenzhe.github.io/posts/" rel="self" type="application/rss+xml" /><item>
    <title>Java零基础教程（六.面向对象-重要补充）</title>
    <link>https://xuwenzhe.github.io/java-shk-6/</link>
    <pubDate>Sat, 10 Apr 2021 12:21:34 -0700</pubDate>
    <author>Author</author>
    <guid>https://xuwenzhe.github.io/java-shk-6/</guid>
    <description><![CDATA[1. static关键字 1.1 static关键字的使用   static: 静态
  static可以用来修饰：属性，方法，代码块，内部类
  使用static修饰属性: 静态变量（是属性，不是局部变量）或者叫类变量
  属性，按是否使用static修饰，有分为静态属性 vs 非静态属性（实例变量）
 实例变量：我们创建类类的多个对象，每个对象都独立的拥有一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值的修改。 静态变量：我们创建类类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的。    static修饰属性的其他说明：
 静态变量随着类的加载而加载。可以通过“类.静态变量”的方式进行调用 静态变量的加载要早于对象的创建。 由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中。   调用 类变量 实例变量 类 yes no 对象 yes yes      静态属性举例： System.out; Math.PI;
    使用static修饰方法: 静态方法
  随着类的加载而加载，可以通过“类.静态方法”的方式进行调用
   调用 静态方法 非静态方法 类 yes no 对象 yes yes    静态方法中，只能调用静态的方法或属性; 非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性]]></description>
</item><item>
    <title>Java零基础教程（五.面向对象-多态Polymorphism）</title>
    <link>https://xuwenzhe.github.io/java-shk-5/</link>
    <pubDate>Tue, 06 Apr 2021 21:11:00 -0700</pubDate>
    <author>Author</author>
    <guid>https://xuwenzhe.github.io/java-shk-5/</guid>
    <description><![CDATA[1. 多态性使用和理解 面向对象特征之三：多态性
  理解多态性：可以理解为一个事物的多种形态。
  何为多态性：对象的多态性，父类的引用指向子类的对象（或子类的对象赋给父类的引用）
  多态的使用：虚拟方法调用
有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。
总结：编译看左边，运行看右边。
便于站在高处(more generalized)指挥，而不局限于实施细节
  多态性的使用前提：1）类的继承关系 2）方法的重写
  对象的多态性，只适用于方法，不适用于属性。子类不会覆盖父类的同名属性，而是内存都有，编译和运行都看左边。
  虚拟方法调用：（Virtual Method Invocation）
子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚拟方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法确定的。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  package com.atguigu.java4; public class PersonTest { public static void main(String[] args) { Person p1 = new Person(); p1.]]></description>
</item><item>
    <title>Java零基础教程（四.面向对象-继承inheritance）</title>
    <link>https://xuwenzhe.github.io/java-shk-4/</link>
    <pubDate>Sun, 04 Apr 2021 12:20:53 -0700</pubDate>
    <author>Author</author>
    <guid>https://xuwenzhe.github.io/java-shk-4/</guid>
    <description><![CDATA[1. 继承性的使用 面向对象的特征之二：继承性 一·继承性的好处 why？
 减少了代码的冗余，提高了代码的复用性 便于功能的扩展 为之后多态性的使用，提供了前提  二·继承性的格式：class A extends B{}
 A: 子类，派生类，subclass B: 父类，超类，基类，superclass   体现：一旦子类A继承父类B以后，子类A中就获取了父类B中声明的所有的结构：属性，方法。 特别地，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私有的结构。 只是因为封装性的影响，使得子类不能直接调用父类的结构而已。权限修饰符解决的是调用的问题。继承性解决的是能不能获取的问题。 子类继承父类以后，还可以声明自己特有的属性或方法，实现功能的扩展。 子类和父类的关系，不同于子集和集合的关系。  extends：扩展
三·Java中关于继承性的规定
 一个类可以被多个子类继承 Java中类的单继承性：一个类只能有一个父类 子父类是相对的概念。 子类直接继承的父类，称为直接父类。间接继承的父类，称为间接父类。 子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法。  四· Object类
 如果我们没有显式地声明一个类的父类的话，则此类继承于java.lang.Object类 所有的java类（除java.lang.Object类之外）都直接或间接的继承于java.lang.Object类 意味着，所有的java类具有java.lang.Object类声明的功能。  1 2 3 4 5 6 7 8 9 10 11 12 13  package com.atguigu.java; public class ExtendsTest { public static void main(String[] args) { Person p1 = new Person(); p1.]]></description>
</item><item>
    <title>Java零基础教程（三.面向对象-封装Encapsulation）</title>
    <link>https://xuwenzhe.github.io/java-shk-3/</link>
    <pubDate>Sat, 03 Apr 2021 10:47:49 -0700</pubDate>
    <author>Author</author>
    <guid>https://xuwenzhe.github.io/java-shk-3/</guid>
    <description><![CDATA[1. 类和对象 1.1 面向对象的思想 一· Java面向对象学习的三条主线
 Java类及类的成员：属性，方法，构造器，代码块，内部类 面向对象的三大特征：封装性，继承性，多态性，（抽象性） 其他关键字：this, super, static, final, abstract, interface, package, import等。  二·“人把大象装进冰箱”
 面向对象：强调的是功能行为，以函数为最小单位，考虑怎么做。  把冰箱门打开 抬起大象，塞进冰箱 把冰箱门关闭   面向对象：强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  人 { 打开(冰箱) { 冰箱.开开(); } 抬起(大象) { 大象.进入(冰箱); } 关闭(冰箱) { 冰箱.闭合(); } } 冰箱 { 开开(){} 闭合(){} } 大象 { 进入(冰箱){} }   程序员从面向过程的执行者转化成了面向对象的指挥者。]]></description>
</item><item>
    <title>Java零基础教程（二.基本语法）</title>
    <link>https://xuwenzhe.github.io/java-shk-2/</link>
    <pubDate>Wed, 10 Mar 2021 18:49:43 -0800</pubDate>
    <author>Author</author>
    <guid>https://xuwenzhe.github.io/java-shk-2/</guid>
    <description><![CDATA[1. 关键字 数据类型：class, interface, enum, byte, short, int, long, float, double, char, boolean, void
数值：true, false, null
流程控制：if, else, switch, case, default, while, do, for, break, continue, return
访问权限：private, protected, public
类，函数，变量的修饰符：abstract, final, static, synchronized
类与类关系：extends, implements
实例的创建，引用，判断：new, this, super, instanceof
异常处理：try, catch, finally, throw, throws
包：package, import
其他：native, strictfp, transient, volatile, assert
2. 标识符 标识符（aka变量方法类名）的命名规范：
 包：都小写 xxxyyy 类,接口：XxxYyy 变量方法：xxxYyy 常量：XXX_YYY_ZZZ  3. 变量 3.1 数据类型 包含变量类型，变量名，和存储的值。变量都定义在其作用域内，在作用域内，它是有效的，除了作用域就失效了。
 基本数据类型：整数类型byte（-128～127）, short（两字节-2^15～2^15-1）, int(四字节，-21亿～21亿), long（八字节，必须以小写或大写L结尾）； 浮点类型float（四字节，必须以f或F结尾，精确到7位有效数字，范围-3.]]></description>
</item><item>
    <title>Java零基础教程（一.概论）</title>
    <link>https://xuwenzhe.github.io/java-shk/</link>
    <pubDate>Wed, 18 Nov 2020 21:36:11 -0800</pubDate>
    <author>Author</author>
    <guid>https://xuwenzhe.github.io/java-shk/</guid>
    <description><![CDATA[1. 硬件介绍 1.1 CPU（中央处理器） 冯诺伊曼体系结构：冯诺伊曼被人们称为“计算机之父”。计算机由输入设备，输出设备，存储器，运算器，控制器构成。现代计算机中的CPU负责其中的运算与控制功能。
赫兹：现代计算机的计算速度以千兆赫（GHz）来表述。英文进制：KHz，MHz，GHz
Intel i7-6700HQ：“6”第六代，HQ标压版本，U低压版本
摩尔定律：每一美元所能买到的电脑性能，每隔18-24个月翻一倍以上。
1.2 存储 硬盘 硬盘存储的数据断电不丢失（持久化设备）。在windows系统中，A/B盘的位置是预留给软驱的（软驱已经淘汰）。
内存 Read-Access Memory，内存存储数据速度比硬盘快10倍以上，其部分解决了CPU运算过快，而硬盘数据存取太慢的问题。断电会导致数据丢失
bit：二进制表示0/1
byte：8 bits，内存中每个byte拥有唯一的地址。
进制：1KB = 1024B, 1MB = 1024KB, 1GB = 1024MB, 1T = 1024GB, 1PB = 1024TB, EB,ZB,YB,以此类推。
ROM：手机的“硬盘”，例如16GB，128GB。但是经常被大众（误）叫做手机内存。
1.3 输入输出 输入设备： 鼠标键盘； 输出设备： 显示器打印机
1920x1080：像素矩阵
2K屏幕：比如2244x1080（2244&gt;2000）
屏幕尺寸：屏幕对角线长度
像素密度：sqrt(长度像素数^2 + 宽度像素数^2) / 屏幕尺寸
1.4 通信设备 2. 计算机发展史 图灵：计算机之父，人工智能之父
冯诺伊曼：计算机之父，博弈论之父
www（万维网）：简称web。www可以让Web客户端（如浏览器）访问浏览Web服务器上的页面。是一个由许多互相连接的超文本组成的系统，通过互联网访问。在这个系统中，每个有用的事物，称为一样资源，并且由一个全局统一资源标识符（URI）标识；这些资源通过超文本传输协议HTTP（Hypertext Transfer Protocol）传送给用户，用户通过点击链接来获得资源。
万维网vs因特网vs互联网：他们是包含关系。万维网是无数个网络站点和网页集合。因特网除了万维网，还包括电子邮件等。
BS架构，CS架构：browser server（例如百度搜索）； client server（例如QQ）
3. Java语言概述 3.1 编程语言 机器语言 -&gt; 汇编语言 -&gt; 高级语言（面向过程）-&gt; 高级语言（面向对象）]]></description>
</item><item>
    <title>《机器学习实战（第二版）》-读书笔记1</title>
    <link>https://xuwenzhe.github.io/handson-ml2-1/</link>
    <pubDate>Sun, 25 Oct 2020 22:06:32 -0700</pubDate>
    <author>Author</author>
    <guid>https://xuwenzhe.github.io/handson-ml2-1/</guid>
    <description><![CDATA[Chapter 1: The Machine Learning Landscape 下载github库中csv数据集: 1 2 3 4 5 6 7  import urllib.request DOWNLOAD_ROOT = &#34;https://raw.githubusercontent.com/ageron/handson-ml2/master/&#34; os.makedirs(datapath, exist_ok=True) for filename in (&#34;oecd_bli_2015.csv&#34;, &#34;gdp_per_capita.csv&#34;): print(&#34;Downloading&#34;, filename) url = DOWNLOAD_ROOT + &#34;datasets/lifesat/&#34; + filename urllib.request.urlretrieve(url, datapath + filename)   预处理pivot: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  def prepare_country_stats(oecd_bli, gdp_per_capita): # 筛选行 oecd_bli = oecd_bli[oecd_bli[&#34;INEQUALITY&#34;]==&#34;TOT&#34;] # 抽取多行数据为多列数据 oecd_bli = oecd_bli.]]></description>
</item><item>
    <title>Kaggle Regression Eda</title>
    <link>https://xuwenzhe.github.io/kaggle-regression-eda/</link>
    <pubDate>Mon, 19 Oct 2020 18:40:30 -0700</pubDate>
    <author>Author</author>
    <guid>https://xuwenzhe.github.io/kaggle-regression-eda/</guid>
    <description><![CDATA[数据的读入 特征的理解 特征的数据类型 1  df.info(verbose=True) # 查看每列缺省情况和数据类型      Pandas dtype Python type NumPy type Usage     object str or mixed string_, unicode_, mixedtypes 字符串文本   int64 int int_, int8, int16, int32, int64, uint8, uint16, uint32, uint64 整数   float64 float float_, float16, float32, float64 浮点数   bool bool bool_ 真假   datetime64 NA datetime64[ns] 日期与时间   timedelta[ns] NA NA 日期时间差   category NA NA Finite list of text values    特征类型 这个步骤是用来理解数据中每一列的具体含义，通过查看feature与label的关系，可以检查是否符合自己的直观感受。比如，通常情况下，房子越大，房子越新，房价越高，等等。可以通过数据类型将每个feature划归到对应的特征类型，便于后续的分析与建模。]]></description>
</item><item>
    <title>Jenkins 基础</title>
    <link>https://xuwenzhe.github.io/jenkins-intro/</link>
    <pubDate>Sat, 26 Sep 2020 18:46:55 -0700</pubDate>
    <author>Author</author>
    <guid>https://xuwenzhe.github.io/jenkins-intro/</guid>
    <description><![CDATA[]]></description>
</item><item>
    <title>Spark 101: DataFrame基本使用</title>
    <link>https://xuwenzhe.github.io/spark-practice-101/</link>
    <pubDate>Thu, 03 Sep 2020 01:08:40 -0700</pubDate>
    <author>Author</author>
    <guid>https://xuwenzhe.github.io/spark-practice-101/</guid>
    <description><![CDATA[Example 1. DataFrame的5种基本操作 1.筛选行，2.选取列，3.增加行列，4.分组总结，5.排序
一个简单的工资数据集：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  df = spark.createDataFrame([ (1, &#39;sales&#39;, 4200), (2, &#39;admin&#39;, 3100), (3, &#39;sales&#39;, 4000), (4, &#39;sales&#39;, 4000), (5, &#39;admin&#39;, 2700), (6, &#39;dev&#39;, 3400), (7, &#39;dev&#39;, 5200), (8, &#39;dev&#39;, 3700), (9, &#39;dev&#39;, 4400), (10, &#39;dev&#39;, 4400) ], schema=[&#39;id&#39;, &#39;dept&#39;, &#39;salary&#39;]) df.]]></description>
</item></channel>
</rss>
