<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>leetcode on Wenzhe&#39;s Blog</title>
    <link>https://xuwenzhe.github.io/tags/leetcode/</link>
    <description>Recent content in leetcode on Wenzhe&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 16 Jul 2020 12:46:49 -0700</lastBuildDate>
    
	<atom:link href="https://xuwenzhe.github.io/tags/leetcode/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Leetcode：树的Traversal</title>
      <link>https://xuwenzhe.github.io/2020/leetcode-tree-traversal/</link>
      <pubDate>Thu, 16 Jul 2020 12:46:49 -0700</pubDate>
      
      <guid>https://xuwenzhe.github.io/2020/leetcode-tree-traversal/</guid>
      <description>In-Order 230. Kth Smallest Element in a BST (medium) 简述：在BST中，求第k小的值 思路：inorder，记录遍历idx 联系：模板题 # class Solution(object): # def kthSmallest(self, root, k): # &amp;#34;&amp;#34;&amp;#34; # :type root: TreeNode # :type k: int # :rtype: int #</description>
    </item>
    
    <item>
      <title>Leetcode：树的Divide &amp; Conquer</title>
      <link>https://xuwenzhe.github.io/2020/leetcode-divide-conquer/</link>
      <pubDate>Fri, 10 Jul 2020 00:20:03 -0700</pubDate>
      
      <guid>https://xuwenzhe.github.io/2020/leetcode-divide-conquer/</guid>
      <description>100. Same Tree (easy) 简述：判断两棵二叉树是否相同 思路：分治法 联系：模板题 # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None # class Solution(object): # def isSameTree(self, p, q): # &amp;#34;&amp;#34;&amp;#34; # :type p: TreeNode</description>
    </item>
    
    <item>
      <title>Leetcode：二分查找</title>
      <link>https://xuwenzhe.github.io/2020/leetcode-binary-search/</link>
      <pubDate>Tue, 07 Jul 2020 19:47:02 -0700</pubDate>
      
      <guid>https://xuwenzhe.github.io/2020/leetcode-binary-search/</guid>
      <description>模板 # def binarySearch(nums, target): # if len(nums) == 0: # return -1 # start, end = 0, len(nums) - 1 while start + 1 &amp;lt; end: # 要点3-1 mid = (start + end) // 2 # 要点3-2: python动态数据类型 # if nums[start] &amp;lt; target: start = mid # 要</description>
    </item>
    
  </channel>
</rss>